## Переменные и параметры

В этой книге не раз упоминались переменные в Bash. Нам уже знаком список системных путей в переменной `PATH`. Мы использовали позиционные параметры в скрипте для резервного копирования. Настало время хорошо разобраться в этой теме.

Сначала выясним, что называется переменной в программировании. Это область памяти (обычно оперативной), в которой хранится значение. В первых языках программирования (например, [**ассемблере**](https://ru.wikipedia.org/wiki/Язык_ассемблера)) обращение к переменным происходит по их адресу. То есть, чтобы записать новое значение или прочитать текущее, надо указать адрес памяти. В 32-разрядных процессорах длина адреса 4 байта (число от 0 до 4294967295), а в 64-разрядных она в два раза больше. Запоминать и оперировать такими большими числами неудобно. Поэтому современные языки программирования позволяют заменять адреса переменных на их имена. Эти имена в процессе компиляции или интерпретации программы транслируются в адреса памяти. Таким образом всю работу по "запоминанию" больших чисел берёт на себя компилятор или интерпретатор.

Зачем нужны переменные? Наш опыт работы с `PATH` и позиционными параметрами показал, что переменные хранят какие-то данные. Это нужно для одной из следующих целей:

1. Передать информацию из одной части программы или системы в другую.

2. Сохранить промежуточный результат вычислений для дальнейшего использования.

3. Сохранить текущее состояние программы или системы. Это состояние может определять дальнейшее поведение.

4. Задать константное значение, которое позже будет многократно использоваться.

Для каждой цели в языках программирования вводится специальный тип переменной. Язык Bash не исключение.

### Классификация переменных

У интерпретатора Bash есть два режима работы: интерактивный (командная оболочка) и неинтерактивном (исполнение скриптов). В каждом режиме переменные решают сходные задачи. Но контексты этих задач различаются. Поэтому признаков для классификации переменных в Bash больше, чем в других интерпретируемых языках.

Упростим терминологию для удобства. Это не совсем правильно, но позволит избежать путаницы. Когда говорим о скриптах, будем использовать термин "переменная" (variable). Когда речь о командной оболочке и аргументах командной строки, будем применять термин "параметр" (parameter). В английской литературе эти термины часто используют как синонимы.

Для классификации переменных в Bash есть четыре признака. Они приведены в таблице 3-1.

{caption: "Таблица 3-1. Классификация переменных в Bash", width: "100%"}
| Признак классификации | Типы | Определение | Примеры |
| --- | --- | --- | --- |
| Механизм установки | Пользовательские переменные | Устанавливаются пользователем. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
|                    | Зарезервированные (системные) переменные | Устанавливаются интерпретатором и нужны для его корректной работы. | `echo "$PATH"` |
|  | | | |
|                    | Специальные параметры | Устанавливаются интерпретатором и доступны только для чтения. | `echo "$?"` |
|  | | | |
| [Область видимости](https://ru.wikipedia.org/wiki/Область_видимости) | Переменные окружения (или глобальные) | Доступны в любом экземпляре интерпретатора. Выводятся утилитой `env`, запущенной без параметров. | `echo "$PATH"` |
|  | | | |
|                     | Локальные переменные | Доступны только в конкретном экземпляре интерпретатора. | `filename="README.txt" ; echo "$filename"` |
|  | | | |
| Содержимое | Строка | Хранит строку. | `filename="README.txt"` |
|  | | | |
|            | Число | Хранит целое число. | `declare -i number=10/2 ; echo "$number"` |
|  | | | |
|            | Индексируемый массив | Хранит нумерованный список строк. | `cities=("London" "New York" "Berlin") ; echo "${cities[1]}"` |
|  | | | `cities[0]="London" ; cities[1]="New York" ; cities[2]="Berlin" ; echo "${cities[1]}"` |
|  | | | |
|            | [**Ассоциативный массив**](https://ru.wikipedia.org/wiki/Ассоциативный_массив) | Структура данных, каждый элемент которой — это пара ключ-значение. Ключом и значением являются строки. | `declare -A cities=( ["Alice"]="London" ["Bob"]="New York" ["Eve"]="Berlin" ) ; echo "${cities[Bob]}"` |
|  | | | |
| Возможность изменения | Константны | Не могут быть удалены. Хранят значения, которые нельзя переопределить. | `readonly CONSTANT="ABC" ; echo "$CONSTANT"` |
|                     | | | `declare -r CONSTANT="ABC" ; echo "$CONSTANT"` |
|  | | | |
|                     | Переменные | Могут быть удалены. Их значения можно переопределить. | `filename="README.txt"` |

Рассмотрим каждый тип переменных.

### Механизм установки

#### Пользовательские переменные

Назначение пользовательских переменных очевидно из названия. Их объявляет пользователь для своих целей. Такие переменные обычно хранят промежуточные результаты работы скрипта, его состояние и часто используемые константы.

Чтобы объявить пользовательскую переменную, укажите её имя, поставьте знак равно и наберите значение переменной.

Рассмотрим пример. Объявим переменную с именем `filename`. В ней хранится имя файла `README.txt`. Объявление переменной выглядит так:
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Пробелы до и после знака равно не ставятся. Другие языки программирования это допускают, но не Bash. Это значит, что интерпретатор не сможет обработать следующее объявление:
{line-numbers: false, format: Bash}
```
filename = "README.txt"
```

Bash интерпретируют эту строку как вызов команды `filename` с двумя параметрами `=` и `"README.txt"`

В именах переменных допустимы только символы латинского алфавита, числа и знак подчёркивания `_`. Имя не должно начинаться с числа. Регистр букв важен. Это значит, что `filename` и `FILENAME` — две разные переменные.

Предположим, что мы объявили переменную `filename`. В результате для неё выделилась область в памяти процесса интерпретатора. В этой области сохранилась строка `README.txt`. Чтобы прочитать строку из памяти, к переменной надо обратиться по имени. При этом интерпретатор Bash должен понять, что вы имеете в виду. Если поставить знак доллара $ перед словом `filename`, Bash обработает его как имя переменной.

Обращение к переменной в команде или скрипте должно выглядеть так:
{line-numbers: false, format: Bash}
```
$filename
```

Bash обрабатывает слова со знаком доллара по-особенному. Встретив такое слово в команде, интерпретатор запускает механизм подстановки переменных (**parameter expansion**). Этот механизм заменяет все вхождения имени переменной на её значение. Рассмотрим следующую команду:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки переменных она будет выглядеть так:
{line-numbers: false, format: Bash}
```
cp README.txt ~
```

Всего интерпретатор совершает девять видов подстановок. Порядок их выполнения важен. Если его не учесть, могут возникнуть ошибки. Рассмотрим пример такой ошибки. Предположим, что в скрипте мы работаем с файлом "my file.txt". Для удобства поместим его имя в переменную. Её объявление выглядит так:
{line-numbers: false, format: Bash}
```
filename="my file.txt"
```

Далее переменная используется в вызове утилиты cp. Команда её вызова выглядит так:
{line-numbers: false, format: Bash}
```
cp $filename ~
```

После подстановки переменных Bash выполняет word splitting. Это другой механизм подстановки. После него вызов утилиты cp станет таким:
{line-numbers: false, format: Bash}
```
cp my file.txt ~
```

Эта команда завершится с ошибкой. Вместо одного параметра с именем файла, в утилиту cp передаются два: `my` и `file.txt`. Таких файлов не существует.

Если в значении переменной встречается специальный символ, опять возникнет проблема. Например:
{line-numbers: true, format: Bash}
```
filename="*file.txt"
rm $filename
```

В результате вызова утилиты rm будут удалены все файлы, заканчивающиеся на `file.txt`. В этом виноват механизм globbing. Он тоже выполняется после подстановки переменных. После globbing в утилиту rm будут переданы все файлы из текущего каталога, имена которых соответствуют шаблону поиска `*file.txt`. Это может привести к неожиданному результату. Например, такому:
{line-numbers: false, format: Bash}
```
rm report_file.txt myfile.txt msg_file.txt
```

Чтобы избежать нежелательных подстановок Bash, заключайте все обращения к переменным в двойные кавычки ". Например, так:
{line-numbers: true, format: Bash}
```
filename1="my file.txt"
cp "$filename1" ~

filename2="*file.txt"
rm "$filename2"
```

Благодаря кавычкам, значение переменной будет подставлено без дальнейших изменений:
{line-numbers: true, format: Bash}
```
cp "my file.txt" ~
rm "*file.txt"
```

Мы уже знаем несколько [подстановок](http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Shell-Expansions), которые выполняет Bash. Таблица 3-2 приводит их полный список и порядок выполнения. 

{caption: "Таблица 3-2. Подстановки Bash", width: "100%"}
| Порядок выполнения | Подстановка | Комментарий | Пример |
| --- | --- | --- | --- |
| 1 | Brace Expansion | Подстановка фигурных скобок { и }. | `echo a{d,c,b}e` |
|  | | | |
| 2 | Tilde Expansion | Подстановка символа тильда ~. | `cd ~` |
|  | | | |
| 3 | Parameter Expansion | Подстановка параметров и переменных. | `echo "$PATH"` |
|  | | | |
| 4 | Arithmetic Expansion | Подстановка вместо арифметических выражений их результатов. | `echo $((4+3))` |
|  | | | |
| 5 | Command Substitution | Подстановка вместо команды её вывода. | `echo $(< README.txt)` |
|  | | | |
| 6 | Process Substitution | Подстановка вместо команды её вывода. В отличие от Command Substitution эта подстановка выполняется [асинхронно](https://ru.wikipedia.org/wiki/Асинхронность#Асинхронность_в_информатике). Ввод и вывод команды привязаны к временному файлу. | `diff <(sort file1.txt) <(sort file2.txt)` |
|  | | | |
| 7 | Word Splitting | Разделение аргументов командной строки на слова и передача их в качестве отдельных параметров. | `cp file1.txt file2.txt ~` |
|  | | | |
| 8 | Filename Expansion (globbing) | Подстановка имён файлов вместо шаблонов. | `rm ~/delete/*` |
|  | | | |
| 9 | Quote Removal | Удаление всех неэкранированных символов \, ' и ", которые не были получены в результате одной из предыдущих подстановок. | `cp "my file.txt" ~` |

{caption: "Упражнение 3-1. Тестирование подстановок Bash", format: text, line-numbers: false}
```
Выполните в терминале пример каждой подстановки Bash из таблицы 3-2.
Разберитесь, как получилась конечная команда.
Придумайте свои примеры.
```

Знак $ перед именем переменной — это сокращенная форма подстановки переменных. В полном виде она выглядит так:
{line-numbers: false, format: Bash}
```
${filename}
```

Используйте полную форму, чтобы избежать неоднозначности. Например, если сразу за именем переменной следует текст:
{line-numbers: true, format: Bash}
```
prefix="my"
name="file.txt"
cp "$prefix_$name" ~
```

Тогда интерпретатор ищет переменную с именем `prefix_`. То есть он приклеит символ подчёркивания к имени переменной. Полная форма записи подстановки переменных решит эту проблему:
{line-numbers: false, format: Bash}
```
cp "${prefix}_${name}" ~
```

Альтернативное решение — заключить каждое имя переменной в кавычки. Например, так:
{line-numbers: false, format: Bash}
```
cp "$prefix"_"$name" ~
```

Полная форма записи подстановки переменных устраняет неоднозначности. Кроме этого она поможет, когда переменная не была определена. В этом случае можно подставить некоторое значение по умолчанию. Например:
{line-numbers: false, format: Bash}
```
cp file.txt "${directory:-~}"
```

При обработке этой команды Bash проверит, определена ли переменная `directory` и имеет ли она непустое значение. Если это так, выполнится обычная подстановка. В противном случае Bash подставит значение, следующее за символом минус -. В нашем примере — это домашний каталог пользователя ~.

Задать значение по умолчанию можно несколькими способами. Все они приведены в таблице 3-3.

{caption: "Таблица 3-3. Задание значения по умолчанию при подстановке", width: "100%"}
| Форма записи | Описание|
| --- | --- |
| `${parameter:-word}` | Если переменная `parameter` не объявлена или имеет пустое значение, будет подставлено значение по умолчанию `word`. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:=word}` | Если переменная не объявлена или имеет пустое значение, ей будет присвоено значение по умолчанию. Затем она будет подставлена. В противном случае подставляется значение переменной. Переопределение позиционных и специальных параметров таким способом недопустимо. |
|  | |
| `${parameter:?word}` | Если переменная не объявлена или имеет пустое значение, значение по умолчанию будет выведено в стандартный поток ошибок. После этого выполнение скрипта будет завершено с кодом возврата отличным от 0. В противном случае подставляется значение переменной. |
|  | |
| `${parameter:+word}` | Если переменная не объявлена или имеет пустое значение, подстановки не будет. В противном случае подставляется значение по умолчанию. |

{caption: "Упражнение 3-2. Полная форма подстановки параметров", format: text, line-numbers: false}
```
Напишите скрипт, который ищет файлы с расширением TXT в текущем каталоге.
Скрипт игнорирует подкаталоги.
Все найденные файлы копируются или перемещаются в домашний каталог пользователя.
При вызове скрипта можно выбрать действие: копировать или перемещать файлы.
Если действие не указано, выполняется копирование.
```

#### Зарезервированные переменные

Переменные может объявлять не только пользователь, но и сам интерпретатор. В этом случае они называются **зарезервированными** (reserved) или **переменными оболочки** (shell variables). Интерпретатор присваивает им значение по умолчанию. Значение некоторых переменных оболочки можно изменить.

Зарезервированные переменные исполняют две функции:

1. Передача информации от командного интерпретатора в запускаемое им приложение.

2. Хранение текущего состояния самого интерпретатора.

Переменные оболочки делятся на две группы:

1. Переменные Bourne Shell.

2. Переменные Bash.

Первая группа унаследована из Bourne Shell и нужна Bash для POSIX-совместимости. Часто используемые из этих переменных представлены в таблице 3-4.

{caption: "Таблица 3-4. Зарезервированные переменные Bourne Shell", width: "100%"}
| Имя | Значение |
| --- | --- |
| `HOME` | Домашний каталог текущего пользователя. Значение переменной используется при вызове встроенной команды `cd` без параметров и подстановке символа тильда `~`. |
|  | |
| [`IFS`](http://mywiki.wooledge.org/IFS) | Список следующих друг за другом символов-разделителей. Вводимые строки будут разделены этими символами на слова (например, при word splitting). По умолчанию разделители такие: пробел, [табуляция](https://ru.wikipedia.org/wiki/Табуляция), перевод строки. |
|  | |
| `PATH` | Список путей, по которым интерпретатор ищет вызываемые утилиты и программы. Пути в списке разделены двоеточиями. |
|  | |
| `PS1` | Приглашение командной строки. Может включать [управляющие символы](https://www.gnu.org/software/bash/manual/html_node/Controlling-the-Prompt.html#Controlling-the-Prompt). Перед выводом на экран они заменятся на конкретные значения (например, имя текущего пользователя). |

Кроме унаследованных переменных оболочки Bourne Shell в Bash появились новые. Они приведены в таблице 3-5. Кроме перечисленных есть и другие переменные Bash, но они используются редко.

{caption: "Таблица 3-5. Зарезервированные переменные Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `BASH` | Полный путь до исполняемого файла Bash. Этот файл соответствует текущему процессу Bash. |
|  | |
| `BASHOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) текущего процесса Bash. Опции в списке разделены двоеточиями. |
|  | |
| `BASH_VERSION` | Версия запущенного Bash интерпретатора. |
|  | |
| `GROUPS` | Список групп, к которым относится текущий пользователь. |
|  | |
| `HISTCMD` | Номер текущей команды в истории команд. |
|  | |
| `HISTFILE` | Файл, в котором сохраняется история команд. По умолчанию это `~/.bash_history`. |
|  | |
| `HISTFILESIZE` | Максимально допустимое число строк в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HISTSIZE` | Максимально допустимое число команд в файле истории команд. Значение по умолчанию 500. |
|  | |
| `HOSTNAME` | Имя текущего компьютера как узла вычислительной сети. |
|  | |
| `HOSTTYPE` | Строка с описанием аппаратной платформы, на которой запущен Bash. |
|  | |
| `LANG` | [Региональные настройки](https://ru.wikipedia.org/wiki/Региональные_настройки_(программирование)) пользовательского интерфейса. Некоторые из них переопределяются переменными `LC_ALL`, `LC_COLLATE`, `LC_CTYPE`, `LC_MESSAGES`, `LC_NUMERIC`, `LC_TYPE`. |
|  | |
| `MACHTYPE` | Строка с описанием системы, на которой запущен Bash. Включает в себя информацию из переменных `HOSTTYPE` и `OSTYPE`. |
|  | |
| `OLDPWD` | Предыдущий рабочий каталог, который устанавливала встроенная команда `cd`. |
|  | |
| `OSTYPE` | Строка с описанием ОС, на которой запущен Bash. |
|  | |
| `POSIXLY_CORRECT` | Если эта переменная определена, Bash работает в режиме [POSIX-совместимости](https://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html#Bash-POSIX-Mode). |
|  | |
| `PWD` | Текущий каталог, который установила встроенная команда `cd`. |
|  | |
| `RANDOM` | Каждый раз при чтении этой переменной возвращается случайное число от 0 до 32767. При записи переменной назначается инициализирующее число ([seed](https://en.wikipedia.org/wiki/Random_seed)) для [генератора псевдослучайных чисел](https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел). |
|  | |
| `SECONDS` | Количество секунд, прошедших с момента запуска текущего процесса Bash. |
|  | |
| `SHELL` | Полный путь к исполняемому файлу командного интерпретатора для текущего пользователя. |
|  | |
| `SHELLOPTS` | Список [дополнительных опций](https://www.gnu.org/software/bash/manual/html_node/The-Shopt-Builtin.html#The-Shopt-Builtin) комндного интерпретатора. Опции в списке разделены двоеточиями. |
|  | |
| `SHLVL` | Уровень вложенности текущего экземпляра Bash. Эта переменная увеличивается на единицу каждый раз при запуске Bash из командного интерпретатора. |
|  | |
| `UID` | Идентификатор текущего пользователя. |

Зарезервированные переменные делятся на три группы в зависимости от допустимых над ними действий:

1. При запуске интерпретатор назначает переменной значение. В течении всей сессии оно остаётся неизменным. Пользователь может его прочитать, но не изменить. Примеры: `BASHOPTS`, `GROUPS`, `SHELLOPTS`, `UID`.

2. При запуске интерпретатор назначает переменной значение по умолчанию. Оно меняется в результате выполнения пользователем команд или иных событий. Значение некоторых переменных можно переобъявить явно, но это может нарушить работу интерпретатора. Примеры: `HISTCMD`, `OLDPWD`, `PWD`, `SECONDS`, `SHLVL`.

3. При запуске интерпретатор назначает переменной значение по умолчанию. Единственный способ его изменить — это переобъявить. Примеры: `HISTFILESIZE`, `HISTSIZE`

#### Специальные параметры

Специальные параметры назначаются интерпретатором, как и переменные оболочки. Некоторые параметры хранят состояние запущенного экземпляра Bash (например, PID). Другие нужны для передачи параметров командной строки в вызываемые приложения и чтения их кода возврата. Все позиционные параметры относятся к специальным.

Часто используемые специальные параметры приведены в таблице 3-6.

{caption: "Таблица 3-6. Специальные параметры Bash", width: "100%"}
| Имя | Значение |
| --- | --- |
| `$*` | Содержит все позиционные параметры, переданные в скрипт. Параметры начинаются не с нулевого (`$0`), а с первого (`$1`). Без двойных кавычек (`$*`), каждый позиционный параметр подставляется как отдельное слово. С двойными кавычками (`"$*"`), Bash подставляет одно слово, содержащее все параметры. Они разделяются первым символом зарезервированной переменной `IFS`. |
|  | |
| `$@` | Массив со всеми позиционными параметрами, переданными в скрипт. Параметры начинаются с первого (`$1`). Без двойных кавычек (`$@`), Bash обрабатывает каждый элемент массива как строку без кавычек. В этом случе выполняется word splitting. С Двойными кавычками ("$@"), Bash обрабатывает каждый элемент массива как строку с кавычками. Wird splitting не происходит. |
|  | |
| `$1`, `$2`... | Содержит значение соответствующего позиционного параметра. `$1` соответствует первому параметру, `$2` — второму и т.д. Номера указываются в десятичной системе. |
|  | |
| `$?` | Код возврата последней выполненной команды в активном режиме (foreground). Если команды выполнялись в конвейере, параметр хранит код возврата последней из них. |
|  | |
| `$-` | Содержит опции текущего экземпляра интерпретатора. |
|  | |
| `$$` | Идентификатор процесса текущего экземпляра интерпретатора. При подстановке в subshell, возвращает PID родительского процесса. |
|  | |
| `$!` | Идентификатор процесса PID последней команды, запущенной в фоновом режиме. |
|  | |
| `$0` | Имя текущего командного интерпретатора или выполняемого в данный момент скрипта. |
|  | |

Специальные параметры нельзя менять непосредственно. Например, следующее перезапись параметра `$1` не сработает:
{line-numbers: false, format: Bash}
```
1="new value"
```

Позиционные параметры можно изменять командой set. Она перезаписывает не один параметр, а сразу все. Форма вызова set в этом случае следующая:
{line-numbers: false, format: Bash}
```
set -- НОВОЕ_ЗНАЧЕНИЕ_$1 НОВОЕ_ЗНАЧЕНИЕ_$2 НОВОЕ_ЗНАЧЕНИЕ_$3...
```

Что делать, если нужно изменить только один параметр? Предположим, ваш скрипт вызывается с четырьмя параметрами. Например, так:
{line-numbers: false, format: Bash}
```
./my_script.sh arg1 arg2 arg3 arg4
```

Заменим третий параметр `arg3` на значение `new`. Это сделает такой вызов set:
{line-numbers: false, format: Bash}
```
set -- "${@:1:2}" "new" "${@:4}"
```

Первый аргумент set — подстановка первых двух элементов из массива `$@`. Второй аргумент — новое значение третьего параметра. Дальше подставляются все параметры, начиная с четвертого.

Все специальные параметры из таблицы 3-6 доступны в режиме POSIX-совместимости.

### Область видимости

#### Переменные окружения

В любой программе и программной системе переменные разделены по **областям видимости** (scope). Область видимости — это часть программы или системы, в которой имя переменной остаётся связанным с её значением. Другими словами конвертировать имя переменной в её адрес можно только в области видимости этой переменной. За пределами области видимости то же самое имя может быть связано с другой переменной.

Область видимости называется **глобальной** (global scope), если распространяется на всю систему. То есть переменные этой области видимости доступны из любой части программы или системы.

Все зарезервированные переменные Bash находятся в глобальной области видимости. Переменные в этой области видимости называются **переменными окружения** (environment variables). Получается, что все зарезервированные переменные являются переменными окружения. Пользовательские переменные также можно объявлять в глобальной области видимости. Тогда они станут переменными окружения.

Зачем интерпретатор хранит переменные в глобальной области видимости? Дело в том, что в Unix есть специальный набор настроек. Они влияют на поведение запускаемых пользователем приложений. Например, региональные настройки. Согласно им каждое запущенное приложение адаптирует свой интерфейс. Именно такие настройки передаются через переменные окружения.

Предположим, что один процесс порождает дочерний процесс. В этом случае дочерний процесс копирует все переменные окружения родителя. Таким образом все утилиты и приложения, запущенные из командного интерпретатора, наследуют его переменные окружения. Так глобальные настройки передаются во все запускаемые пользователем программы.

Дочерние процессы могут изменять свои переменные окружения. В результате порождённые ими процессы унаследуют эти изменения. Однако, это никак не отразится на соответствующих переменных родительского процесса.

Чтобы объявить переменную окружения, используйте встроенную команду export. Например:
{line-numbers: false, format: Bash}
```
export BROWSER_PATH="/opt/firefox/bin"
```

Переменную можно сначала объявить, а потом поместить в глобальную область видимости. Например:
{line-numbers: true, format: Bash}
```
BROWSER_PATH="/opt/firefox/bin"
export BROWSER_PATH
```

Переменные окружения можно объявлять и переопределять для каждого запускаемого приложения отдельно. Для этого в команде вызова программы перечислите их имена и значения через пробел. Например, следующим образом:
{line-numbers: false, format: Bash}
```
MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Такое решение работает для интерпретатора Bash. Для других интерпретаторов (например, Bourne Shell) придётся использовать утилиту env. Вызовите утилиту, перечислите через пробел переменные окружения и добавьте команду запуска приложения. Например, так:
{line-numbers: false, format: Bash}
```
env MOZ_WEBRENDER=1 LANG="en_US.UTF-8" /opt/firefox/bin/firefox
```

Вызовите утилиту env без параметров. Она выведет все объявленные переменные окружения для текущего экземпляра интерпретатора. Попробуйте получить этот вывод в своём терминале:
{line-numbers: false, format: Bash}
```
env
```

Команда export и утилита env выводят одно и то же, если вызвать их без параметров. Предпочтительней использовать export. Во-первых, вывод команды отсортирован. Во-вторых, все значения переменных заключены в двойные кавычки. Это убережёт вас от ошибки, если в значении переменной встретится перевод строки.

Исторически сложилось так, что имена переменных окружения пишутся буквами в верхнем регистре. Поэтому давать имена локальным переменным в нижнем регистре считается хорошей практикой. Таким образом вы предотвратите случайное использование одной переменной вместо другой.

#### Локальные переменные

Мы познакомились с пользовательскими переменными. В зависимости от способа их объявления они могут быть **локальными** или переменными окружения (глобальными).

Добавить переменную в глобальную область видимости можно одним из следующих способов:

1. Добавить команду export в объявление переменной.

2. Передать переменную при запуске программы. Это можно сделать как с помощью утилиты env, так и без неё.

Если вы не сделали ничего из перечисленного, переменная будет локальной. Она будет доступна только в текущем экземпляре интерпретатора. Говорят, что локальная переменная имеет **ограниченную область видимости** (local scope). При этом никакие дочерние процессы (кроме subshell) её не наследуют.

Рассмотрим пример. Предположим, что вы объявили переменную в окне терминала MSYS2 следующим образом: 
{line-numbers: false, format: Bash}
```
filename="README.txt"
```

Теперь в этом же окне терминала вы можете вывести её значение:
{line-numbers: false, format: Bash}
```
echo "$filename"
```

Та же самая команда отработает корректно, если выполнить её в subshell:
{line-numbers: false, format: Bash}
```
(echo "$filename")
```

Однако, если прочитать значение переменной из дочернего процесса, получится пустое значение. Чтобы запустить дочерний процесс, вызовите новый экземпляр интерпретатора в окне терминала. Например, так:
{line-numbers: false, format: Bash}
```
bash -c 'echo "$filename"'
```

В опции `-c` передаётся команда, которая выполнится дочерним процессом Bash. Аналогичный вызов Bash происходит неявно при запуске скрипта из командного интерпретатора.

Обратите внимание на одинарные кавычки ', в которые мы поместили вызов echo. Они отключают все подстановки для строки в них. У двойных кавычек поведение отличается. Они разрешают только подстановку команд и параметров. Если в нашем вызове `bash` использовать двойные кавычки, то произойдёт подстановка параметров. В результате команда запуска дочернего процесса Bash станет такой:
{line-numbers: false, format: Bash}
```
bash -c "echo README.txt"
```

Это совсем не то, что нам нужно. Мы проверяем, как дочерний процесс прочитает значение локальной переменной. В данном случае родительский процесс уже подставил это значение в вызов `bash`.

При изменении локальной переменной в subshell, её значение в родительском процессе не изменится. Например, в результате следующих команд напечатается строка "README.txt":
{line-numbers: true, format: Bash}
```
filename="README.txt"
(filename="CHANGELOG.txt")
echo "$filename"
```

То есть присвоение переменной `filename` нового значения в subshell никак не отразилось на родительском процессе.

После объявления локальной переменной она попадает в список **переменных оболочки** (shell variables). К ним относятся все локальные переменные и переменные окружения, доступные в текущем экземпляре интерпретатора. Их можно вывести встроенной командой set, если запустить её без параметров. Попробуйте найти нашу переменную `filename` следующим образом:
{line-numbers: false, format: Bash}
```
set | grep filename=
```

В выводе этой команды вы увидите следующую строку:
{line-numbers: false, format: Bash}
```
filename=README.txt
```

Это значит, что переменная `filename` попала в список переменных оболочки.

### Содержимое переменной

#### Типы переменных

В компилируемых языках программирования (например, C) принято использовать [**статическую типизацию**](https://ru.wikipedia.org/wiki/Статическая_типизация). Это означает, что при объявлении переменной указывается, как хранить её значение в памяти. Рассмотрим пример, чтобы лучше понять о чём речь.

Предположим, что мы объявляем переменную с именем `number`. В объявлении обязательно надо указать её тип. Например, целое беззнаковое (положительное) число размером два байта. В результате на эту переменную в памяти будет отведено ровно два байта. Далее переменной присваиваем значение 203 или 0xCB в шестнадцатеричной системе. В памяти это значение сохранится в следующем виде:
{line-numbers: false, format: Bash}
```
00 CB
```

I> На самом деле в памяти современного компьютера вся информация хранится в двоичном виде. Вместо двоичного мы используем шестнадцатеричный формат для наглядности.

Чтобы хранить значение 203, достаточно и одного байта. Но при объявлении переменной мы зарезервировали два. Неиспользуемый байт в нашем случае останется равным нулю. Во всей области видимости переменной `number` никто не сможет использовать этот байт. Если переменная находится в глобальной области видимости, на протяжении работы программы этот байт будет зарезервирован и не использован.

Если переменной присвоить значение 14037 или 0x36D5, в отведённую ей область памяти запишутся следующие два байта:
{line-numbers: false, format: Bash}
```
36 D5
```

I> [**Порядок байтов**](https://ru.wikipedia.org/wiki/Порядок_байтов) (endianness) при хранении чисел в памяти определяется свойствами CPU. В нашем примере порядок байтов от старшего к младшему (big-endian). Альтернативный порядок — от младшего к старшему (little-endian).

Теперь предположим, что в переменной нужно сохранить значение 107981 или 0x1A5CD. Это число не помещается в два байта. Размер переменной определён при её объявлении и не может быть автоматически расширен. Поэтому записываемое значение будет обрезано до двух байтов. В результате в памяти окажется следующее:
{line-numbers: false, format: Bash}
```
A5 CD
```

Старшая единица была отброшена. Теперь если вы прочитаете значение переменной `number`, то получите 42445 или 0xA5CD. Это значит, что записанное в `number` число 107981 потеряно и его невозможно восстановить. Такая проблема называется [**переполнением**](https://ru.wikipedia.org/wiki/Целочисленное_переполнение).

Рассмотрим другой пример статической типизации. Предположим, что нам нужно сохранить имя пользователя в переменной `username`. Для этого объявляем переменную строкового типа. Во многих компилируемых языках программирования при объявлении строки надо указать её допустимую длину. Для примера длина составляет десять символов. После объявления переменной присваиваем ей значение "Alice" в ASCII-кодировке. Если использовать компилятор языка C, строка в памяти будет выглядеть так:
{line-numbers: false, format: Bash}
```
41 6C 69 63 65 00 00 00 00 00
```

I> ASCII-коды букв в шестнадцатеричной системе можно проверить по [таблице](https://ru.wikipedia.org/wiki/ASCII).

Для хранения строки "Alice" достаточно шести байтов: пять для каждой буквы плюс один для нуль-терминатора (00) на конце. Однако, мы зарезервировали десять байтов, поэтому неиспользуемая память будет заполнена нулями или случайными значениями.

[**Динамическая типизация**](https://ru.wikipedia.org/wiki/Динамическая_типизация) — это альтернатива статической типизации. При динамической типизации способ хранения переменной выбирается иначе. Это происходит не в момент объявления переменной, а в момент присваивания ей нового значения. При присваивании переменной назначается [**метаинформация**](https://ru.wikipedia.org/wiki/Метаданные) о её текущем типе. Пока программа исполняется, значение переменной и соответствующая метаинформация могут меняться. Таким образом представление переменной в памяти также меняется. Динамическая типизация обычно применяется в интерпретируемых языках программирования (например, Python).

I> Метаинформация — это дополнительная информация о каком-либо объекте или данных. [Библиотечный каталог](https://ru.wikipedia.org/wiki/Библиотечный_каталог) — хороший пример метаинформации. В нём для каждой книги заведена карточка. В карточке указывается автор, название произведения, издательство, год издания и количество страниц. Карточка содержит метаинформацию о книге.

Строго говоря, в языке Bash нет системы типов. Его нельзя считать языком со статической или динамической типизацией. В Bash все [**скалярные переменные**](https://en.wikipedia.org/wiki/Variable_(computer_science)) являются строками.

Скалярной называется переменная, которая хранит данные [**примитивного типа**](https://ru.wikipedia.org/wiki/Примитивный_тип). Это минимальные строительные блоки из которых собираются данные более сложных [**составных типов**](https://en.wikipedia.org/wiki/Composite_data_type). Как правило, скалярная переменная — это просто имя для адреса памяти, по которому хранится её значение.

Рассмотрим, как Bash представляет свои скалярные переменные в памяти. Есть следующее объявление:
{line-numbers: false, format: Bash}
```
declare -i number=42
```

В памяти переменная `number` будет сохранена как строка:
{line-numbers: false, format: Bash}
```
34 32 00
```

В языке с системой типов достаточно одного байта для хранения этого числа. Но в Bash нам потребовалось три: по байту для каждого символа (4 и 2) плюс нуль-терминатор на конце.

В Bourne Shell есть только скалярные переменные. В Bash появились два новых составных типа: индексируемый [**массив**](https://ru.wikipedia.org/wiki/Массив_(тип_данных)) и ассоциативный массив.

Индексируемый массив представляет собой пронумерованный набор строк. В нём каждой строке соответствует порядковый номер. Массивы этого типа хранятся в памяти в виде [**связанного списка**](https://ru.wikipedia.org/wiki/Связный_список). Связанный список — это структура данных, состоящая из узлов. Каждый узел содержит данные (в нашем случае строку) и адрес в памяти следующего узла.

Ассоциативный массив устроен сложнее. Он представляет собой набор элементов. Каждый элемент состоит из двух строк. Первая из них называется ключом, а вторая — значением. Чтобы прочитать или записать строку в массив, нужно указать соответствующий ей ключ. Точно так же в индексируемом массиве для доступа к строке указывается её порядковый номер. Очевидно, что под одним номером может храниться только одна строка. Аналогично один ключ в ассоциативном массиве соответствует только одной строке. В памяти такой массив хранится в виде [**хеш-таблицы**](https://ru.wikipedia.org/wiki/Хеш-таблица).

Почему "массивы" в Bash называются массивами? Ведь фактически они представляют собой связанные списки и хэш-таблицы. Настоящий массив — это структура данных, элементы которой хранятся в памяти последовательно друг за другом. У каждого элемента есть порядковый номер, называемый **индексом** (index) или идентификатором. Элементы "массивов" в Bash хранятся в памяти не последовательно. Значит согласно определению, это не массивы.

Рассмотрим, как элементы настоящего массива хранятся в памяти. Предположим, у нас есть массив с числами от пяти до девяти. Каждый его элемент занимает один байт. Тогда размер массива равен пяти байтам. В памяти он будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
05 06 07 08 09
```

Индексы начинаются с нуля. Тогда элемент с порядковым номером ноль равен пяти, а с номером три — восьми. Элементы в памяти следуют друг за другом. Индекс представляет собой смещение в памяти относительно начала массива.

Вернёмся к вопросу о названиях структур данных в Bash. Ответ на него знают только авторы языка. Однако, мы можем предположить. Название "массив" даёт пользователю подсказку о том, как следует работать с этой структурой. Имея опыт в других языках (например, C) пользователь знает, что читать и писать отдельные элементы массива надо по индексу. Поэтому он сможет использовать уже знакомый ему синтаксис языка C в Bash. При этом пользователю совсем необязательно знать, как на самом деле "массив" Bash хранится в памяти.

#### Атрибуты

У языка Bash нет системы типов. В нём все скалярные переменные хранятся в памяти как строки. Но в Bash есть составные типы — массивы. Они представляют собой комбинации строк.

Тип переменной (скалярная или составная) выбирается при её определении. Для этого надо указать метаинформацию, которая в Bash называется **атрибутами**. Кроме типа атрибуты определяют константность и область видимости переменной.

Чтобы указать атрибуты переменной, используйте встроенную команду declare. Если вызвать её без параметров, она выведет имена и значения всех объявленных в данный момент переменных: локальных и окружения. Эту же информацию выводит команда set.

У команды declare есть опция `-p`. Она добавляет в вывод атрибуты переменных.

Если вам нужна информация по конкретной переменной, передайте команде declare её имя. Например, так:
{line-numbers: false, format: Bash}
```
declare -p PATH
```

Команда declare без параметров выводит информацию не только об объявленных переменных, но и о доступных [**подпрограммах**](https://ru.wikipedia.org/wiki/Функция_(программирование)). В Bash они называются **функциями**. Функция — это фрагмент программы или самостоятельный блок кода, который выполняет определённую задачу.

Чтобы команда declare вывела только информацию о функциях, используйте опцию `-f`. Например, так:
{line-numbers: false, format: Bash}
```
declare -f
```

Если вас интересует конкретная функция, укажите её имя после опции `-f`. Пример для функции `quote`:
{line-numbers: false, format: Bash}
```
declare -f quote
```

Эта команда выведет на экран определение функции.

I> Функция `quote` заключает переданную ей строку в одинарные кавычки. Если одинарные кавычки уже есть в строке, они будут экранированы. Функция вызывается точно так же, как и любая встроенная команда Bash. Например:
{line-numbers: false, format: Bash}
```
quote "this is a 'test' string"
```

Без опции `-f` declare не сможет вывести определение конкретной функции. То есть следующая команда не сработает:
{line-numbers: false, format: Bash}
```
declare quote
```

Команда declare не только выводит информацию об уже объявленных переменных и функциях. Она также устанавливает атрибуты при объявлении новой переменной.

Часто используемые опции команды declare приведены в таблице 3-7.

{caption: "Таблица 3-7. Опции команды declare и соответствующие атрибуты переменных", width: "100%"}
| Опция | Значение |
| --- | --- |
| `-a` | Объявленная переменная является индексируемым массивом. Элементы такого массива доступны по целочисленным номерам. |
|  | |
| `-A` | Объявленная переменная является ассоциативным массивом. Каждому элементу такого массива соответствует ключ-строка. |
|  | |
| `-g` | Объявление переменной в глобальной области видимости скрипта. При этом переменная не попадает в окружение. |
|  | |
| `-i` | Объявление целочисленной переменной. Присваиваемое ей значение обрабатывается как арифметическое выражение. |
|  | |
| `-r` | Объявление константы. После объявления ей нельзя присвоить другое значение. |
|  | |
| `-x` | Объявление переменной окружения. |

Рассмотрим примеры объявлений с атрибутами. Начнём с целочисленных и строковых переменных. Выполните в окне терминала следующее:
{line-numbers: true, format: Bash}
```
declare -i sum=11+2
text=11+2
```

Мы объявили две переменные с именами `sum` и `text`. Первая из них объявлена как целочисленная. Её значение равно 13 (сумма чисел 11 и 2). Значение второй переменной `text` равно строке "11+2".

Обратите внимание, что обе переменные хранятся в памяти в виде строк. Опция `-i` не задаёт тип переменной, а ограничивает её допустимые значения.

Попробуйте присвоить переменной `sum` строку. Например, одним из следующих способов:
{line-numbers: true, format: Bash}
```
declare -i sum="test"
sum="test"
```

В результате переменная `sum` станет равна нулю.

Предположим, вы объявили переменную как целочисленную. Тогда для арифметических операции над ней не нужны дополнительные подстановки Bash. Например, следующие команды выполнятся корректно:
{line-numbers: true, format: Bash}
```
sum=sum+1       # 13 + 1 = 14
sum+=1          # 14 + 1 = 15
sum+=sum+1      # 15 + 15 + 1 = 31
```

В комментариях к командам приводятся их результаты.

Выполним те же самые операции со строковой переменной. Результаты будут отличаться:
{line-numbers: true, format: Bash}
```
text=text+1     # "text+1"
text+=1         # "text+1" + "1" = "text+11"
text+=text+1    # "text+11" + "text" + "1" = "text+11text+1"
```

Вместо арифметических операций над числами произошло склеивание строк. Чтобы выполнить эти операции над текстовой переменной, нужна арифметическая подстановка. Например:
{line-numbers: true, format: Bash}
```
text=11
text=$(($text + 2))  # 11 + 2 = 13
```

Опция `-r` команды declare объявляет переменную константой. Например, так:
{line-numbers: false, format: Bash}
```
declare -r filename="README.txt"
```

Теперь при каждой попытке изменить значение переменной `filename` или удалить её, Bash выводит сообщение об ошибке. Поэтому следующие команды завершатся с ошибкой:
{line-numbers: true, format: Bash}
```
filename="123.txt"
unset filename
```

I> Для удаления переменной любого типа, кроме константы, используйте встроенную команду unset.

Команда declare с опцией `-x` объявляет переменную окружения. То же самое объявление делает команда export. Следующие два объявления переменной `BROWSER_PATH` эквивалентны:
{line-numbers: true, format: Bash}
```
export BROWSER_PATH="/opt/firefox/bin"
declare -x BROWSER_PATH="/opt/firefox/bin"
```

Хорошей практикой считается использовать команду export вместо declare с `-x`. Это улучшает читаемость кода. Вам не нужно вспоминать, что значит опция `-x`. По этой же причине предпочитайте использовать команду readonly вместо declare с `-r`. Она тоже объявляет константу и её проще запомнить.

Обратите внимание, что команда readonly объявляет переменную в глобальной области видимости скрипта. Команда declare с `-r` даст другой результат. Если использовать declare в теле функции, объявленная переменная будет локальной. Вне функции она недоступна. Чтобы переменная стала глобальной (как с readonly), используйте опцию declare `-g`. Например, так:
{line-numbers: false, format: Bash}
```
declare -gr filename="README.txt"
```

#### Индексируемые массивы

В Bourne Shell есть только скалярные переменные (строки). В Bash по просьбам пользователей разработчики добавили массивы. Когда они могут понадобиться?

У строкового типа есть серьёзное ограничение. При записи в скалярную переменную какого-то значения, логически получается один элемент. Например, вы сохраняете в переменную с именем `files` список файлов. Элементы списка разделены пробелами. В результате `files` хранит одну строку с точки зрения Bash. Это может привести к ошибкам.

Как мы выяснили, стандарт POSIX разрешает любые символы в именах файлов, кроме нуль-терминатора (NUL). NUL означает конец имени файла. Этот же самый символ в Bash означает конец строки. Поэтому строковая переменная может содержать NUL не в произвольном месте, а только в конце. Получается, у вас нет надёжного способа разделить имена файлов в списке. NUL использовать нельзя. Любой другой символ-разделитель может встретиться в этих именах.

Именно проблема разделителя мешает надёжно обработать вывод утилиты ls. Утилита find позволяет разделять элементы своего вывода с помощью NUL, а ls - нет. Никакой символ кроме NUL не будет надёжным разделителем. Поэтому не объявляйте переменные так:
{line-numbers: false, format: Bash}
```
files=$(ls Documents/*.txt)
```

В результате в переменную `files` будет записана строка со всеми TXT файлами каталога `Documents`. Если в именах файлов встречаются пробелы или символы переноса строки, восстановить исходную информацию будет проблематично.

Массивы добавлены в Bash для решения этой проблемы. Массив хранит список отдельных элементов. Прочитать их в исходном виде не составляет труда. Поэтому вместо присваивания переменной вывода утилиты ls, используйте массив. Например:
{line-numbers: false, format: Bash}
```
declare -a files=(Documents/*.txt)
```

**Инициализацией массива** называется определение его элементов. Массив можно инициализировать при объявлении или после. В примере выше инициализация `files` происходит при объявлении.

Bash способен вывести тип переменной самостоятельно. Этот механизм работает, когда вы присваиваете значение переменной при объявлении. В зависимости от значения Bash добавляет соответствующий атрибут. В таком случае команду declare можно опустить. Например, наш массив `files` можно объявить без declare:
{line-numbers: false, format: Bash}
```
files=(Documents/*.txt)
```

Предположим, что элементы массива получаются не в результате подстановки, а известны заранее. В этом случае их можно задать явно при объявлении. Это будет выглядеть так:
{line-numbers: false, format: Bash}
```
files=("/usr/share/doc/bash/README" "/usr/share/doc/flex/README.md" "/usr/share/doc/xz/README")
```

Элементы массива можно читать из значений других переменных. Например:
{line-numbers: true, format: Bash}
```
bash_doc="/usr/share/doc/bash/README"
flex_doc="/usr/share/doc/flex/README.md"
xz_doc="/usr/share/doc/xz/README"
files=("$bash_doc" "$flex_doc" "$xz_doc")
```

Элементами массива `files` станут текущие значения переменных `bash_doc`, `flex_doc` и `xz_doc`. Изменение этих переменных после объявления массива, никак не отразится на его содержимом.

При объявлении массива для каждого его элемента можно явно указать индекс. Например:
{line-numbers: true, format: Bash}
```
bash_doc="/usr/share/doc/bash/README"
flex_doc="/usr/share/doc/flex/README.md"
xz_doc="/usr/share/doc/xz/README"
files=([0]="$bash_doc" [1]="$flex_doc" [5]="/usr/share/doc/xz/README")
```

Обратите внимание на отсутствие пробелов до и после каждого знака равно. Запомните простое правило: при объявлении переменных в Bash пробелы до и после знака равно не ставятся.

Вместо инициализации всего массива за раз, можно определять его элементы по отдельности. Например, так:
{line-numbers: true, format: Bash}
```
files[0]="$bash_doc"
files[1]="$flex_doc"
files[5]="/usr/share/doc/xz/README"
```

В последних двух объявлениях массива `files` нумерация индексов идёт не по порядку. Это не ошибка. Bash допускает **массивы с пропусками** (sparse arrays).

Вывести все элементы массива можно с помощью следующей подстановки:
{line-numbers: true, format: Bash}
```
$ echo "${files[@]}"
/usr/share/doc/bash/README /usr/share/doc/flex/README.md /usr/share/doc/xz/README
```

I> В этой команде символ $ указывает на приглашение командной строки. После него через пробел идёт команда. На следующей строке — вывод её результата.

Иногда бывает полезно вывести только индексы элементов. Для этого в подстановке добавьте восклицательный знак перед именем массива. Например:
{line-numbers: true, format: Bash}
```
$ echo "${!files[@]}"
0 1 5
```

При подстановке индекс элемента можно рассчитать по формуле. Просто укажите в квадратных скобках арифметическое выражение для его вычисления. Например, так:
{line-numbers: true, format: Bash}
```
echo "${files[4+1]}"
files[4+1]="/usr/share/doc/xz/README"
```

В арифметическом выражении можно использовать переменные. Причём они могут быть объявлены и как целочисленные, и как строковые. Например:
{line-numbers: true, format: Bash}
```
i=4
echo "${files[i+1]}"
files[i+1]="/usr/share/doc/xz/README"
```

Следующие подряд элементы можно подставить одной командой. Для этого после двоеточия укажите стартовый индекс и число элементов. Например, так:
{line-numbers: true, format: Bash}
```
$ echo "${files[@]:1:2}"
/usr/share/doc/flex/README.md /usr/share/doc/xz/README
```

Эта команда выведет два элемента начиная с первого. Обратите внимание, что индексы элементов в этом случае не важны. Мы прочитали имена файлов под номерами 1 и 5.

Bash, начиная с версии 4, предоставляет встроенную команду readarray (также известную как mapfile). Она читает содержимое текстового файла в массив. Рассмотрим, как её использовать.

Предположим, что у нас есть файл с именем `names.txt`. Его содержимое такое:
{line-numbers: true, format: Bash}
```
Alice
Bob
Eve
Mallory
```

Создадим массив со строками из этого файла. Для этого достаточно выполнить следующую команду:
{line-numbers: false, format: Bash}
```
readarray -t names_array < names.txt
```

В результате содержимое файла будет записано в массив с именем `names_array`.

{caption: "Упражнение 3-3. Объявление массивов", format: text, line-numbers: false}
```
Выполните самостоятельно все рассмотренные способы объявления массивов:

1. С помощью команды declare.

2. Без использования команды declare.

3. Все элементы массива подставляются в результате globbing.

4. Все элементы массива указываются явно при объявлении.

5. Каждый элемент массива задаётся отдельно.

6. В качестве элементов массива используются значения объявленных ранее переменных.

7. Элементы массива читаются из текстового файла.

Выведите содержимое массива с помощью команды echo для каждого случая.
Убедитесь, что объявления выполнились корректно.
```

Мы научились объявлять и инициализировать индексируемые массивы. Теперь разберёмся, как их использовать. Предположим, что массив `files` содержит список имён файлов. Вам нужно скопировать первый файл в списке. Для этого воспользуемся утилитой cp:
{line-numbers: false, format: Bash}
```
cp "${files[0]}" ~/Documents
```

W> В большинстве языков программирования принято нумеровать элементы массивов и строк с нуля, а не с единицы. Это правило справедливо и для Bash.

Для чтения элемента массива нужна полная форма подстановки параметров с фигурными скобками. После имени переменной в квадратных скобках указывается индекс нужного элемента. Для подстановки всех элементов используйте символ @ вместо индекса. Например, так:
{line-numbers: false, format: Bash}
```
cp "${files[@]}" ~/Documents
```

Чтобы получить размер массива, поставьте символ решётка # перед его именем. Например:
{line-numbers: false, format: Bash}
```
echo "${#files[@]}"
```

При подстановке элементов массива всегда используйте двойные кавычки, чтобы предотвратить word splitting.

Чтобы удалить элемент массива, используйте встроенную команду unset. Например, удаление четвёртого элемента (не забывайте про нумерацию с нуля) выглядит так:
{line-numbers: false, format: Bash}
```
unset 'files[3]'
```

Обратите внимание на обязательные одинарные кавычки. Они выключат все возможные подстановки интерпретатора.

С помощью команды unset можно также очистить весь массив:
{line-numbers: false, format: Bash}
```
unset files
```

#### Ассоциативные массивы

Мы рассмотрели индексируемые массивы. В них элементами являются строки, а индексами — целые положительные числа. Массивы этого типа по указанному индексу возвращают соответствующую ему строку.

В Bash версии 4 добавили ассоциативные массивы. В них индексы — это не числа, а строки. Такая строка-индекс называется **ключом** (key). Ассоциативный массив по указанной строке-индексу возвращает соответствующую ей строку-значение. Когда это может быть полезно? Рассмотрим пример.

Предположим, нам нужен скрипт для хранения контактов. Скрипт позволяет добавить в список имя человека, его email или номер телефона. Для простоты можно опустить фамилию и хранить только имя. По запросу скрипт выводит контактные данные человека.

Если для нашей задачи применить индексируемый массив, поиск контактов будет неэффективным. Придётся перебирать элементы массива друг за другом и сравнивать имя человека с искомым. Если нужное имя найдено, скрипт выведет на экран соответствующие контактные данные.

Ассоциативный массив сделает поиск по контактам быстрее и проще. В этом случае перебирать элементы массива не нужно. Достаточно указать ключ и получить соответствующий элемент массива. Рассмотрим это решение подробнее.

Объявление и инициализация ассоциативного массива с контактами выглядит так:
{line-numbers: false, format: Bash}
```
declare -A contacts=(["Alice"]="alice@gmail.com" ["Bob"]="(697) 955-5984" ["Eve"]="(245) 317-0117" ["Mallory"]="mallory@hotmail.com")
```

Ассоциативный массив всегда объявляется с командой declare и её опцией `-A`. Bash не сможет правильно вывести тип переменной, даже если указать в качестве индексов строки. Поэтому в результате следующего объявления вы получите индексируемый массив, а не ассоциативный:
{line-numbers: false, format: Bash}
```
contacts=(["Alice"]="alice@gmail.com" ["Bob"]="(697) 955-5984" ["Eve"]="(245) 317-0117" ["Mallory"]="mallory@hotmail.com")
```

Проверим, чему равна переменная `contacts` в этом случае:
{line-numbers: true, format: Bash}
```
$ declare -p contacts
declare -a contacts='([0]="mallory@hotmail.com")'
```

Мы получили индексируемый массив с одним элементом. Bash сконвертировал все строки-ключи в индекс ноль. Поэтому в нулевой элемент записался только контакт последнего человека в списке инициализации.

Элементы массива можно задавать по отдельности. Например, так:
{line-numbers: true, format: Bash}
```
declare -A contacts
contacts["Alice"]="alice@gmail.com"
contacts["Bob"]="(697) 955-5984"
contacts["Eve"]="(245) 317-0117"
contacts["Mallory"]="mallory@hotmail.com"
```

Итак, мы объявили ассоциативный массив. Его элементы доступны по ключам. В нашем случае ключ — это имя человека.

Чтобы прочитать элемент массива по его ключу, выполните такую подстановку:
{line-numbers: true, format: Bash}
```
$ echo "${contacts["Bob"]}"
(697) 955-5984
```

Для вывода всех элементов массива просто укажите в качестве ключа символ @:
{line-numbers: true, format: Bash}
```
$ echo "${contacts[@]}"
(697) 955-5984 mallory@hotmail.com alice@gmail.com (245) 317-0117
```

Чтобы вывести список всех ключей, поставьте восклицательный знак ! перед именем массива. Например:
{line-numbers: true, format: Bash}
```
$ echo "${!contacts[@]}"
Bob Mallory Alice Eve
```

Размер массива выводится с помощью символа решётка #. Например, так:
{line-numbers: true, format: Bash}
```
$ echo "${#contacts[@]}"
4
```

Поместим ассоциативный массив с контактами в скрипт. Тогда имя интересующего человека можно передать через параметр командной строки. В ответ скрипт выведет соответствующий email или телефон.

Листинг 3-10 демонстрирует скрипт с контактами.

{caption: "Листинг 3-10. Скрипт для хранения контактов", line-numbers: true, format: Bash}
![`contacts.sh`](code/BashScripting/contacts.sh)

Для редактирования контактов измените инициализацию массива в скрипте.

Удалить ассоциативный массив или его элемент можно командой unset:
{line-numbers: true, format: Bash}
```
unset contacts
unset 'contacts[Bob]'
```

Подстановка нескольких элементов ассоциативного массива работает так же, как и для индексируемого массива. Например:
{line-numbers: true, format: Bash}
```
$ echo "${contacts[@]:Bob:2}"
(697) 955-5984 mallory@hotmail.com
```

В этом случае Bash подставит два элемента: соответствующий ключу `Bob` и следующий за ним в памяти. Проблема в том, что порядок следования элементов в памяти не соответствует порядку их инициализации. Индекс каждого элемента рассчитывается [**хеш-функцией**](https://ru.wikipedia.org/wiki/Хеш-функция). На вход она принимает строку-ключ, а на выходе возвращает уникальное целое число. Из-за этой особенности подстановка нескольких элементов ассоциативного массива мало полезна на практике.