## Компьютерная программа

Мы познакомились с операционными системами. Они отвечают за запуск и выполнение компьютерных программ. Программы решают прикладные задачи пользователя. Например, текстовый редактор позволяет работать с текстом.

Программа представляет собой набор элементарных шагов. Они называются инструкциями. Компьютер последовательно выполняет эти шаги. Так он справляется со сложными задачами. Рассмотрим подробнее, как происходит запуск и исполнение программы.

### Память компьютера

Инструкции компьютерной программы хранятся на жёстком диске или другом носителе информации. Небольшая программа помещается в один файл. Сложное приложение может состоять из десятков файлов.

Предположим, что у вас есть файл с программой. При его запуске ОС загружает содержимое файла в оперативную память компьютера. Затем ОС выделяет часть процессорного времени на исполнение новой программы. Тогда процессор получает и исполняет инструкции вашей программы по частям. Эти части чередуются с остальными запущенными приложениями и компонентами ОС.

Первый шаг запуска программы — загрузка её инструкций в оперативную память. Чтобы лучше понять этот шаг, рассмотрим устройство памяти современного компьютера.

Память компьютера измеряется в [**байтах**](https://ru.wikipedia.org/wiki/Байт). Байт — это минимальный блок информации, на который процессор может ссылаться и загружать в свою память. Процессор способен оперировать и меньшими объёмами информации — битами. [**Бит**](https://ru.wikipedia.org/wiki/Бит) — это минимальная единица информации, которую нельзя разложить на составные части.

Бит представляет собой логическое состояние с двумя возможными значениями. Есть несколько способов интерпретировать эти значения:

* 0 или 1
* Истина или ложь
* Да или нет
* + или —
* Включено или выключено.

Представьте себе бит, как выключатель лампы. Выключатель находится в одном из двух состояний:

* Он замыкает цепь и лампа горит.
* Он размыкает цепь и лампа выключена.

Восемь битов составляют блок памяти в один байт. Такая упаковка битов в байты вызывает вопросы. Процессор может оперировать отдельными битами. Почему тогда он не может ссылаться на конкретный бит в памяти?

Процессор не работает с битами напрямую. У этого ограничения есть исторические причины. Первые компьютеры использовались для арифметических вычислений. Например, они рассчитывали [баллистические таблицы](https://ru.wikipedia.org/wiki/Баллистическая_таблица) для артиллерии. При решении подобных задач компьютер оперировал целыми и дробными числами. Чтобы сохранить число в памяти, одного бита недостаточно. Поэтому понадобились блоки памяти из нескольких битов. Такими блоками стали байты. 

Объединение битов в байты отразилось на архитектуре процессоров. Их производители предположили, что компьютеры и дальше будут оперировать только числами. Поэтому инженеры позволили процессору загружать и обрабатывать все биты одного числа за раз. Это решение на порядок увеличило производительность компьютеров. В то же время загрузка отдельного бита в память процессора выполнялась редко. Поддержка этой возможности требовала аппаратных ресурсов и не оправдывала себя. В результате от неё отказались.

Есть ещё один вопрос. Почему байт состоит именно из восьми бит? Так было не всегда. В первых компьютерах размер байта равнялся [шести битам](https://ru.wikipedia.org/wiki/Шестибитные_кодировки). Этого блока памяти хватало для кодирования всех символов английского алфавита в верхнем регистре, цифр, знаков пунктуации и математических операций.

Со временем блока в шесть битов стало недостаточно. Байт расширили до семи битов в начале 1960-х годов. Этот момент совпал с появлением [ASCII-кодировки](https://ru.wikipedia.org/wiki/ASCII). Она стала стандартом для представления символов в памяти компьютера. ASCII определяет символы для кодов от 0 до 127. Максимальное семибитное число 127 ограничивает этот диапазон.

В 1964 году IBM выпустила мейнфрейм [IBM System/360](https://ru.wikipedia.org/wiki/IBM_System/360). В нём размер байта равнялся восьми битам. Такой размер позволял поддерживать старые кодировки символов из прошлых проектов IBM. Мейнфрейм IBM System/360 стал популярен и широко использовался. Это привело к тому, что упаковка восьми битов в байт стала отраслевым стандартом.

Таблица 1-1 демонстрирует часто используемые единицы измерения информации.

{caption: "Таблица 1-1. Единицы измерения информации", width: "70%"}
| Название | Сокращение | Число байтов | Число битов |
| --- | --- | --- | --- |
| килобайт | Кбайт | 1000 | 8000 |
| мегабайт | Мбайт | 1000000 | 8000000 |
| гигабайт | Гбайт | 1000000000 | 8000000000 |
| терабайт | Тбайт | 1000000000000 | 8000000000000 |

В таблице 1-2 приведены распространённые устройства хранения информации и их объёмы.

{caption: "Таблица 1-2. Устройства хранения информации", width: "50%"}
| Устройство хранения | Объём |
| --- | --- |
| [Дискета 3.5"](https://ru.wikipedia.org/wiki/Дискета) | 1.44 Мбайт |
| [Компакт-диск](https://ru.wikipedia.org/wiki/Компакт-диск) | 700 МБайт |
| [DVD-диск](https://ru.wikipedia.org/wiki/DVD) | до 17 Гбайт |
| [USB-флеш-накопитель](https://ru.wikipedia.org/wiki/USB-флеш-накопитель) | до 2 Тбайт |
| [Жёсткий диск](https://ru.wikipedia.org/wiki/Жёсткий_диск) | до 16 Тбайт |
| [Твердотельный накопитель](https://ru.wikipedia.org/wiki/Твердотельный_накопитель) | до 100 Тбайт |

Мы познакомились с единицами измерения информации и устройствами хранения. Теперь вернёмся к исполнению программы. Зачем загружать её инструкции в оперативную память? Ведь процессор может читать их напрямую с жёсткого диска.

В современном компьютере вся память делится на [четыре уровня](https://ru.wikipedia.org/wiki/Иерархия_памяти). Они изображены на иллюстрации 1-13 красными прямоугольниками. Каждому уровню соответствуют разные устройства. Единственное исключение из этого правила — процессор. В его кристалле находятся и регистры, и кэш память. Им соответствуют разные модули кристалла.

Стрелки на иллюстрации 1-13 означают потоки данных. Передача происходит только между соседними уровнями памяти.

Предположим, процессор собирается обработать данные с диска. Для этого их надо загрузить в регистры процессора. Он работает только с содержимым своих регистров.

Если процессору нужны данные из дисковой памяти, они загружаются так:

1. Дисковая память -> Оперативная память
2. Оперативная память -> Кэш процессора
3. Кэш процессора -> Регистры процессора

Данные из регистров записываются на диск в обратном порядке: 

1. Регистры процессора -> Кэш процессора
2. Кэш процессора -> Оперативная память
3. Оперативная память -> Дисковая память

{caption: "Иллюстрация 1-13. Уровни памяти персонального компьютера", height: "50%"}
![Уровни памяти](images/GeneralInformation/memory-levels.png)

Устройства хранения информации отличаются друг от друга следующими параметрами:

1. **Скорость доступа** — сколько данных читается или пишется на устройство в единицу времени. Единицы измерения — байты в секунду (байт/с).

2. **Объём** — максимальное количество данных, которое может хранить устройство. Измеряется в байтах.

3. **Стоимость** — цена устройства в соотношении к его объёму. Измеряется в долларах или центах за байт или бит.

4. **Время доступа** — время между моментами, когда данные с устройства понадобились процессору и когда он их получил. Измеряется в [**тактовых сигналах**](https://ru.wikipedia.org/wiki/Тактовый_сигнал) процессора.

На разных уровнях иерархии памяти параметры устройств существенно различаются. Таблица 1-3 приводит соотношение этих параметров.

{caption: "Таблица 1-3. Уровни памяти персонального компьютера", width: "100%", column-widths: "10%,30%,*"}
| Уровень | Устройство | Объём | Скорость доступа | Время доступа | Стоимость |
| --- | --- | --- | --- | --- | --- |
| 1 | [**Регистры**](https://ru.wikipedia.org/wiki/Регистр_процессора) процессора. | до тысячи байтов | — | 1 такт | — |
|  | | | | | |
| 2 | [**Кэш**](https://ru.wikipedia.org/wiki/Кэш_процессора) память процессора. | от одного килобайта до нескольких мегабайтов | от 700 до 100 гигабайт/сек | от 2 до 100 тактов | — |
|  | | | | | |
| 3 | Оперативная память | десятки гигабайтов | 10 гигабайт/сек | до 1000 тактов | $10^-9^/байт |
|  | | | | | |
| 4 | Дисковая память ([**жёсткие диски**](https://ru.wikipedia.org/wiki/Жёсткий_диск) и [**твёрдотельные накопители**](https://ru.wikipedia.org/wiki/Твердотельный_накопитель)) | терабайты | 2000 мегабайт/сек | до 10000000 тактов | $10^-12^/байт |

Таблица 1-3 вызывает вопросы. У дисковой памяти высокая скорость доступа. Почему нельзя читать данные из неё напрямую в регистры процессора? Это возможно технически, но приведёт к высоким накладным расходам.

На практике быстродействие определяет не скорость, а время доступа к памяти. Это время простаивания процессора, пока он не получит нужные ему данные. Оно измеряется в числе тактовых сигналов или тактах. Такт синхронизирует выполнение всех операций процессора. На выполнении одной инструкции программы уходит от 1 до 10 тактов.

Высокое время доступа приводит к низкой производительности. Рассмотрим пример. Допустим, что процессор читает инструкции программы напрямую с жёсткого диска. Объём регистров процессора мал. Поэтому все инструкции программы в них не поместятся. Процессору придётся загружать и выполнять программу по частям. Каждая такая загрузка занимает 10000000 тактов. Другими словами загрузка инструкций длится дольше, чем их выполнение. Большую часть времени процессор простаивает в ожидании. Иерархия памяти компьютера решает именно эту проблему простоя.

Рассмотрим передачу данных между уровнями иерархии памяти. Представьте, что вы запустили простую программу. Она читает файл с жёсткого диска и выводит его содержимое на экран. Данные с диска читаются в несколько шагов. Эти шаги выполняются на аппаратном уровне.

Первый шаг — чтение данных с диска в оперативную память, как показывает иллюстрация 1-13. Затем по частям они загружаются в кэш процессора. Специальный **механизм кеширования** предугадывает, какие данные из оперативной памяти понадобятся процессору дальше. Такое предугадывание сокращает ожидание загрузки данных процессором.

Процессор получает доступ к данным только тогда, когда они попадают в его кеш. Нужные данные загружаются из кеша в регистры. Инструкции программы проходят тот же путь загрузки, что и данные.

В нашем примере программа выводит данные на экран. Для этого вывода она вызывает API функцию из системной библиотеки ОС. Выполняя API функцию, библиотека меняет картинку на экране. При этом большую часть работы выполняет процессор. Он загружает инструкции системной библиотеки и драйвера видеокарты. Затем он применяет эти инструкции к данным в своих регистрах. Эти данные соответствуют содержимому файла, который надо вывести. Драйвер видеокарты обращается к самой видеокарте и передаёт ей данные для вывода на экран.

В нашем примере процессор простаивает, если необходимые ему данные не были загружены заранее. Вот несколько примеров, когда это происходит. Процессору нужны данные файла для обработки их в коде драйвера видеокарты. Допустим, что эти данные загружены кеш процессора, но не в его регистры. Тогда процессор проведёт в ожидании от 2 до 100 тактов. Если данные ещё не загружены в кеш из оперативной памяти, время ожидания увеличивается на порядок до 1000 тактов.

Наша программа способна выводить содержимое больших файлов. Размер файла может превышать объём оперативной памяти. Тогда в память загрузится только его часть. В случае если процессору понадобится незагруженная часть файла, время простоя увеличится на четыре порядка до 10000000 тактов. Для сравнения: за это время процессор мог бы исполнить около 1000000 инструкций программы.

Аппаратный механизм кеширования есть и у процессора, и у жёсткого диска. Механизм диска использует дополнительный контроллер памяти с относительно низким временем доступа. В него сохраняются данные, которые предположительно загрузятся в оперативную память следующими. На программном уровне есть свой механизм кеширования. За него отвечает операционная система.

Аппаратные и программные механизмы кеширования значительно повышают производительность компьютера. Ошибка одного из них приводит к простою процессора. Такая ошибка называется **промах кеша** (cache miss). Каждый промах дорого обходится с точки зрения производительности.

Помните об иерархии памяти и механизмах кеширования. Учитывайте их при разработке своих алгоритмов. Некоторые алгоритмы и структуры данных приводят к промахам кеша чаще, чем другие.

Устройства памяти из разных уровней иерархии находятся на разном физическом расстоянии от процессора. Чем короче это расстояние, тем меньше время доступа к устройству. Иллюстрация 1-14 демонстрирует этот принцип.

Например, регистры и кэш процессора (CPU) находятся внутри его кристалла. Оперативная память (RAM) расположена на [**материнской плате**](https://ru.wikipedia.org/wiki/Материнская_плата) рядом с процессором. Их соединяет высокочастотная [**шина данных**](https://ru.wikipedia.org/wiki/Шина_данных). Она обеспечивает низкое время доступа.

Материнская плата — эта [печатная плата](https://ru.wikipedia.org/wiki/Печатная_плата), которая соединяет компоненты компьютера. Некоторые из них вставляются в саму материнскую плату. Например, это процессор и оперативная память. Другие устройства подключаются к плате через кабели. Один из примеров — дисковая память. Для неё используется относительно медленный интерфейс. Он следует одному из следующих стандартов: ATA, SATA, SCSI, PCI Express.

За загрузку данных из оперативной памяти в кэш процессора отвечает системный контроллер. Он называется [**северный мост**](https://ru.wikipedia.org/wiki/Северный_мост_(компьютер)). До 2011 года это был отдельный компонент материнской платы. Благодаря развитию технологии изготовления [**интегральных схем**]((https://ru.wikipedia.org/wiki/Интегральная_схема)), северный мост встраивается в кристалл современных процессоров.

За чтение данных с жёсткого диска в оперативную память отвечает контроллер под названием [**южный мост**](https://ru.wikipedia.org/wiki/Южный_мост_(компьютер)). Он отвечает за обмен данными с устройствами, подключёнными через относительно медленные интерфейсы: PCI, USB, SATA и т.д. Южный мост до сих пор является отдельным компонентом материнской платы.

{caption: "Иллюстрация 1-14. Материнская плата ПК", height: "50%"}
![Материнская плата](images/GeneralInformation/motherboard-memory.png)

### Машинный код

Предположим, что ОС загрузила содержимое исполняемого файла в оперативную память. В этом файле хранятся инструкции программы и данные для её работы. Примеры таких данных: текстовые строки, символы псевдографики, предопределённые константы и т.д.

Инструкции программы называются [**машинным кодом**](https://ru.wikipedia.org/wiki/Машинный_код). Процессор выполняет инструкции друг за другом. Каждая из них соответствует элементарной операции над данными из регистров процессора.

У процессора есть разные логические блоки. Разные инструкции программы выполняются разными блоками. Набор блоков определяет, какие операции поддерживает CPU. Если процессор не имеет специального блока для выполнения инструкции, она выполняется комбинацией блоков. Такое исполнение занимает больше времени и ресурсов.

После загрузки программы в оперативную память ОС выделяет часть времени процессора на её исполнение. С этого момента программа становится [**вычислительным процессом**](https://ru.wikipedia.org/wiki/Процесс_(информатика)) (process). Процесс — это запущенная программа вместе с ресурсами, которые она использует. Примеры ресурсов: область памяти и объекты ОС.

Как выглядят инструкции программы? Вы можете прочитать их в исполняемом файле. Для работы с такими файлами есть специальные [**hex-редакторы**](https://ru.wikipedia.org/wiki/Hex-редактор). Эти редакторы представляют машинный код программы в [**шестнадцатеричной системе счисления**](https://ru.wikipedia.org/wiki/Шестнадцатеричная_система_счисления). На самом деле в исполняемом файле хранится [**двоичный код**](https://ru.wikipedia.org/wiki/Двоичный_код#Примеры_двоичных_чисел). Он представляет собой последовательность нулей и единиц. Именно в таком формате процессор получает инструкции и данные программы. Hex-редактор переводит их в шестнадцатеричный формат для удобства чтения.

Для работы с машинным кодом есть и более мощные средства, чем hex-редакторы. Одно из них — это программа под названием [**дизассемблер**](https://ru.wikipedia.org/wiki/Дизассемблер). Дизассемблер анализирует машинный код и переводит его в команды процессора. Таким образом вы получаете более точное представление об алгоритме анализируемой программы.

Мы столкнулись с термином система счисления. Разберёмся с ним подробнее.

Одно и то же число можно представить в разных системах счисления. При этом оно будет выглядеть по-разному. Система счисления определяет, какие символы и в каком порядке используются при записи числа. Например, двоичная система допускает только символы 0 и 1.

Таблица 1-4 приводит соответствие чисел в двоичной (binary, BIN), десятичной (decimal, DEC) и шестнадцатеричной (hexadecimal, HEX) системах счисления.

{caption: "Таблица 1-4. Числа в системах счисления DEC, HEX и BIN", width: "50%"}
| Десятичная | Шестнадцатеричная | Двоичная |
| --- | --- | --- |
| 0 | 0 | 0000 |
| 1 | 1 | 0001 |
| 2 | 2 | 0010 |
| 3 | 3 | 0011 |
| 4 | 4 | 0100 |
| 5 | 5 | 0101 |
| 6 | 6 | 0110 |
| 7 | 7 | 0111 |
| 8 | 8 | 1000 |
| 9 | 9 | 1001 |
| 10 | A | 1010 |
| 11 | B | 1011 |
| 12 | C | 1100 |
| 13 | D | 1101 |
| 14 | E | 1110 |
| 15 | F | 1111 |

I> Для перевода из одной системы счисления в другую используйте стандартный калькулятор Windows. Функция перевода доступна в [**режиме "Программист"**](https://ru.wikipedia.org/wiki/Калькулятор_(Windows)#Режим_«Программист»).

Почему в программировании используется и двоичная, и шестнадцатеричная системы? Было бы гораздо удобнее использовать только одну из них. Чтобы ответить на этот вопрос, проясним как работает оборудование современного компьютера. 

На двоичной системе и булевой алгебре строится вся современная [**цифровая техника**](https://ru.wikipedia.org/wiki/Цифровые_технологии). В цифровой технике элементарный носитель информации — это электрический [**сигнал**](https://ru.wikipedia.org/wiki/Сигнал). Для работы с сигналами нужен способ их кодирования. Кодирование означает сопоставление определённых чисел с состояниями сигнала.

У цифрового сигнала есть два состояния. Он либо есть, либо его нет. Поэтому для представления состояния сигнала можно взять два первых целых числа: ноль и единицу. Тогда ноль означает отсутствие сигнала, а единица — его наличие. Такая кодировка очень компактна. Одного бита достаточно, чтобы сохранить состояние одного сигнала.

Базовый элемент в цифровой технике — это [**логический вентиль**](https://ru.wikipedia.org/wiki/Логический_вентиль). Он преобразовывает электрические сигналы. Логическим вентилем могут быть разные физические устройства. Вот несколько примеров: электромагнитные реле, электровакуумные лампы, транзисторы. Каждое из этих устройств работает по разному с точки зрения физики. Однако, все они одинаковы с точки зрения обработки сигналов.

Обработка сигнала логическим вентилем состоит из двух действий:

1. Получить на вход один или более сигналов.
2. Передать результирующий сигнал на выход.

Обработка сигналов выполняется по правилам [**булевой алгебры**](https://ru.wikipedia.org/wiki/Булева_алгебра). Она также известна как [**алгебра логики**](https://ru.wikipedia.org/wiki/Алгебра_логики). Для логического вентиля каждого типа в булевой алгебре есть соответствующая операция. Если соединить вентили последовательно, получается сложное преобразование сигналов. Его результат можно рассчитать с помощью выражения булевой алгебры. Соединение вентилей даёт сложно поведение. Например, центральный процессор компьютера — это огромная сеть логических вентилей.

Для работы с цифровой техникой нужна двоичная система счисления. Она кодирует состояния сигналов в логические значения, которыми оперирует булева алгебра. Используя булеву алгебру можно рассчитать результат преобразования сигналов.

Вся компьютерная аппаратура работает на уровне цифровых сигналов и логических вентилей. Иногда на этот уровень приходится переходить при разработке программы. Получается, что устройство аппаратуры навязывает программисту двоичную систему.

Аппаратура работает в двоичной системе счисления. Зачем тогда понадобилась шестнадцатеричная система? На самом деле программисты в своей работе используют либо десятичную систему, либо двоичную. Первая удобна при написании высокоуровневой логики программы. Например, для подсчёта повторений одного и того же действия.

Двоичная система нужна для работы с оборудованием. Например, для подготовки и передачи данных на устройство. У двоичной системы есть две проблемы проблемы. Во-первых, её неудобно записывать, читать, запоминать и произносить. Во-вторых, перевод из десятичной системы в двоичную сложен. Проблемы решает шестнадцатеричная система. Она так же компактна и удобна, как и десятичная. При этом перевод из шестнадцатеричной в двоичную систему выполняется в уме.

Перевод числа из двоичной системы в шестнадцатеричную выполняется так:

1. Разбейте число на группы по четыре разряда, начиная с конца.

2. Если последняя группа оказалась меньше четырёх разрядов, дополните её слева нулями.

3. Каждую четвёрку разрядов замените на шестнадцатеричное число по таблице 1-4.

Вот пример перевода двоичного числа 110010011010111:
```
110010011010111 = 110 0100 1101 0111 = 0110 0100 1101 0111 = 6 4 D 7 = 64D7
```

{caption: "Упражнение 1-1. Перевод чисел из BIN в HEX", line-numbers: false}
```
Переведите следующие числа из двоичной системы в шестнадцатеричную:
* 10100110100110
* 1011000111010100010011
* 1111101110001001010100110000000110101101
```

{caption: "Упражнение 1-2. Перевод чисел из HEX в BIN", line-numbers: false}
```
Переведите следующие числа из шестнадцатеричной системы в двоичную:
* FF00AB02
* 7854AC1
* 1E5340ACB38
```

В последнем разделе книги вы найдёте ответы на все упражнения. Если вы не уверены в своём результате, сверьтесь с ответами.

Вернёмся к исполнению программы. ОС загружает её исполняемый файл с диска в оперативную память. Затем ОС загружает все библиотеки, которые использует программа. За обе эти процедуры отвечает [**загрузчик программ Windows**](https://ru.wikipedia.org/wiki/Загрузчик_программ). Благодаря предварительной загрузке библиотек, процессору не приходится ждать, когда программа к ним обращается. Инструкции и данные нужной библиотеки уже находится в памяти. Они доступны процессору в течении нескольких сотен тактов. После окончания работы загрузчика Windows программа считается процессом. Процессор исполняет её, начиная с первой инструкции.

Каждая инструкция в машинном коде называется [**операционным кодом**](https://ru.wikipedia.org/wiki/Код_операции) или опкодом. Опкод указывает процессору, какие логические вентили использовать и из каких регистров загружать для них данные. После выполнения операции, опкод определяет регистр для сохранения результата. Опкоды передаются в двоичной системе счисления.

Пока программа выполняется, её инструкции, ресурсы и библиотеки занимают область оперативной памяти. После завершения программы эта область очищается. С этого момента её могут использовать другие приложения.

### Исходный код

Машинный код — это низкоуровневое представление программы. Такой формат инструкций и данных удобен для процессора. Однако, человеку трудно писать программу на машинном коде. Именно так разрабатывались программы для первых компьютеров. По сравнению с ними современные компьютеры гораздо мощнее и сложнее. Их программы огромны и состоят из большого числа модулей.

Чтобы решить проблему работы с машинным кодом, компьютерные инженеры разработали два типа приложений. Эти приложения называются [**компиляторы**](https://ru.wikipedia.org/wiki/Компилятор) и [**интерпретаторы**](https://ru.wikipedia.org/wiki/Интерпретатор). Они переводят программу из понятного человеку языка в машинный код. Компиляторы и интерпретаторы делают это по-разному.

Сегодня программы пишут на [**языках программирования**](https://ru.wikipedia.org/wiki/Язык_программирования). Написанные на них программы передаются на вход компилятору или интерпретатору. Далее он переводит текст программы в машинный код.

Для общения люди используют [**естественные языки**](https://ru.wikipedia.org/wiki/Естественный_язык). По сравнению с ними языки программирования очень формальны и ограничены. Они позволяют выразить только те действия, которые способен выполнить компьютер. Чтобы записать эти действия, вы должны следовать строгим правилам языка. Например, есть ограниченный набор слов, которые употребляются только в определённом порядке.

[**Исходный код**](https://ru.wikipedia.org/wiki/Исходный_код) — это текст программы, записанный на языке программирования.

Компилятор и интерпретатор работают с исходным кодом по-разному. Компилятор читает текст программы целиком, генерирует по нему машинный код и сохраняет результат в файл на диске. Компилятор не исполняет получившуюся программу.

Интерпретатор читает исходный код программы по частям, генерирует инструкции машинного кода и сразу же исполняет их. Интерпретатор временно сохраняет свои результаты в оперативной памяти. При завершении программы оперативная память очищается.

Рассмотрим работу компилятора по шагам. Предположим, что вы написали программу и сохранили её исходный код в файл на жёстком диске. Затем вы запускаете подходящий компилятор. Для каждого языка программирования есть свой компилятор или интерпретатор.

Компилятор читает файл с диска, обрабатывает его и записывает машинный код вашей программы в исполняемый файл на диск. Теперь у вас есть два файла: с исходным кодом и с машинным. Каждый раз когда вы меняете исходный код программы, вы должны сгенерировать новый исполняемый файл. Чтобы выполнить программу, вы запускаете исполняемый файл.

Иллюстрация 1-15 демонстрирует процесс компиляции программы, написанной на языке C или C++.

{caption: "Иллюстрация 1-15. Компиляция программы", height: "50%", width: "100%"}
![Компиляция программы](images/GeneralInformation/compiler.png)

Компиляция происходит в два этапа. Первый этап выполняет компилятор. Второй этап называется **компоновка** или **линковка**. Его выполняет специальная программа [**компоновщик**](https://ru.wikipedia.org/wiki/Компоновщик).

Компилятор создаёт промежуточные **объектные файлы**. Их использует компоновщик, чтобы создать исполняемый файл.

Почему компиляция программы выполняется в два этапа? На самом деле можно скомбинировать компилятор и компоновщик в одну программу. Однако, у такого решения есть несколько проблем.

Первая проблема связана с ограниченным размером оперативной памяти. Исходный код программы принято разбивать на несколько файлов. Каждый файл содержит часть программы, которая отвечает за определённую функциональность. Такое разделение облегчает работу с исходным кодом больших проектов. Компилятор обрабатывает файлы программы по отдельности. Для каждого из них компилятор генерирует объектный файл. В нём хранится промежуточный результат компиляции.

Если объединить компилятор и компоновщик, сохранять промежуточные результаты на диск станет неэффективно. Такое сохранение замедлит весь процесс компиляции из-за медленного доступа к диску. Вместо этого все данные можно хранить в оперативной памяти. К сожалению, такой подход не сработает при компиляции больших приложений. Их исходный и объектный код не поместится в оперативную память. Тогда компилятор завершится с ошибкой.

Предположим, что после объединения компилятора и компоновщика, вы сохраняете промежуточные результаты на диск. За это вы платите временем, которое процессор простаивает ожидая доступ к диску. В то же время такое решение не приносит вам никакой выгоды. Единственное чего вы достигли, это обошли проблему переполнения оперативной памяти. Если вы разделите компилятор и компоновщик, вы получите два простых приложения вместо одного сложного. Простые приложения дешевле сопровождать. Поэтому разработчики компиляторов предпочли такое разделение.

Вторая проблема объединения компилятора и компоновщика заключается в разрешении зависимостей. В исходном коде есть блоки команд, которые обращаются друг к другу. Такие обращения называются **зависимостями**. Отслеживание зависимостей — это задача компоновщика.

Компилятор генерирует объектные файлы. Они содержат машинный код, а не исходный. Компоновщик принимает на вход эти объектные файлы. Поэтому он отслеживает зависимости не в исходном коде, а в машинном. Машинный код компактнее и вв нём быстрее искать нужные блоки команд.

Предположим, что вы совместили. компилятор и компоновщик. Тогда для разрешения зависимостей понадобятся дополнительные проходы по всему исходном коду программы. Компилятору требуется намного больше времени времени на один такой проход, чем компоновщику для прохода по машинному коду. Поэтому разделив компилятор и компоновщик, вы уменьшаете общее время компиляции программы.

Программа может вызвать блоки кода из библиотеки. В этом случае компоновщик обрабатывает файл библиотеки вместе с объектными файлами компилируемой программы. Компилятор не может обработать файл библиотеки, потому что он содержит машинный код. Разделение компилятора и компоновщика решает задачу использования библиотек.

Мы рассмотрели процесс компиляции. Теперь предположим, что вы предпочли интерпретатор для запуска своей программы. В этом случае файл с исходным кодом уже готов для исполнения. Чтобы его запустить, ОС сначала загружает интерпретатор. Далее интерпретатор читает файл с исходным кодом с диска в оперативную память. Затем он исполняет файл строка за строкой. При этом перевод команд исходного кода в машинный выполняются в оперативной памяти.

Некоторые интерпретаторы сохраняют на диск файлы с промежуточным представлением программы. Это ускоряет выполнение программы, если вы её перезапустите. Но так или иначе для исполнения программы всегда нужен интерпретатор.

Процесс интерпретации программы приведён на иллюстрации 1-16.

{caption: "Иллюстрация 1-16. Интерпретация программы", height: "50%", width: "100%"}
![Интерпретация программы](images/GeneralInformation/interpreter.png)

Схема на иллюстрации 1-16 выглядит так, словно интерпретатор работает как объединённый компилятор и компоновщик. Интерпретатор загружает текстовые файлы в оперативную память и переводит их в машинный код. Почему при этом не переполняется оперативная память? Как интерпретатор справляется с зависимостями?

Интерпретатор обходит проблемы объединённого компилятора и компоновщика потому, что он обрабатывает исходный код не так как компилятор. Интерпретатор читает и выполняет программу строка за строкой. Поэтому ему не нужно хранить в памяти исходный или машинный код всего приложения. Достаточно обрабатывать части файлов с исходным кодом по мере надобности. Интерпретатор исполняет и сразу выгружает эти части из оперативной памяти.

Интерпретация программ выглядит удобнее чем компиляция. Однако, у интерпретации есть свои недостатки.

Прежде всего, все интерпретаторы работают медленно. Причина в том, что каждый раз при запуске программы, интерпретатор должен перевести её исходный код в машинный. Это долгий процесс по меркам компьютера. Другая причина медленной работы интерпретаторов связана с доступом к диску. Загрузка исходного кода программы в оперативную память приводит к простоям процессора. Согласно таблице 1-3, простои могут длится до 10000000 тактов.

Вторая проблема интерпретации в том, что сам интерпретатор — это сложная программа. Для работы она требует часть аппаратных ресурсов компьютера. Получается, что одновременно с вашей программой компьютер выполняет машинный код интерпретатора. Это лишние накладные расходы. Они замедляют работу вашей программы.

Мы выяснили, что интерпретация программы выполняется медленно. Значит ли это, что компиляция лучше? Компилятор генерирует исполняемый файл с машинным кодом. Поэтому скорость выполнения скомпилированной программы такая же, как и у написанной вручную на машинном коде. Однако, вы платите за удобство языка программирования на этапе компиляции. Чтобы скомпилировать небольшую программу, достаточно пары секунд и нескольких мегабайтов оперативной памяти. Но компиляция больших проектов (например, ядра Linux) занимает несколько часов. При любом изменении в исходном коде, компиляцию надо перезапустить и снова ждать несколько часов.

Помните про накладные расходы компиляторов и интерпретаторов, при выборе языка программирования. Интерпретатор подойдёт вам в следующих случаях:

* Вам нужно написать программу как можно быстрее.
* Вам не важна скорость выполнения программы.
* Вы работаете над небольшим и простым проектом.

В следующих случаях вам стоит выбрать компилятор:

* Вы работаете над большим и сложным проектом.
* Ваша программа должна исполняться максимально быстро.
* Вам важно быстро находить ошибки в программе.

Накладные расходы есть и у компиляторов, и у интерпретаторов. Стоит ли вообще использовать языки программирования? Не лучше ли писать программы на машинном коде, как раньше? В этом случае вы не теряете время, ожидая завершения компиляции. При этом ваша программа работает максимально быстро. Эти доводы звучат разумно. Но не торопитесь с выводами.

Простой пример поможет вам оценить преимущество языков программирования. Листинг 1-1 демонстрирует исходный код программы на языке C. Она выводит на экран текст "Hello world!".

{caption: "Листинг 1-1. Исходный код программы на языке C", format: C}
![`HelloWorld.c`](code/GeneralInformation/HelloWorld.c)

Листинг 1-2 приводит ту же программу в виде машинного кода в шестнадцатеричном представлении.

{caption: "Листинг 1-2. Машинный код программы"}
![`MachineCode.txt`](code/GeneralInformation/MachineCode.txt)

Даже если вы не знаете язык C, вы предпочтёте работать с кодом из листинга 1-1. По крайней мере, его можно быстро прочитать и изменить. Чтобы разобраться в числах из листинга 1-2 вам понадобится время.

Возможно, профессиональный программист с большим опытом работы сможет написать небольшую программу на машинном коде. Но чтобы разобраться в ней, другому программисту понадобиться много времени и сил. Разработка большого проекта на машинном коде — очень сложная задача для программиста любого уровня.

Использование языков программирования экономит ваше время и силы. Также это сокращает затраты на поддержку уже написанных программ. Разрабатывать современные сложные программы на машинном коде просто неэффективно.
