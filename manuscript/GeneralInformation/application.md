## Компьютерная программа

Мы познакомились с операционными системами. Они отвечают за запуск и выполнение компьютерных программ. Программы решают прикладные задачи пользователя. Например, текстовый редактор позволяет работать с текстом.

Программа представляет собой набор элементарных шагов или инструкций. Компьютер последовательно выполняет эти шаги. Так он справляется со сложными задачами. Рассмотрим подробнее, как происходит запуск и исполнение программы.

### Память компьютера

Инструкции компьютерной программы хранятся на жёстком диске или другом носителе информации в виде файла. Чтобы начать их исполнение, ОС загружает содержимое этого файла в оперативную память. Затем ОС выделяет процессорное время на исполнение программы. В заданные интервалы процессор выполняет инструкции программы.

Разберёмся, как ОС загружает программу в оперативную память. Начнём с общего устройства памяти компьютера.

Память компьютера измеряется в [**байтах**](https://ru.wikipedia.org/wiki/Байт). Байт — это минимальный блок информации, на который может ссылаться процессор и загружать в свою память. Процессор способен оперировать и меньшими объёмами информации — битами. [**Бит**](https://ru.wikipedia.org/wiki/Бит) — это минимальная единица информации, которую нельзя разложить на составные части. Бит представляет собой логическое состояние с двумя возможными значениями. Эти значения интерпретируются разными способами: 0 или 1, истина или ложь, да или нет, + или —, включено или выключено. Представьте себе бит, как выключатель лампы. Он либо замыкает цепь и лампа горит, либо размыкает и лампа выключена. Восемь битов составляют блок в один байт.

Упаковка битов в байты вызывает вопросы. Операции над отдельными битами возможны. Почему тогда нельзя ссылаться на конкретный бит в памяти? У этого ограничения есть исторические причины. Первые компьютеры использовались преимущественно для арифметических вычислений. Например, для расчёта [баллистических таблиц](https://ru.wikipedia.org/wiki/Баллистическая_таблица). Компьютеры оперировали целыми и дробными числами. Чтобы сохранить число в памяти, одного бита недостаточно. Поэтому понадобились блоки памяти, крупнее битов. Такими блоками стали байты. Дальше объединение битов в байты отразилось на архитектуре процессоров. Разработчики процессоров ожидали, что большая часть вычислений выполняется над числами. Поэтому загрузка и обработка всех битов числа за раз увеличивает производительность компьютера на порядок. Так получилось, что процессоры работают только с байтами.

Ещё один вопрос. Почему байт состоит именно из восьми бит? В первых компьютерах размер байта равнялся [шести битам](https://ru.wikipedia.org/wiki/Шестибитные_кодировки). Такого блока хватало для кодирования всех символов английского алфавита в верхнем и нижнем регистре, цифр, знаков пунктуации и математических операций. Со временем этого размера стало недостаточно. Байт расширили до семи битов. Этот момент совпал с появлением [ASCII-таблицы](https://ru.wikipedia.org/wiki/ASCII). Она стала стандартом для кодирования символов. Именно поэтому ASCII-таблица определяет символы для кодов от 0 до 127, то есть до максимального семибитного числа. Позднее IBM выпустила мейнфрейм [IBM System/360](https://ru.wikipedia.org/wiki/IBM_System/360). В нём размер байта составлял восемь битов. Такой размер позволял поддерживать старые кодировки символов из прошлых проектов IBM. Такая упаковка битов стала стандартом в отрасли благодаря популярности и широкому распространению IBM System/360.

Часто используемые единицы объёма информации приведены в таблице 1-1.

{caption: "Таблица 1-1. Единицы объёма информации", width: "70%"}
| Название | Сокращение | Число байтов | Число битов |
| --- | --- | --- | --- |
| килобайт | Кбайт | 1000 | 8000 |
| мегабайт | Мбайт | 1000000 | 8000000 |
| гигабайт | Гбайт | 1000000000 | 8000000000 |
| терабайт | Тбайт | 1000000000000 | 8000000000000 |

В таблице 1-2 приведены распространённые устройства хранения информации и их объёмы.

{caption: "Таблица 1-2. Устройства хранения информации", width: "50%"}
| Устройство хранения | Объём |
| --- | --- |
| [Дискета 3.5"](https://ru.wikipedia.org/wiki/Дискета) | 1.44 Мбайт |
| [Компакт-диск](https://ru.wikipedia.org/wiki/Компакт-диск) | 700 МБайт |
| [DVD-диск](https://ru.wikipedia.org/wiki/DVD) | до 17 Гбайт |
| [USB-флеш-накопитель](https://ru.wikipedia.org/wiki/USB-флеш-накопитель) | до 2 Тбайт |
| [Жёсткий диск](https://ru.wikipedia.org/wiki/Жёсткий_диск) | до 16 Тбайт |
| [Твердотельный накопитель](https://ru.wikipedia.org/wiki/Твердотельный_накопитель) | до 100 Тбайт |

Мы познакомились с единицами измерения памяти. Теперь вернёмся к исполнению программы. Зачем загружать её в оперативную память? Ведь процессор мог бы читать инструкции программы напрямую с жёсткого диска.

В современном компьютере вся память делится на [четыре уровня](https://ru.wikipedia.org/wiki/Иерархия_памяти). Они изображены на иллюстрации 1-13 красными прямоугольниками. Это физическое разделение памяти. То есть каждому уровню соответствуют разные устройства. Единственное исключение — процессор. В кристалле процессора находятся и регистры, и кэш память. Но это разные модули кристалла.

Стрелки на иллюстрации 1-13 означают потоки данных. Передача происходит только между соседними уровнями памяти. Процессор работает только с данными из своих регистров. Если ему нужны данные с дисковой памяти, их загрузка произойдёт так:

1. Дисковая память -> Оперативная память
2. Оперативная память -> Кэш процессора
3. Кэш процессора -> Регистры процессора

Данные записываются на диск в обратном порядке шагов.

{caption: "Иллюстрация 1-13. Уровни памяти персонального компьютера", height: "50%"}
![Уровни памяти](images/GeneralInformation/memory-levels.png)

Уровни памяти отличаются друг от друга следующими параметрами:

1. **Скорость доступа** — сколько данных читается или пишется на носитель в единицу времени. Единицы измерения — байты в секунду (байт/с).

2. **Объём** — максимальное количество данных, которое хранит носитель. Измеряется в байтах.

3. **Стоимость** — цена носителя в соотношении к его объёму. Измеряется в долларах или центах за байт или бит.

4. **Время доступа** — время между моментами, когда данные понадобились процессору и когда они стали ему доступны. Измеряется в [**тактовых сигналах**](https://ru.wikipedia.org/wiki/Тактовый_сигнал) процессора.

Таблица 1-3 приводит соотношение параметров разных типов памяти.

{caption: "Таблица 1-3. Уровни памяти персонального компьютера", width: "100%", column-widths: "10%,30%,*"}
| Уровень | Память | Объём | Скорость доступа | Время доступа | Стоимость |
| --- | --- | --- | --- | --- | --- |
| 1 | [**Регистры**](https://ru.wikipedia.org/wiki/Регистр_процессора) процессора. | до тысячи байтов | — | 1 такт | — |
|  | | | | | |
| 2 | [**Кэш**](https://ru.wikipedia.org/wiki/Кэш_процессора) память процессора. | от одного килобайта до нескольких мегабайтов | от 700 до 100 гигабайт/сек | от 2 до 100 тактов | — |
|  | | | | | |
| 3 | Оперативная память | десятки гигабайтов | 10 гигабайт/сек | до 1000 тактов | $10^-9^/байт |
|  | | | | | |
| 4 | Дисковая память ([**жёсткие диски**](https://ru.wikipedia.org/wiki/Жёсткий_диск) и [**твёрдотельные накопители**](https://ru.wikipedia.org/wiki/Твердотельный_накопитель)) | терабайты | 2000 мегабайт/сек | до 10000000 тактов | $10^-12^/байт |

Таблица 1-3 вызывает вопросы. Скорость доступа к дисковой памяти огромна. Почему нельзя сразу читать данные с диска в регистры? На самом деле скорость чтения не так важна. Главное — как долго простаивает процессор, дожидаясь доступа к запрошенным данным. Это время доступа к памяти измеряется в числе тактовых сигналов или тактах. Такт синхронизирует выполнение всех операций процессора. Одна инструкция программы выполняется в течении одного или нескольких тактов.

Предположим, что процессор читает инструкции программы напрямую с жёсткого диска. В этом случае простейшие алгоритмы выполнялись бы неделями. Причём большую часть этого времени процессор бы простаивал в ожидании операций чтения. Иерархическая организация памяти на порядки ускоряет доступ к данным, необходимым процессору.

Представьте, что процессор исполняет программу. Она читает файл с диска и выводит его содержимое на экран. Согласно иллюстрации 1-13, данные с диска сначала загружаются в оперативную память. Затем по частям они загружаются в кэш процессора и оттуда в его регистры. После этого CPU вызывает функцию из системной библиотеки ОС. В неё он передаёт содержимое файла. Функция обращается к драйверу видеокарты. Он выводит данные на экран.

Проблема может возникнуть, когда процессор вызвал функцию и передаёт в неё данные. Если они ещё не загружены в регистры из кэша, то CPU проведёт в ожидании от 2 до 100 тактов (согласно таблице 1-3). Аналогично, если данные ещё не загружены из RAM в кэш, то время ожидания вырастет на порядок (до 1000 тактов). Предположим, что читаемый файл оказался слишком большим. Он не поместился целиком в оперативную память. Тогда CPU может обратиться к части файла, которая ещё не загружена в RAM. В этом случае время простоя CPU увеличится на 4 порядка (до 10000000 тактов). Для сравнения за это время процессор мог бы выполнить около 1000000 инструкций программы.

За загрузку данных в кэш процессора отвечает механизм кэширования. Пример с чтением файла показал, как дорого обходится каждая ошибка этого механизма. Она называется **промахом**. Помните об иерархии памяти и учитывайте её, разрабатывая алгоритмы. Некоторые алгоритмы и структуры данных приводят к большему числу промахов, чем другие.

Чем меньше время доступа к памяти, тем ближе она к процессору. Это демонстрирует иллюстрация 1-14. Например, внутренняя память CPU (регистры и кэш) находится внутри его кристалла. Оперативная память (RAM) расположена на [**материнской плате**](https://ru.wikipedia.org/wiki/Материнская_плата) рядом с процессором. Они соединяются высокочастотной [**шиной данных**](https://ru.wikipedia.org/wiki/Шина_данных). Дисковая память подключается к материнской плате через относительно медленную шину. Пример такой шины — [**SATA**](https://ru.wikipedia.org/wiki/SATA).

За загрузку данных из RAM в кэш процессора отвечает системный контроллер. Он называется [**северный мост**](https://ru.wikipedia.org/wiki/Северный_мост_(компьютер)). В ранних версиях персональных компьютеров это был отдельный чип на материнской плате. Технология изготовления процессоров развивалась. В результате северный мост стали встраивать в кристалл процессора.

За чтение данных с жёсткого диска в оперативную память отвечает контроллер под названием [**южный мост**](https://ru.wikipedia.org/wiki/Южный_мост_(компьютер)).

{caption: "Иллюстрация 1-14. Материнская плата ПК", height: "50%"}
![Материнская плата](images/GeneralInformation/motherboard-memory.png)

### Машинный код

Предположим, что ОС загрузила содержимое исполняемого файла в оперативную память. В этом файле хранятся не только инструкции программы, но и данные для её работы. Примеры данных: текстовые строки, иконки, картинки, предопределённые константы и т.д.

Инструкции программы называются [**машинным кодом**](https://ru.wikipedia.org/wiki/Машинный_код). У процессора есть разные логические блоки. Каждый блок выполняет свой тип инструкций. Набор блоков определяет, какие операции поддерживает CPU. Если процессор не имеет отдельного блока для выполнения операции, она выполняется комбинацией блоков. Такое исполнение займёт больше времени и ресурсов. Одна инструкция считается элементарной операцией над данными в регистрах CPU.

После загрузки программы в оперативную память CPU начинает её исполнять. Исполнение программы называется [**вычислительным процессом**](https://ru.wikipedia.org/wiki/Процесс_(информатика)) (process). К процессу также относятся ресурсы, которые использует работающая программа. Это область памяти и объекты ОС.

Есть специальные программы для чтения и редактирования исполняемых файлов. Они называются [**Hex-редакторами**](https://ru.wikipedia.org/wiki/Hex-редактор). Такие редакторы представляют машинный код программы в [**шестнадцатеричной системе счисления**](https://ru.wikipedia.org/wiki/Шестнадцатеричная_система_счисления). На самом деле в исполняемом файле хранится [**двоичный код**](https://ru.wikipedia.org/wiki/Двоичный_код#Примеры_двоичных_чисел). Этот код представляет собой последовательность нулей и единиц. Hex-редактор для удобства чтения переводит их в шестнадцатеричный формат. Именно в двоичном коде процессор получает инструкции и данные.

Одно и то же число в разных системах счисления выглядит по-разному. Система счисления определяет, какие символы и в каком порядке используются при записи числа. Например, двоичная система допускает только символы 0 и 1.

Таблица 1-4 приводит соответствие чисел в двоичной (binary, BIN), десятичной (decimal, DEC) и шестнадцатеричной (hexadecimal, HEX) системах счисления.

{caption: "Таблица 1-4. Числа в системах счисления DEC, HEX и BIN", width: "50%"}
| Десятичная | Шестнадцатеричная | Двоичная |
| --- | --- | --- |
| 0 | 0 | 0000 |
| 1 | 1 | 0001 |
| 2 | 2 | 0010 |
| 3 | 3 | 0011 |
| 4 | 4 | 0100 |
| 5 | 5 | 0101 |
| 6 | 6 | 0110 |
| 7 | 7 | 0111 |
| 8 | 8 | 1000 |
| 9 | 9 | 1001 |
| 10 | A | 1010 |
| 11 | B | 1011 |
| 12 | C | 1100 |
| 13 | D | 1101 |
| 14 | E | 1110 |
| 15 | F | 1111 |

I> Для перевода из одной системы счисления в другую используйте стандартный калькулятор Windows. Функция перевода доступна в [**режиме "Программист"**](https://ru.wikipedia.org/wiki/Калькулятор_(Windows)#Режим_«Программист»).

Почему двоичная и шестнадцатеричная система используются в программировании? На двоичной системе и булевой алгебре строится современная [**цифровая техника**](https://ru.wikipedia.org/wiki/Цифровые_технологии). В цифровой технике элементарный носитель информации — это электрический [**сигнал**](https://ru.wikipedia.org/wiki/Сигнал). Простейший способ его закодировать — различать состояния, когда он есть и когда его нет. Наличие сигнала кодируется единицей, а отсутствие — нулём. Для такого кодирования достаточно одного бита.

Базовый элемент в цифровой технике — это [**логический вентиль**](https://ru.wikipedia.org/wiki/Логический_вентиль). Он преобразовывает электрические сигналы. Роль логического вентиля способны выполнять разные элементы. Это могут быть электромагнитные реле, электровакуумные лампы или транзисторы. Все эти устройства работают одинаково с точки зрения обработки сигналов. Эта обработка состоит из двух действий:

1. Получить на вход один или более сигналов.
2. Передать результирующий сигнал на выход.

Такая обработка выполняется по правилам [**булевой алгебры**](https://ru.wikipedia.org/wiki/Булева_алгебра). Она также известна как [**алгебра логики**](https://ru.wikipedia.org/wiki/Алгебра_логики). Каждой операции булевой алгебры соответствует логический вентиль. Если соединить их последовательно, получается сложное преобразование сигналов. По сути центральный процессор — это огромная сеть логических вентилей.

Двоичная система счисления позволяет работать с цифровой техникой на самом низком уровне. Это уровень электрических сигналов. Получается, что устройство аппаратуры навязывает нам двоичную систему.

Аппаратура работает в двоичной системе счисления. Зачем тогда понадобилась шестнадцатеричная система? На самом деле программисты используют либо десятичную систему, либо двоичную. Первая удобна при написании высокоуровневой логики программы. Например, для подсчёта повторений одного и того же действия. Двоичная система нужна для взаимодействия с аппаратурой. Например, для подготовки и передачи данных на устройство. У двоичной системы есть проблема. Её неудобно записывать, читать, запоминать и произносить. Перевод же из десятичной в двоичную сложен. Проблему перевода решает шестнадцатеричная система. Она так же компактна и удобна, как и десятичная. Перевод из шестнадцатеричной в двоичную систему и обратно выполняется в уме.

Рассмотрим перевод числа из двоичной системы в шестнадцатеричную. Для этого разбейте число на группы по четыре разряда, начиная с конца. Если последняя группа оказалась меньше четырёх разрядов, дополните её слева нулями. Затем по таблице 1-4 каждую четвёрку разрядов замените на шестнадцатеричное число. Вот пример перевода:
```
110010011010111 = 110 0100 1101 0111 = 0110 0100 1101 0111 = 6 4 D 7 = 64D7
```

{caption: "Упражнение 1-1. Перевод чисел из BIN в HEX", line-numbers: false}
```
Переведите следующие числа из двоичной системы в шестнадцатеричную:
* 10100110100110
* 1011000111010100010011
* 1111101110001001010100110000000110101101
```

{caption: "Упражнение 1-2. Перевод чисел из HEX в BIN", line-numbers: false}
```
Переведите следующие числа из шестнадцатеричной системы в двоичную:
* FF00AB02
* 7854AC1
* 1E5340ACB38
```

В последнем разделе книги вы найдёте ответы на все упражнения. Если вы не уверены в своём результате, сверьтесь с ответами.

Вернёмся к нашему исполняемому файлу. Кроме него в оперативную память загружаются все необходимые для работы приложения библиотеки (в том числе системные). За эту процедуру отвечает [**загрузчик программ Windows**](https://ru.wikipedia.org/wiki/Загрузчик_программ). Благодаря предварительной загрузке библиотек, процессору не приходится ждать, когда программа к ним обращается. Код нужной библиотеки уже находится в памяти и доступен CPU в течении нескольких сотен тактов. После окончания работы загрузчика Windows программа считается процессом. CPU исполняет её, начиная с первой инструкции.

Пока программа выполняется, её инструкции, ресурсы и библиотеки занимают область RAM. После завершения программы эта область памяти очищается. С этого момента её могут использовать другие приложения.

### Исходный код

Машинный код — это низкоуровневое представление программы. Такой формат инструкций и данных удобен для процессора. Однако, человеку писать программу в таком виде неудобно. Эта проблема стала ещё актуальнее с увеличением мощности компьютеров и усложнением программ. Проблему решают специальные приложения двух типов: [**компиляторы**](https://ru.wikipedia.org/wiki/Компилятор) и [**интерпретаторы**](https://ru.wikipedia.org/wiki/Интерпретатор). Они выполняют одну и ту же задачу: переводят текст программы с удобного человеку языка в машинный код.

Сегодня программы пишут на [**языках программирования**](https://ru.wikipedia.org/wiki/Язык_программирования). Они отличаются от [**естественных языков**](https://ru.wikipedia.org/wiki/Естественный_язык), на которых общаются люди. Языки программирования очень ограничены. На них можно выразить только действия, которые способен выполнить компьютер. Также эти языки отличаются строгими правилами. Например, допустим небольшой набор слов. Сочетать слова можно только в определённом порядке. Текст программы, записанный на языке программирования, называется [**исходным кодом**](https://ru.wikipedia.org/wiki/Исходный_код).

Компилятор и интерпретатор работают с исходным кодом по-разному. Отличие в моменте, когда машинный код генерируется из исходного. Компилятор читает текст программы целиком, генерирует инструкции процессора и сохраняет результат в файл на диске. При этом программа не исполняется. Интерпретатор читает исходный код по частям, генерирует инструкции процессора и сразу же их исполняет. Результат работы интерпретатора временно хранится в оперативной памяти.

Рассмотрим пример компиляции программы. Предположим, что вы написали и сохранили её исходный код в файл на жёстком диске. Дальше вы запускаете подходящий компилятор. Для каждого языка программирования есть свой компилятор или интерпретатор. Результат компиляции программы сохраняется в исполняемый файл на диске. Файл содержит машинный код. Он соответствует исходному коду программы. Теперь для выполнения программы достаточно запустить её исполняемый файл.

Иллюстрация 1-15 демонстрирует процесс компиляции программы, написанной на языке C или C++.

{caption: "Иллюстрация 1-15. Компиляция программы", height: "50%", width: "100%"}
![Компиляция программы](images/GeneralInformation/compiler.png)

Компиляция состоит из двух этапов. Первый этап выполняет компилятор. Второй этап называется **линковка**. Его выполняет специальная программа [**компоновщик**](https://ru.wikipedia.org/wiki/Компоновщик).

Компилятор создаёт промежуточные **объектные файлы**. Их использует линковщик, чтобы создать исполняемый файл. Почему нельзя объединить компилятор и линковщик в одну программу? У такого решения есть несколько проблемы. Первая связана с ограниченным размером оперативной памяти. Исходный код программы принято разбивать на несколько файлов. Компилятор обрабатывает их по отдельности и записывает результаты на диск в объектные файлы. Это промежуточные результаты компиляции. Если объединить компилятор и линковщик, сохранять промежуточные результаты на диск не получится. Всю программу придётся компилировать целиком за раз. В этом случае может не хватить оперативной памяти.

Вторая проблема заключается в разрешении зависимостей. В исходном коде есть блоки команд, которые обращаются друг к другу. Чтобы сопоставить такие перекрёстные вызовы, компилятору нужны дополнительные проходы по всему коду программы. Это увеличивает время компиляции в разы. Линковщик решает эту задачу быстрее.

Возможны случаи, когда в исходном коде вызываются функции из библиотеки. Тогда она подаётся на вход линковщика вместе с объектными файлами. Компилятор не может обработать библиотеку. Поскольку, она поставляется в машинном, а не в исходном коде. Разделение компиляции на два этапа решает эту проблему.

Теперь предположим, что для перевода исходного кода программы вы выбрали интерпретатор. В этом случае файл с исходным кодом уже готов для исполнения. Чтобы его запустить, ОС сначала загружает интерпретатор. Далее интерпретатор читает файл с исходным кодом с диска в оперативную память. Затем он исполняет файл строка за строкой. При этом преобразования команд исходного кода в машинный выполняются в оперативной памяти. Некоторые интерпретаторы сохраняют на диск файлы с промежуточным представлением программы. Это нужно для оптимизации. Но так или иначе программу всегда исполняет интерпретатор.

Процесс интерпретации программы приведён на иллюстрации 1-16.

{caption: "Иллюстрация 1-16. Интерпретация программы", height: "50%", width: "100%"}
![Интерпретация программы](images/GeneralInformation/interpreter.png)

Схема на иллюстрации 1-16 выглядит так, словно интерпретатор работает как компилятор, объединённый с линковщиком. Интерпретатор загружает текстовые файлы в оперативную память и переводит их в машинный код. Почему при этом не возникает проблем с объёмом RAM и перекрёстными вызовами блоков кода?

Интерпретатор обрабатывает исходный код не так как компилятор. Он читает и выполняет программу строка за строкой. Это значит, что ему не нужно хранить в памяти машинный код всего приложения. Достаточно обрабатывать текстовые файлы с исходным кодом по мере надобности. Для экономии оперативной памяти, интерпретатор периодически удаляет уже выполненные команды.

Все интерпретаторы работают медленно. Загрузка исходного кода программы с диска в RAM приводит к простоям процессора. Согласно таблице 1-3, эта загрузка занимает до 10000000 тактов. Кроме того сам интерпретатор — это сложная программа. Для работы она требует часть аппаратных ресурсов компьютера. Получается, что в дополнение к вашей программе компьютер параллельно выполняет инструкции интерпретатора. Это лишние накладные расходы. Они замедляют работу программы.

Интерпретация программ обходится дорого. А что насчёт компиляции? Компилятор генерирует исполняемый файл с машинным кодом. Поэтому скорость выполнения скомпилированной программы такая же, как и написанной вручную на машинном коде. Однако, вы платите за удобство языка программирования на этапе компиляции. Чтобы скомпилировать небольшую программу, достаточно пары секнуд и нескольких мегабайтов RAM. Но компиляция больших проектов (например, ядро ОС) занимает несколько часов. Помните про накладные расходы, при выборе языка программирования. Одни задачи лучше решает интерпретатор, другие — компилятор.

Стоит ли вообще использовать языки программирования? Время на компиляцию проекта можно потратить на написание программы в машинном коде. Кажется, что так вы сэкономите время и ресурсы компьютера. Пример поможет оценить преимущество языков программирования. Листинг 1-1 демонстрирует исходный код программы на языке C. Она выводит на экран текст "Hello world!".

{caption: "Листинг 1-1. Исходный код программы на языке C", format: C}
![`HelloWorld.c`](code/GeneralInformation/HelloWorld.c)

Листинг 1-2 приводит ту же программу в виде машинного кода в шестнадцатеричном представлении.

{caption: "Листинг 1-2. Машинный код программы"}
![`MachineCode.txt`](code/GeneralInformation/MachineCode.txt)

Даже если вы не знаете язык C, код из листинга 1-1 выглядит понятнее, чем из листинга 1-2. Его проще прочитать и отредактировать. Возможно, профессионал сможет быстро написать машинный код для небольшой программы. Но чтобы разобраться в нём, другому программисту понадобиться много времени и сил.

Язык программирования удобнее и выразительнее машинного кода. С его помощью программы проще разрабатывать и поддерживать.
