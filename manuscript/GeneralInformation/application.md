## Компьютерная программа

Мы познакомились с операционными системами. Они отвечают за запуск и выполнение компьютерных программ. Программы решают прикладные задачи пользователя. Например, текстовый редактор позволяет работать с текстом.

Программа представляет собой набор элементарных шагов или инструкций. Компьютер последовательно выполняет эти шаги. Так он справляется со сложными задачами. Рассмотрим подробнее, как происходит запуск и исполнение программы.

### Память компьютера

Инструкции компьютерной программы хранятся на жёстком диске или другом носителе информации в виде файла. Чтобы начать их исполнение, ОС загружает содержимое этого файла в оперативную память. Затем ОС выделяет процессорное время на исполнение программы. В заданные интервалы процессор выполняет инструкции программы.

Разберёмся, как ОС загружает программу в оперативную память. Начнём с общего устройства памяти компьютера.

Память компьютера измеряется в [**байтах**](https://ru.wikipedia.org/wiki/Байт). Байт — это минимальный блок информации, на который может ссылаться процессор и загружать в свою память. Процессор способен оперировать и меньшими объёмами информации — битами. [**Бит**](https://ru.wikipedia.org/wiki/Бит) — это минимальная единица информации, которую нельзя разложить на составные части. Бит представляет собой логическое состояние с двумя возможными значениями. Эти значения интерпретируются разными способами: 0 или 1, истина или ложь, да или нет, + или —, включено или выключено. Представьте себе бит, как выключатель лампы. Он либо замыкает цепь и лампа горит, либо размыкает и лампа выключена. Восемь битов составляют блок в один байт.

Упаковка битов в байты вызывает вопросы. Операции над отдельными битами возможны. Почему тогда нельзя ссылаться на конкретный бит в памяти? У этого ограничения есть исторические причины. Первые компьютеры использовались преимущественно для арифметических вычислений. Например, для расчёта [баллистических таблиц](https://ru.wikipedia.org/wiki/Баллистическая_таблица). Компьютеры оперировали целыми и дробными числами. Чтобы сохранить число в памяти, одного бита недостаточно. Поэтому понадобились блоки памяти, крупнее битов. Такими блоками стали байты. Дальше объединение битов в байты отразилось на архитектуре процессоров. Разработчики процессоров ожидали, что большая часть вычислений выполняется над числами. Поэтому загрузка и обработка всех битов числа за раз увеличит производительность компьютера на порядок. Так получилось, что процессоры работают только с байтами.

Ещё один вопрос. Почему байт состоит именно из восьми бит? В первых компьютерах размер байта равнялся [шести битам](https://ru.wikipedia.org/wiki/Шестибитные_кодировки). Такого блока хватало для кодирования всех символов английского алфавита в верхнем и нижнем регистре, цифр, знаков пунктуации и математических операций. Со временем этого размера стало недостаточно. Байт расширили до семи битов. Этот момент совпал с появлением [ASCII-таблицы](https://ru.wikipedia.org/wiki/ASCII). Она стала стандартом для кодирования символов. Именно поэтому ASCII-таблица определяет символы для кодов от 0 до 127, то есть до максимального семибитного числа. Позднее IBM выпустила мейнфрейм [IBM System/360](https://ru.wikipedia.org/wiki/IBM_System/360). В нём размер байта составлял восемь битов. Такой размер позволял поддерживать старые кодировки символов из прошлых проектов IBM. Такая упаковка битов стала стандартом в отрасли благодаря популярности и широкому распространению IBM System/360.

Часто используемые единицы объёма информации приведены в таблице 1-1.

{caption: "Таблица 1-1. Единицы объёма информации", width: "70%"}
| Название | Сокращение | Число байтов | Число битов |
| --- | --- | --- | --- |
| килобайт | Кбайт | 1000 | 8000 |
| мегабайт | Мбайт | 1000000 | 8000000 |
| гигабайт | Гбайт | 1000000000 | 8000000000 |
| терабайт | Тбайт | 1000000000000 | 8000000000000 |

В таблице 1-2 приведены распространённые устройства хранения информации и их объёмы.

{caption: "Таблица 1-2. Устройства хранения информации", width: "50%"}
| Устройство хранения | Объём |
| --- | --- |
| [Дискета 3.5"](https://ru.wikipedia.org/wiki/Дискета) | 1.44 Мбайт |
| [Компакт-диск](https://ru.wikipedia.org/wiki/Компакт-диск) | 700 МБайт |
| [DVD-диск](https://ru.wikipedia.org/wiki/DVD) | до 17 Гбайт |
| [USB-флеш-накопитель](https://ru.wikipedia.org/wiki/USB-флеш-накопитель) | до 2 Тбайт |
| [Жёсткий диск](https://ru.wikipedia.org/wiki/Жёсткий_диск) | до 16 Тбайт |
| [Твердотельный накопитель](https://ru.wikipedia.org/wiki/Твердотельный_накопитель) | до 100 Тбайт |

Мы познакомились с единицами измерения памяти. Теперь вернёмся к исполнению программы. Зачем загружать её в оперативную память? Ведь процессор мог бы читать инструкции программы напрямую с жёсткого диска.

В современном компьютере вся память делится на [четыре уровня](https://ru.wikipedia.org/wiki/Иерархия_памяти). Они изображены на иллюстрации 1-13 красными прямоугольниками. Это физическое разделение памяти. То есть каждому уровню соответствуют разные устройства. Единственное исключение — процессор. В кристалле процессора находятся и регистры, и кэш память. Но это разные модули кристалла.

Стрелки на иллюстрации 1-13 означают потоки данных. Передача происходит только между соседними уровнями памяти. Процессор работает только с данными из своих регистров. Если ему нужны данные с дисковой памяти, их загрузка произойдёт так:

1. Дисковая память -> Оперативная память
2. Оперативная память -> Кэш процессора
3. Кэш процессора -> Регистры процессора

Данные записываются на диск в обратном порядке шагов.

{caption: "Иллюстрация 1-13. Уровни памяти персонального компьютера", height: "50%"}
![Уровни памяти](images/GeneralInformation/memory-levels.png)

Уровни памяти отличаются друг от друга следующими параметрами:

1. **Скорость доступа** — сколько данных читается или пишется на носитель в единицу времени. Единицы измерения — байты в секунду (байт/с).

2. **Объём** — максимальное количество данных, которое хранит носитель. Измеряется в байтах.

3. **Стоимость** — цена носителя в соотношении к его объёму. Измеряется в долларах или центах за байт или бит.

4. **Время доступа** — время между моментами, когда данные понадобились процессору и когда они стали ему доступны. Измеряется в [**тактовых сигналах**](https://ru.wikipedia.org/wiki/Тактовый_сигнал) процессора.

Таблица 1-3 приводит соотношение параметров разных типов памяти.

{caption: "Таблица 1-3. Уровни памяти персонального компьютера", width: "100%", column-widths: "10%,30%,*"}
| Уровень | Память | Объём | Скорость доступа | Время доступа | Стоимость |
| --- | --- | --- | --- | --- | --- |
| 1 | [**Регистры**](https://ru.wikipedia.org/wiki/Регистр_процессора) процессора. | до тысячи байтов | — | 1 такт | — |
|  | | | | | |
| 2 | [**Кэш**](https://ru.wikipedia.org/wiki/Кэш_процессора) память процессора. | от одного килобайта до нескольких мегабайтов | от 700 до 100 гигабайт/сек | от 2 до 100 тактов | — |
|  | | | | | |
| 3 | Оперативная память | десятки гигабайтов | 10 гигабайт/сек | до 1000 тактов | $10^-9^/байт |
|  | | | | | |
| 4 | Дисковая память ([**жёсткие диски**](https://ru.wikipedia.org/wiki/Жёсткий_диск) и [**твёрдотельные накопители**](https://ru.wikipedia.org/wiki/Твердотельный_накопитель)) | терабайты | 2000 мегабайт/сек | до 10000000 тактов | $10^-12^/байт |

Таблица 1-3 вызывает вопросы. Скорость доступа к дисковой памяти огромна. Почему нельзя сразу читать данные с диска в регистры? На самом деле скорость чтения не так важна. Главное — как долго простаивает процессор, дожидаясь доступа к запрошенным данным. Это время доступа к памяти измеряется в числе тактовых сигналов или тактах. Такт синхронизирует выполнение всех операций процессора. Одна инструкция программы выполняется в течении одного или нескольких тактов.

Предположим, что процессор читает инструкции программы напрямую с жёсткого диска. В этом случае простейшие алгоритмы выполнялись бы неделями. Причём большую часть этого времени процессор бы простаивал в ожидании операций чтения. Иерархическая организация памяти на порядки ускоряет доступ к данным, необходимым процессору.

Представьте, что процессор исполняет программу. Она читает файл с диска и выводит его содержимое на экран. Согласно иллюстрации 1-13, данные с диска сначала загружаются в оперативную память. Затем по частям они загружаются в кэш процессора и оттуда в его регистры. После этого CPU вызывает функцию из системной библиотеки ОС. В неё он передаёт содержимое файла. Функция обращается к драйверу видеокарты. Он выводит данные на экран.

Проблема может возникнуть, когда процессор вызвал функцию и передаёт в неё данные. Если они ещё не загружены в регистры из кэша, то CPU проведёт в ожидании от 2 до 100 тактов (согласно таблице 1-3). Аналогично, если данные ещё не загружены из RAM в кэш, то время ожидания вырастет на порядок (до 1000 тактов). Предположим, что читаемый файл оказался слишком большим. Он не поместился целиком в оперативную память. Тогда CPU может обратиться к части файла, которая ещё не загружена в RAM. В этом случае время простоя CPU увеличится на 4 порядка (до 10000000 тактов). Для сравнения за это время процессор мог бы выполнить около 1000000 инструкций программы.

За загрузку данных в кэш процессора отвечает механизм кэширования. Пример с чтением файла показал, как дорого обходится каждая ошибка этого механизма. Она называется **промахом**. Помните об иерархии памяти и учитывайте её, разрабатывая алгоритмы. Некоторые алгоритмы и структуры данных приводят к большему числу промахов, чем другие.

Чем меньше время доступа к памяти, тем ближе она к процессору. Это демонстрирует иллюстрация 1-14. Например, внутренняя память CPU (регистры и кэш) находится внутри его кристалла. Оперативная память (RAM) расположена на [**материнской плате**](https://ru.wikipedia.org/wiki/Материнская_плата) рядом с процессором. Они соединяются высокочастотной [**шиной данных**](https://ru.wikipedia.org/wiki/Шина_данных). Дисковая память подключается к материнской плате через относительно медленную шину. Пример такой шины — [**SATA**](https://ru.wikipedia.org/wiki/SATA).

За загрузку данных из RAM в кэш процессора отвечает системный контроллер. Он называется [**северный мост**](https://ru.wikipedia.org/wiki/Северный_мост_(компьютер)). В ранних версиях персональных компьютеров это был отдельный чип на материнской плате. Технология изготовления процессоров развивалась. В результате северный мост стали встраивать в кристалл процессора.

За чтение данных с жёсткого диска в оперативную память отвечает контроллер под названием [**южный мост**](https://ru.wikipedia.org/wiki/Южный_мост_(компьютер)).

{caption: "Иллюстрация 1-14. Материнская плата ПК", height: "50%"}
![Материнская плата](images/GeneralInformation/motherboard-memory.png)

### Машинный код

Предположим, что ОС успешно загрузила содержимое исполняемого файла приложения в оперативную память. В этом файле хранятся не только инструкции программы, но и необходимые данные для её работы. Этими данными могут быть текстовые строки, иконки, картинки, предопределённые константы и т.д. Инструкции программы называются [**машинным кодом**](https://ru.wikipedia.org/wiki/Машинный_код). За исполнение каждой из них отвечает определённый логический блок процессора. Набор этих блоков определяет поддерживаемые CPU операции. Если процессор не имеет блока для выполнения какой-то операции, она всё равно может быть выполнена с помощью комбинации других блоков. Но такое исполнение будет неоптимальным, потому что займёт больше времени и ресурсов. В любом случае машинная инструкция считается элементарной операцией над данными, загруженными в регистры CPU.

После загрузки программы в оперативную память CPU начинает её исполнение. Это исполнение называется [**вычислительным процессом**](https://ru.wikipedia.org/wiki/Процесс_(информатика)) (process). К процессу также относятся ресурсы, которые использует работающая программа: память и объекты ОС.

Есть специальные программы для чтения и редактирования исполняемых файлов. Они называются [**Hex-редакторами**](https://ru.wikipedia.org/wiki/Hex-редактор). Такие редакторы представляют машинный код программы в [**шестнадцатеричной системе счисления**](https://ru.wikipedia.org/wiki/Шестнадцатеричная_система_счисления). На самом деле в исполняемом файле хранится [**двоичный код**](https://ru.wikipedia.org/wiki/Двоичный_код#Примеры_двоичных_чисел). Этот код представляет собой последовательность байтов, то есть нулей и единиц. Hex-редактор для удобства чтения переводит последовательность байтов в шестнадцатеричный формат. Именно в двоичном коде процессор получает инструкции и данные.

Одно и то же число можно представить в разных системах счисления. Система счисления определяет, какие символы и в каком порядке используются при записи числа. Например, двоичная система допускает только символы 0 и 1. Таблица 1-4 демонстрирует соответствие чисел в двоичной (binary, BIN), десятичной (decimal, DEC) и шестнадцатеричной (hexadecimal, HEX) системах счисления.

{caption: "Таблица 1-4. Числа в системах счисления: DEC, HEX и BIN", width: "50%"}
| Десятичная | Шестнадцатеричная | Двоичная |
| --- | --- | --- |
| 0 | 0 | 0000 |
| 1 | 1 | 0001 |
| 2 | 2 | 0010 |
| 3 | 3 | 0011 |
| 4 | 4 | 0100 |
| 5 | 5 | 0101 |
| 6 | 6 | 0110 |
| 7 | 7 | 0111 |
| 8 | 8 | 1000 |
| 9 | 9 | 1001 |
| 10 | A | 1010 |
| 11 | B | 1011 |
| 12 | C | 1100 |
| 13 | D | 1101 |
| 14 | E | 1110 |
| 15 | F | 1111 |

I> Для перевода из одной системы счисления в другую используйте стандартный калькулятор Windows. Функция перевода доступна в [**режиме "Программист"**](https://ru.wikipedia.org/wiki/Калькулятор_(Windows)#Режим_«Программист»).

Почему в программировании наряду с десятичной системой активно используются двоичная и шестнадцатеричная? На двоичной системе и булевой алгебре строится вся современная [**цифровая техника**](https://ru.wikipedia.org/wiki/Цифровые_технологии). В цифровой технике элементарным носителем информации является электрический [**сигнал**](https://ru.wikipedia.org/wiki/Сигнал). Самый экономичный способ кодирования сигнала заключается в различении двух состояний: когда он есть и когда его нет. Наличие сигнала кодируется единицей, а отсутствие — нулём. То есть для кодирования достаточно одного бита.

[**Логический вентиль**](https://ru.wikipedia.org/wiki/Логический_вентиль) — базовый элемент в цифровой технике. Он преобразовывает электрические сигналы. Физически эти элементы могут принципиально различаться. На разных этапах развития компьютеров их роль выполняли: электромагнитные реле, электровакуумные лампы и транзисторы. Но все эти устройства работают одинаково с точки зрения обработки сигналов. Эта обработка состоит из двух действий: получения одного или двух сигналов на вход и передача на выход одного результирующего сигнала. Такая обработка выполняется по правилам [**булевой алгебры**](https://ru.wikipedia.org/wiki/Булева_алгебра), также известной как [**алгебра логики**](https://ru.wikipedia.org/wiki/Алгебра_логики). То есть для каждой операции этой алгебры существует соответствующий логический вентиль. Если соединить их последовательно, получается сложное преобразование сигналов. По сути центральный процессор есть не что иное, как огромная сеть логических элементов. Двоичная система счисления позволяет работать с цифровой техникой на самом низком уровне, то есть на уровне электрических сигналов. Получается, что использование этой системы в программировании продиктовано особенностью работы аппаратуры.

Зачем в таком случае понадобилась шестнадцатеричная система для разработки программ? На самом деле программисты в своей работе используют либо десятичную систему, либо двоичную. Первая удобна при написании высокоуровневой логики программы. Например, для расчёта того, сколько раз надо повторить то или иное действие. Двоичная система применяется, когда программе приходится взаимодействовать с аппаратурой. Например, для подготовки и передачи данных на устройство. Проблема двоичной системы в том, что она неудобна человеку для записи, чтения, запоминания и произношения. Перевод же из DEC в BIN достаточно сложен. Именно эту проблему перевода чисел решает шестнадцатеричная система. Она так же компактна и удобна для человека, как и десятичная. Перевод из неё в двоичную систему и обратно можно производить в уме.

Чтобы перевести число из двоичной системы в шестнадцатеричную, разбейте его на группы по четыре разряда, начиная с конца. Если последняя группа оказалась меньше четырёх разрядов дополните её нулями впереди. Затем по таблице 1-4 каждую четвёрку замените на шестнадцатеричное число. Рассмотрим пример такого перевода:
```
110010011010111 = 110 0100 1101 0111 = 0110 0100 1101 0111 = 6 4 D 7 = 64D7 
```

{caption: "Упражнение 1-1. Перевод чисел из BIN в HEX", line-numbers: false}
```
Переведите следующие числа из двоичной системы в шестнадцатеричную:
* 10100110100110
* 1011000111010100010011
* 1111101110001001010100110000000110101101
```

{caption: "Упражнение 1-2. Перевод чисел из HEX в BIN", line-numbers: false}
```
Переведите следующие числа из шестнадцатеричной системы в двоичную:
* FF00AB02
* 7854AC1
* 1E5340ACB38
```

Ответы на все упражнения приведены в последнем разделе книги. Если вы не уверены в правильности своего результата, сверьтесь с ответами.

Вернёмся к нашему исполняемому файлу. Кроме него в оперативную память загружаются все необходимые для работы приложения библиотеки (в том числе системные). За эту процедуру отвечает [**загрузчик программ Windows**](https://ru.wikipedia.org/wiki/Загрузчик_программ). Благодаря предварительной загрузке библиотек, процессору не приходится ждать, когда программа к ним обращается. Весь код библиотеки уже в памяти и доступен CPU в течении нескольких сотен тактов. После окончания работы загрузчика Windows программа считается процессом и исполняется CPU, начиная со своей первой инструкции.

После окончания работы программы занимаемая ей и загруженными библиотеками область RAM очищается. Она может использоваться другими приложениями.

### Исходный код

Машинный код, представленный в двоичном виде, понятен процессору. Однако, человеку писать программу на нём очень неудобно. Особенно остро эта проблема стала проявляться с увеличением мощности компьютеров и усложнении их программ. Для её решения появились специальные приложения: [**компиляторы**](https://ru.wikipedia.org/wiki/Компилятор) и [**интерпретаторы**](https://ru.wikipedia.org/wiki/Интерпретатор). Оба типа приложений решают одну и ту же задачу. Эта задача состоит из двух шагов:

1. Прочитать текст программы, написанный на удобном для человека языке.

2. Перевести текст в машинный код.

Программы пишут на [**языках программирования**](https://ru.wikipedia.org/wiki/Язык_программирования). Они отличаются от [**естественного языка**](https://ru.wikipedia.org/wiki/Естественный_язык), на котором мы с вами общаемся. Главное отличие языков программирования заключается в искусственном ограничении того, что можно на них выразить. Нет смысла описывать в программе что-то, что компьютер не способен выполнить. Также языки программирования отличаются строгими правилами. Например, набор допустимых слов ограничен и они должны следовать в определённом порядке. Текст программы, записанный на языке программирования, называется [**исходным кодом**](https://ru.wikipedia.org/wiki/Исходный_код).

Компиляторы и интерпретаторы работают с исходным кодом по-разному. Отличие заключается в моменте, когда машинный код генерируется из исходного. Компиляторы читают текст программы целиком, генерируют инструкции процессора и сохраняют результат в файл на диске. При этом программа не исполняется. Интерпретаторы читают исходный код по частям, генерируют инструкции процессора и сразу же их исполняют. Результат работы интерпретатора временно хранится в оперативной памяти.

Рассмотрим пример компиляции программы. Предположим, что вы написали и сохранили её исходный код в файл на жёстком диске. Дальше вы запускаете компилятор того языка программирования, который вы использовали. Результат компиляции программы будет сохранён в новый исполняемый файл на диске. Он содержит машинный код, соответствующий исходному коду вашей программы. Теперь, чтобы выполнить программу, достаточно запустить исполняемый файл.

Иллюстрация 1-15 демонстрирует процесс компиляции программы, написанной на языке C или C++.

{caption: "Иллюстрация 1-15. Компиляция программы", height: "50%", width: "100%"}
![Компиляция программы](images/GeneralInformation/compiler.png)

Согласно иллюстрации, компиляция состоит из двух этапов. Первый выполняется компилятором. Второй этап под названием **линковка** выполняется специальной программой [**компоновщиком**](https://ru.wikipedia.org/wiki/Компоновщик).

При линковке создаются промежуточные **объектные файлы**. Может возникнуть вопрос — зачем они нужны? Почему нельзя объединить компилятор и линковщик в одну программу? У такого решения есть две проблемы. Первая заключается в ограниченном размере оперативной памяти. Исходный код программы обычно разбивается на несколько файлов. Компилятор, работая с ним, строит **промежуточное представление программы**. Это представление хранится в RAM и может по различным причинам значительно превосходить по размеру файл с исходным кодом. Чтобы получить исполняемый файл, компилятор должен пройти по всему исходному коду. Сохранять промежуточные результаты на диск нельзя. В этом случае очень высока вероятность, что оперативной памяти просто не хватит.

Вторая проблема заключается в разрешении зависимостей. Функции каждого из трёх [**текстовых файлов**](https://ru.wikipedia.org/wiki/Текстовый_файл) с исходным кодом на иллюстрации 1-15 могут вызывать друг друга. Компилятору потребовалось бы намного больше времени, чтобы сопоставить эти перекрёстные вызовы сразу в процессе компиляции. Кроме того возможны случаи, когда для получения исполняемого файла необходима дополнительная библиотека. В этом случае она выполняет роль ещё одного объектного файла, который подаётся на вход компоновщика. Из-за этих проблем разделение компиляции на два этапа даёт более надёжное и гибкое решение.

Теперь предположим, что для исполнения программы вы выбрали интерпретатор, а не компилятор. В этом случае файл с исходным кодом уже готов для исполнения. Чтобы его запустить, ОС сначала загружает интерпретатор. Далее интерпретатор читает файл с исходным кодом с диска в оперативную память и начинает его выполнение строка за строкой. При этом преобразование каждой команды исходного кода в машинный код происходит в оперативной памяти. В целях оптимизации некоторые интерпретаторы сохраняют на жёсткий диск файлы с промежуточным представлением программы. Но главная идея в том, что программу всегда исполняет интерпретатор.

Иллюстрация 1-16 демонстрирует процесс интерпретации программы.

{caption: "Иллюстрация 1-16. Интерпретация программы", height: "50%", width: "100%"}
![Интерпретация программы](images/GeneralInformation/interpreter.png)

Задумайтесь над проблемами компиляции за один этап, которые мы рассмотрели. Теперь посмотрите ещё раз на иллюстрацию 1-16. Вам не кажется, что интерпретатор работает как "одноэтапный" компилятор? Он загружает все текстовые файлы в оперативную память, строит их промежуточное представление, а затем разрешает зависимости. Как ему это удаётся?

На самом деле интерпретатор обрабатывает исходный код не так как компилятор. Он читает и выполняет программу строка за строкой. Это значит, что ему не нужно хранить в памяти код всего приложения и его промежуточное представление. Достаточно обрабатывать исходный код по мере надобности. При нехватке оперативной памяти, уже обработанные команды могут быть выгружены.

Любой интерпретатор работает медленно. Загрузка исходного кода программы с диска в RAM и его выгрузка обходится дорогими простоями процессора. Согласно таблице 1-3, эти простои могут длиться до 10000000 тактов. Кроме того сам интерпретатор — это сложная программа. Для работы она требует часть аппаратных ресурсов компьютера. Получается, что в нагрузку к вашей программе компьютер будет параллельно выполнять и инструкции интерпретатора. Эти накладные расходы приводят к тому, что интерпретация программ — это дорогой вычислительный процесс.

Интерпретация программ обходится дорого, а что насчёт компиляции? Накладные расходы есть и у компилятора. Он генерирует исполняемый файл с машинным кодом. Поэтому скорость выполнения скомпилированного приложения почти такая же, как и написанного изначально на машинном коде. Вы платите за удобство языка программирования на этапе компиляции. Генерация машинного кода для небольшого приложения требует нескольких секунд и незначительных ресурсов компьютера. Но для больших и сложных проектов (например, ядро ОС) это время увеличивается до нескольких часов. Любое изменение исходного кода приведёт к повторной компиляции. Помните про накладные расходы, при выборе языка программирования для вашего проекта. Одни задачи лучше решаются интерпретатором, а другие — компилятором.

Стоит ли вообще использовать языки программирования? Часы ожидания компиляции проекта, можно было бы потратить на разработку программы в машинном коде. Таким образом мы бы избежали лишнего расхода времени и аппаратных ресурсов на работу интерпретатора. Но обратимся к примеру, чтобы оценить преимущества, которые дают языки программирования. Листинг 1-1 демонстрирует исходный код программы на языке C. Она выводит на консоль текст "Hello world!".

{caption: "Листинг 1-1. Исходный код программы на языке C", format: C}
![`HelloWorld.c`](code/GeneralInformation/HelloWorld.c)

В листинге 1-2 приведена та же программа в виде машинного кода в шестнадцатеричном представлении.

{caption: "Листинг 1-2. Машинный код программы"}
![`MachineCode.txt`](code/GeneralInformation/MachineCode.txt)

Очевидно, что код из листинга 1-1 намного проще прочитать, понять и отредактировать. Возможно код из листинга 1-2 и просто написать, но разобраться в нём другому программисту будет очень сложно.

Любой язык программирования удобнее и выразительнее машинного кода. Благодаря этому, написанные на нём программы намного проще разрабатывать и поддерживать.
