# Ответы

## Общая информация

##### Упражнение 1-1. Перевод чисел из BIN в HEX

{line-numbers: false}
```
* 10100110100110 = 0010 1001 1010 0110 = 2 9 A 6 = 29A6

* 1011000111010100010011 = 0010 1100 0111 0101 0001 0011 = 2 C 7 5 1 3 = 2C7513

* 1111101110001001010100110000000110101101 = 1111 1011 1000 1001 0101 0011 0000 0001 1010 1101 = F B 8 9 5 3 0 1 A D = FB895301AD
```

##### Упражнение 1-2. Перевод чисел из HEX в BIN

{line-numbers: false}
```
* FF00AB02 = F F 0 0 A B 0 2 = 1111 1111 0000 0000 1010 1011 0000 0010 = 11111111000000001010101100000010

* 7854AC1 = 7 8 5 4 A C 1 = 0111 1000 0101 0100 1010 1100 0001 = 111100001010100101011000001

* 1E5340ACB38 = 1 E 5 3 4 0 A C B 3 8 = 0001 1110 0101 0011 0100 0000 1010 1100 1011 0011 1000 = 11110010100110100000010101100101100111000
```

## Командный интерпретатор Bash

##### Упражнение 2-1. Шаблоны поиска

Правильный ответ: `README.md`.

Строка `00_README.txt` не подходит. Согласно шаблону `*ME.??`, после точки идут два символа. В строке `00_README.txt` их три.

В строке `README` нет точки. Поэтому она тоже не подходит.

##### Упражнение 2-2. Шаблоны поиска

Шаблону поиска `*/doc?openssl*` соответствуют три строки:

* `/usr/share/doc/openssl/IPAddressChoice_new.html`
* `/usr/share/doc_openssl/IPAddressChoice_new.html`
* `/doc/openssl`

Строка `doc/openssl` не подходит. В ней нет символа / перед `doc`.

##### Упражнение 2-3. Поиск файлов утилитой find

Вот команда для поиска текстовых файлов в системных каталогах:
{line-numbers: false, format: Bash}
```
find /usr -name "*.txt"
```

Текстовые файлы хранятся только в `/usr`. Поэтому нет смысла проверять остальные системные каталоги.

Подсчитаем число строк в найденных файлах. Для этого добавим действие с вызовом утилиты wc:
{line-numbers: false, format: Bash}
```
find /usr -name "*.txt" -exec wc -l {} +
```

Чтобы найти все текстовые файлы на диске, начните поиск с корневого каталога. Например, так:
{line-numbers: false, format: Bash}
```
find / -name "*.txt"
```

Если к этому вызову добавить действие с утилитой wc, произойдёт ошибка. То есть следующая команда не сработает в окружении MSYS2:
{line-numbers: false, format: Bash}
```
find / -name "*.txt" -exec wc -l {} +
```

Проблема связана с ошибкой на иллюстрации 2-17. Текст ошибки передаётся утилите wc. Утилита рассматривает каждое полученное на вход слово как путь до файла. Текст — это не путь. Поэтому wc завершит работу с ошибкой.

##### Упражнение 2-4. Поиск файлов утилитой grep

Ищите информацию о лицензиях приложений в системном каталоге с документацией `/usr/share/doc`.

В документации на приложение с лицензией [GNU General Public License](https://ru.wikipedia.org/wiki/GNU_General_Public_License) встречается строка "General Public License". Найдём такие документы следующей командой:
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/doc
```

Также проверим файлы каталога `/usr/share/licenses`:
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/licenses
```

В окружении MSYS2 есть два дополнительных каталога установки приложений: `/mingw32` и `/mingw64`. Они не соответствуют POSIX-стандарту. Проверим установленные в них программы следующими командами:
{line-numbers: true, format: Bash}
```
grep -Rl "General Public License" /mingw32/share/doc
grep -Rl "General Public License" /mingw64/share
```

Чтобы найти приложения с лицензией MIT, подойдёт строка поиска "MIT license". Для Apache лицензии — строка "Apache license", а для BSD — "BSD license".

##### Упражнение 2-6. Работа с файлами и каталогами

Для начала создайте каталоги для каждого года и месяца. Например, так:
{line-numbers: true, format: Bash}
```
mkdir -p ~/photo/2019/11
mkdir -p ~/photo/2019/12
mkdir -p ~/photo/2020/01
```

Предположим, что фотографии хранятся в каталоге `D:\Photo`. С помощью утилиты find найдём там файлы, созданные в ноябре 2019 года. Чтобы проверить дату создания файла, используйте параметр `-newermt`. Например:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01
```

Эта команда ищет файлы в каталоге `/d/Photo`. Он соответствует пути `D:\Photo` в Windows-окружении.

Первое выражение `-newermt 2019-11-01` означает искать только файлы, изменённые начиная с 1 ноября 2019 года. За ним следует выражение `! -newermt 2019-12-01`. Оно исключает из результата файлы, модифицированные начиная с 1 декабря 2019 года. Восклицательный знак перед выражением — это отрицание. Между выражениями нет условия. Но утилита find подставит логическое И по умолчанию. В результате получится выражение: "файлы, созданные после 1 ноября 2019 года, но не позднее 30 ноября 2019 года". Другими словами — "файлы за ноябрь месяц".

Команда поиска файлов готова. Добавим к ней действие копирования. Получим следующее:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec cp {} ~/photo/2019/11 \;
```

Эта команда скопирует файлы за ноябрь 2019 года в каталог `~/photo/2019/11`.

Вот аналогичные команды для копирования файлов за декабрь и январь:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec cp {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec cp {} ~/photo/2020/01 \;
```

Предположим, что файлы в каталоге `D:\Photo` не нужны. Тогда заменим копирование на переименование. Получим такие команды:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec mv {} ~/photo/2019/11 \;
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec mv {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec mv {} ~/photo/2020/01 \;
```

Обратите внимание на масштабируемость нашего решения. Количество файлов в каталоге `D:\Photo` неважно. Чтобы разбить их на три месяца, нужно три команды.

##### Упражнение 2-7. Конвейеры и перенаправление потоков ввода-вывода

Выясним, как работает утилита bsdtar. Вызовите её с опцией `--help`. На экран выведется справка по опциям и параметрам. Из справки следует, что утилита создаст архив каталога, если передать ей опции `-c` и `-f`. После опций идёт имя архива. Вот пример вызова утилиты:
{line-numbers: false, format: Bash}
```
bsdtar -c -f test.tar test
```

Эта команда создаст архив с именем `test.tar` и содержимым каталога `test`. Обратите внимание, что команда не [сожмёт](https://ru.wikipedia.org/wiki/Сжатие_данных) файлы. То есть архив займёт столько же места на диске, сколько и собранные в него файлы.

Цели операций архивирования и сжатия разные. Архивирование нужно для хранения и копирования большого числа файлов. Сжатие уменьшает объём, занимаемый данными на диске. Часто эти операции совмещают в одну.

Чтобы создать архив и сжать его, добавьте в вызов bsdtar опцию `-j`. Например, так:
{line-numbers: false, format: Bash}
```
bsdtar -c -j -f test.tar.bz2 test
```

Опции `-c`, `-j` и `-f` можно объединить в одну группу. Получится следующее:
{line-numbers: false, format: Bash}
```
bsdtar -cjf test.tar.bz2 test
```

Напишем команду для прохода по каталогу фотографий. Для каждого месяца она создаст отдельный архив.

Следующий вызов утилиты find найдёт каталоги с месяцами:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/*
```

Вывод этой команды перенаправим на вход утилиты xargs. Она сформирует вызов bsdtar. Получится такая команда:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cf %.tar %
```

Чтобы bsdtar сжимала файлы, добавьте опцию `-j`. Получим:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cjf %.tar.bz2 %
```

I> Сжатие длится дольше чем архивация.

Мы передаём параметр `-I` утилите xargs. Он указывает место подстановки аргументов в сформированную команду. В вызове утилиты `bsdtar` таких мест два: имя создаваемого архива и путь до обрабатываемого каталога.

Не забывайте про имена файлов с символами перевода строки. Чтобы обработать их корректно, добавим опцию `-print0` в вызов утилиты find. Получим:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar -cjf %.tar.bz2 %
```

Предположим, что файлы в архивах должны храниться без относительных путей (например `2019/11`). Для удаления путей используйте опцию bsdtar `--strip-components`. Например, так:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar --strip-components=3 -cjf %.tar.bz2 %
```

##### Упражнение 2-8. Логические операторы

Реализуем алгоритм по шагам. Первое действие — копирование файла `README` в домашний каталог пользователя. Это делает следующая команда:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~
```

С помощью оператора && и echo выведем результат команды в лог-файл. Получим:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log
```

Для архивации файла вызовем утилиту bsdtar или tar. Например, так:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README
```

Результат утилиты выведем в лог-файл с помощью оператора && и echo:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Теперь команда echo дописывает строку в конец существующего лог-файла.

Объединим вызовы утилит cp и bsdtar в одну команду. Утилита bsdtar вызывается только после успешного копирования файла `README`. Чтобы добиться такой зависимости, поставим между командами оператор &&. Получим:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Добавим последнее действие — удаление файла `README`:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log && rm ~/README && echo "rm - OK" >> ~/result.log
```

Запустите эту команду. Если она выполнится без ошибок, в лог-файл запишется следующее:
{line-numbers: true}
```
cp - OK
bsdtar - OK
rm - OK
```

Команда с вызовами трёх утилит подряд выглядит громоздко. Её неудобно читать и редактировать. Разобьём команду на строки. Для этого есть несколько способов.

Способ первый — перенос строк после логических операторов. Применим его и получим следующее:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log &&
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log &&
rm ~/README && echo "rm - OK" >> ~/result.log
```

Попробуйте скопировать эту команду в окно терминала и исполнить. Она выполнится без ошибок.

Второй способ разбить команду на строки — использовать символ обратный слэш \. Сразу после него поставьте перенос строки. Применяйте этот способ, когда в команде нет логических операторов.

Для примера поставим обратные слэши перед операторами && в нашей команде. Получим:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log \
&& bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log \
&& rm ~/README && echo "rm - OK" >> ~/result.log
```

## Разработка Bash-скриптов

##### Упражнение 3-2. Полная форма подстановки параметров

Утилита find рекурсивно ищет файлы, начиная с указанного пути. Используйте параметр `-maxdepth`, чтобы исключить из поиска подкаталоги.

Команда поиска TXT файлов в текущем каталоге выглядит так:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt"
```

Добавим действие для копирования найденных файлов в домашний каталог пользователя. Получим:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec cp -t ~ {} \;
```

Создайте скрипт с именем `txt-copy.sh`. Скопируйте в него команду поиска.

В скрипт будем передавать параметр. В зависимости от него, выбирается действие: копирование или переименование. В качестве параметра удобнее передать имя утилиты: cp или mv. Скрипт вызовет утилиту по имени для каждого файла, найденного find.

Рассмотрим интерфейс скрипта `txt-copy.sh`. Копирование выполняется следующей командой:
{line-numbers: false, format: Bash}
```
./txt-copy.sh cp
```

Команда для переименования файлов такая:
{line-numbers: false, format: Bash}
```
./txt-copy.sh mv
```

Первый параметр скрипта сохраняется в переменной `$1`. Подставим её в вызов утилиты find. Получится следующее:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec "$1" -t ~ {} \;
```

Если действие не указано, скрипт должен копировать файлы. То есть допустим такой вызов:
{line-numbers: false, format: Bash}
```
./txt-copy.sh
```

Чтобы это сработало, добавим в подстановку параметра `$1` значение по умолчанию. Получим скрипт `find-txt.sh` из листинга 5-1.

{caption: "Листинг 5-1. Скрипт для поиска TXT-файлов", line-numbers: true, format: Bash}
![`find-txt.sh`](code/Answers/find-txt.sh)

##### Упражнение 3-4. Оператор if

Исходная команда выглядит так:
{line-numbers: false, format: Bash}
```
( grep -RlZ "123" target | xargs -0 cp -t . && echo "cp - OK" || ! echo "cp - FAILS" ) && ( grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS" )
```

Обратите внимание на отрицание вызова echo "cp - FAILS". Из-за него утилита grep вызовется второй раз только, если первый вызов выполнился успешно.

Заменим логический оператор && между вызовами grep на конструкцию if-else. Получится следующее:
{line-numbers: true, format: Bash}
```
if grep -RlZ "123" target | xargs -0 cp -t .
then
  echo "cp - OK"
  grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS"
else
  echo "cp - FAILS"
fi
```

Теперь заменим операторы || во втором вызове grep на if-else. Получим:
{line-numbers: true, format: Bash}
```
if grep -RlZ "123" target | xargs -0 cp -t .
then
  echo "cp - OK"
  if grep -RLZ "123" target | xargs -0 rm
  then
    echo "rm - OK"
  else
    echo "rm - FAILS"
  fi
else
  echo "cp - FAILS"
fi
```

Чтобы избежать вложенных конструкций if-else, применим технику раннего возврата. Также добавим в начале скрипта шебанг. Листинг 5-2 демонстрирует результат.

{caption: "Листинг 5-2. Скрипт для поиска стоки в файлах", line-numbers: true, format: Bash}
![`search-copy-remove.sh`](code/Answers/search-copy-remove.sh)

##### Упражнение 3-5. Оператор [[

Сравним содержимое двух каталогов. Результатом сравнения будет список файлов, которыми они различаются.

Для начала надо пройти по всем файлам каждого каталога. Применим утилиту find. Поиск файлов в каталоге `dir1` выглядит так:
{line-numbers: false, format: Bash}
```
find dir1 -type f
```

Вот пример вывода этой команды:
{line-numbers: false}
```
dir1/test3.txt
dir1/test1.txt
dir1/test2.txt
```

Мы получили список файлов в каталоге `dir1`. Проверим, что каждый из них есть в каталоге `dir2`. Для этого добавим действие `-exec` в вызов find.

Есть одна проблема. Утилита find добавляет имя каталога `dir1` к каждому найденному файлу. Чтобы исключить `dir1` в списке файлов, перейдём в этот каталог перед запуском find. Получим такие команды:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f
```

Теперь вывод find выглядит так:
{line-numbers: false}
```
./test3.txt
./test1.txt
./test2.txt
```

С помощью действия `-exec` и команды test проверим, что каждый найденный файл есть в каталоге `dir2`. Получим:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test -e ../dir2/{} \;
```

Здесь мы используем команду test вместо оператора [[. Дело в том, что встроенный интерпретатор find не способен обработать этот оператор корректно. Это одно из исключений, когда [[ надо заменить на test. В общем случае предпочитайте оператор [[.

Если файла не оказалось в каталоге `dir2`, выведем его имя на экран. Для этого инвертируем проверку test и добавим второе действие `-exec` с выводом echo. Между действиями поставим логический оператор И. В результате получим следующие команды:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;
```

Добавим аналогичный вызов find для проверки файлов каталога `dir2` в каталоге `dir1`.

Листинг 5-3 демонстрирует полный скрипт `dir-diff.sh` для сравнения каталогов.

{caption: "Листинг 5-3. Скрипт для сравнения каталогов", line-numbers: true, format: Bash}
![`dir-diff.sh`](code/Answers/dir-diff.sh)

I> Мы написали скрипт сравнения каталогов для учебных целей. Не используйте его для реальных задач. Предпочитайте специальную GNU-утилиту diff.

##### Упражнение 3-6. Оператор case

Скрипт переключения между конфигурационными файлами будет создавать [**символьные ссылки**](https://ru.wikipedia.org/wiki/Символическая_ссылка). Символьная ссылка — это файл специального типа. Вместо данных он содержит указатель на другой файл или каталог.

I> В Unix-окружении, запущенном на OS Windows, создать символьную ссылку нельзя. Вместо этого утилита ln копирует файл или каталог, соответствующий ссылке. На ОС Linux и macOS утилита работает правильно.

Символьные ссылки удобны, когда нужен доступ к файлу или каталогу из разных мест файловой системы. Открыв ссылку на файл, вы редактируете файл, на который она указывает. Так же работает ссылка на каталог. Любые изменения отразятся на целевом каталоге.

Напишем алгоритм скрипта переключения между файлами конфигурации. Он выглядит так:

1. Удалить существующую символьную ссылку или файл по пути `~/.bashrc`.

2. Проверить опцию командной строки, переданную в скрипт.

3. В зависимости от опции создать символьную ссылку на файл `.bashrc-home` или `.bashrc-work`.

Реализуем этот алгоритм с помощью оператора case. Листинг 5-4 демонстрирует результат.

{caption: "Листинг 5-4. Скрипт для переключения конфигурационных файлов", line-numbers: true, format: Bash}
![`switch-config-case.sh`](code/Answers/switch-config-case.sh)

Конфигурационный файл выбираем в зависимости от переданного в скрипт параметра `$1`.

Команды вызова утилиты ln отличаются только именем файла. Такое подобие подсказывает, что оператор case можно заменить на ассоциативный массив. Тогда получится скрипт, похожий на листинг 5-5.

{caption: "Листинг 5-5. Скрипт для переключения конфигурационных файлов", line-numbers: true, format: Bash}
![`switch-config-array.sh`](code/Answers/switch-config-array.sh)

Рассмотрим последнюю строку скрипта. Двойные кавычки при подстановке элемента массива здесь не обязательны. Но они предотвратят ошибку, если в будущем появится имя конфигурационного файла с пробелами.

##### Упражнение 3-7. Арифметические действия в дополнительном коде

Результаты сложения однобайтовых целых:
{line-numbers: false}
```
* 79 + (-46) = 0100 1111 + 1101 0010 = 1 0010 0001 -> 0010 0000 = 33

* -97 + 96 = 1001 1111 + 0110 0000 = 1111 1111 -> 1111 1110 -> 1000 0001 = -1
```

Результат сложения двухбайтовых целых:
{line-numbers: false}
```
* 12868 + (-1219) = 0011 0010 0100 0100 + 1111 1011 0011 1101 = 1 0010 1101 1000 0001 -> 0010 1101 1000 0001 = 11649
```

Чтобы проверить правильность перевода чисел в дополнительный код, используйте [онлайн-калькулятор](https://planetcalc.com/747/)

##### Упражнение 3-8. Modulo и остаток от деления

{line-numbers: false}
```
* 1697 % 13
q = 1697 / 13 ~ 130.5385 ~ 130
r = 1697 - 13 * 130 = 7

* 1697 modulo 13
q = 1697 / 13 ~ 130.5385 ~ 130
r = 1697 - 13 * 130 = 7

* 772 % -45
q = 772 / -45 ~ -17.15556 ~ -17
r = 772 - (-45) * (-17) = 7

* 772 modulo -45
q = (772 / -45) - 1 ~ -18.15556 ~ -18
r = 772 - (-45) * (-18) = -38

* -568 % 12
q = -568 / 12 ~ -47.33333 ~ -47
r = -568 - 12 * (-47) = -4

* -568 modulo 12
q = (-568 / 12) - 1 ~ -48.33333 ~ -48
r = -568 - 12 * (-48) = 8

* -5437 % -17
q = -5437 / -17 ~ 319.8235 ~ 319
r = -5437 - (-17) * 319 = -14

* -5437 modulo -17
q = -5437 / -17 ~ 319.8235 ~ 319
r = -5437 - (-17) * 319 = -14
```

##### Упражнение 3-9. Побитовое отрицание

Сначала вычислим побитовое отрицание для беззнаковых двухбайтовых целых.
{line-numbers: false}
```
 56 = 0000 0000 0011 1000
~56 = 1111 1111 1100 0111 = 65479

 1018 = 0000 0011 1111 1010
~1018 = 1111 1100 0000 0101 = 64517

 58362 = 1110 0011 1111 1010
~58362 = 0001 1100 0000 0101 = 7173
```

Если операция отрицания выполняется над знаковыми двухбайтовыми целыми, результаты отличаются:
{line-numbers: false}
```
 56 = 0000 0000 0011 1000
~56 = 1111 1111 1100 0111 -> 1000 0000 0011 1001 = -57

 1018 = 0000 0011 1111 1010
~1018 = 1111 1100 0000 0101 -> 1000 0011 1111 1011 = -1019
```

Число 58362 нельзя представить как знаковое двухбайтовое целое. Причина в переполнении. Если записать биты числа в переменную такого типа, получим -7174. Перевод этого числа в дополнительный код выглядит так:
{line-numbers: false}
```
58362 = 1110 0011 1111 1010 -> 1001 1100 0000 0110 = -7174
```

Теперь выполним побитовое отрицание:
{line-numbers: false}
```
  -7174  = 1110 0011 1111 1010
~(-7174) = 0001 1100 0000 0101 = 7173
```

Проверим результаты для знаковых целых с помощью Bash-команд:
{line-numbers: true, format: Bash}
```
$ echo $((~56))
-57
$ echo $((~1018))
-1019
$ echo $((~(-7174)))
7173
```

Проверить отрицание двухбайтового беззнакого целого 58362 с помощью Bash нельзя. Интерпретатор сохранит число в знаковом четырёхбайтовом целом. Тогда результат отрицания будет такой:
{line-numbers: true, format: Bash}
```
$ echo $((~58362))
-58363
```

##### Упражнение 3-10. Побитовые И, ИЛИ, исключающее ИЛИ

Вычислим битовые операции для беззнаковых двухбайтовый целых:
{line-numbers: false}
```
1122 & 908 = 0000 0100 0110 0010 & 0000 0011 1000 1100 = 0000 0000 000 0000 = 0

1122 | 908 = 0000 0100 0110 0010 | 0000 0011 1000 1100 = 0000 0111 1110 1110 = 2030

1122 ^ 908 = 0000 0100 0110 0010 ^ 0000 0011 1000 1100 = 0000 0111 1110 1110 = 2030


49608 & 33036 = 1100 0001 1100 1000 & 1000 0001 0000 1100 = 1000 0001 0000 1000 = 33032

49608 | 33036 = 1100 0001 1100 1000 | 1000 0001 0000 1100 = 1100 0001 1100 1100 = 49612

49608 ^ 33036 = 1100 0001 1100 1000 ^ 1000 0001 0000 1100 = 0100 0000 1100 0100 = 16580
```

Если целые знаковые, результаты битовых операций для первой пары чисел 1122 и 908 такие же. Для второй пары, вычисление отличается. Рассмотрим его.

Сначала получим значение чисел 49608 и 33036 в дополнительном коде:
{line-numbers: false}
```
49608 = 1100 0001 1100 1000 -> 1011 1110 0011 1000 = -15928

33036 = 1000 0001 0000 1100 -> 1111 1110 1111 0100 = -32500
```

Теперь выполним битовые операции:
{line-numbers: false}
```
-15928 & -32500 = 1100 0001 1100 1000 & 1000 0001 0000 1100 = 1000 0001 0000 1000 -> 1111 1110 1111 1000 = -32504

-15928 | -32500 = 1100 0001 1100 1000 | 1000 0001 0000 1100 = 1100 0001 1100 1100 -> 1011 1110 0011 0100 = -15924

-15928 ^ -32500 = 1100 0001 1100 1000 ^ 1000 0001 0000 1100 = 0100 0000 1100 0100 = 16580
```

Вот Bash-команды для проверки результатов:
{line-numbers: true, format: Bash}
```
$ echo $((1122 & 908))
0
$ echo $((1122 | 908))
2030
$ echo $((1122 ^ 908))
2030

$ echo $((49608 & 33036))
33032
$ echo $((49608 | 33036))
49612
$ echo $((49608 ^ 33036))
16580

$ echo $((-15928 & -32500))
-32504
$ echo $((-15928 | -32500))
-15924
$ echo $((-15928 ^ -32500))
16580
```

##### Упражнение 3-11. Битовые сдвиги

Вычисление битовых сдвигов:
{line-numbers: false}
```
* 25649 >> 3 = 0110 0100 0011 0001 >> 3 = 0110 0100 0011 0 = 0000 1100 1000 0110 = 3206

* 25649 << 2 = 0110 0100 0011 0001 << 2 = 10 0100 0011 0001 -> 1001 0000 1100 0100 -> 1110 1111 0011 1100 = -28476

* -9154 >> 4 = 1101 1100 0011 1110 >> 4 = 1101 1100 0011 -> 1111 1101 1100 0011 -> 1000 0010 0011 1101 = -573

* -9154 << 3 = 1101 1100 0011 1110 << 3 = 1 1100 0011 1110 -> 1110 0001 1111 0000 -> 1001 1110 0001 0000 = -7696
```

Bash-команды для проверки результатов:
{line-numbers: true, format: Bash}
```
$ echo $((25649 >> 3))
3206
$ echo $((25649 << 2))
102596
$ echo $((-9154 >> 4))
-573
$ echo $((-9154 << 3))
-73232
```

Результаты Bash-команд отличаются для второго и четвертого сдвига. Причина в том, что Bash хранит все числа в восьми батах.

Проверьте свои расчёты с помощью [онлайн-калькулятора](https://onlinetoolz.net/bitshift).

##### Упражнение 3-12. Операторы цикла

Чтобы отгадать число, игроку даётся семь попыток. Каждая попытка обрабатывается по одному и тому же алгоритму. Поместим его в цикл for.

Алгоритм обработки действия игрока следующий:

1. Прочитать ввод с помощью команды read.

2. Сравнить введённое число с загаданным.

3. Если игрок ошибся, вывести подсказку и перейти к шагу 1.

4. Если игрок угадал число, завершить работу скрипта.

Чтобы загадать случайное число, обратимся к зарезервированной переменной `RANDOM`. При чтении она возвращает случайное значение от 0 до 32767. Нам нужно число от 1 до 100. Получим его из `RANDOM` по такому алгоритму:

1. Получим случайное число от 0 до 99. Для этого вычислим остаток от деления `RANDOM` на 100 по формуле:
{line-numbers: false, format: Bash}
```
number=$((RANDOM % 100))
```

2. Получим число в диапазоне от 1 до 100. Для этого прибавим единицу к предыдущему результату.

Полная формула вычисления случайного числа от 1 до 100 выглядит так:
{line-numbers: false, format: Bash}
```
number=$((RANDOM % 100 + 1))
```

Листинг 5-6 демонстрирует скрипт, выполняющий алгоритм игры.

{caption: "Листинг 5-6. Скрипт игры Больше-Меньше", line-numbers: true, format: Bash}
![`more-less-game.sh`](code/Answers/more-less-game.sh)

Чтобы отгадать число за семь попыток, примените [**двоичный поиск**](https://ru.wikipedia.org/wiki/Двоичный_поиск). Его идея в разделении массива чисел на половины. Рассмотрим пример игры "Больше-Меньше" и двоичного поиска.

Как только игра началась мы отгадываем число в диапазоне от 1 до 100. Середина этого диапазона — число 50. Введите это значение первым. Программа даст подсказку, в какой половине диапазона находится загаданное число. Предположим, программа ответила, что 50 меньше искомого числа. Это означает, что искать надо в диапазоне от 50 до 100. Введём середину этого диапазона, то есть число 75. Получаем ответ, что 75 тоже меньше искомого. Вывод — искомое число находится между 75 и 100. Середина этого диапазона X рассчитывается так:
{line-numbers: false, format: text}
```
X = 75 + (100 - 75) / 2 = 87.5
```

Округлите результат в большую или меньшую сторону. Это неважно. Округлим в меньшую и получим число 87 для следующего ввода. Если число до сих пор не отгадано, продолжайте делить диапазон предполагаемых чисел пополам. Тогда вам хватит семь шагов, чтобы найти загаданное число.

##### Упражнение 3-13. Функции

Мы рассмотрели вариант функции `code_to_error` в примерах раздела "Функции в скриптах".

Объединим код функций `print_error` и `code_to_error` в один файл. Получим скрипт из листинга 5-7.

{caption: "Листинг 5-7. Скрипт для вывода сообщений об ошибках", line-numbers: true, format: Bash}
![`print-error.sh`](code/Answers/print-error.sh)

Сейчас функция `code_to_error` выводит сообщения на русском языке. Переименуем её на `code_to_error_ru`. Тогда язык сообщений станет понятен из имени функции.

Добавим в скрипт функцию `code_to_error_en`. Она печатает текст на английском языке для переданного в неё кода ошибки. Код функции выглядит так:
{line-numbers: true, format: Bash}
```
code_to_error_en()
{
  case $1 in
    1)
      echo "File not found:"
      ;;
    2)
      echo "Permission to read the file denied:"
      ;;
  esac
}
```

Теперь надо выбрать, какую функцию `code_to_error` вызывать из `print_error`. Проверим региональные настройки в переменной окружения `LANG`. Если значение переменной соответствует шаблону "ru_RU*", вызовем функцию `code_to_error_ru`. В противном случае вызовем `code_to_error_en`.

Полный код скрипта приведён в листинге 5-8.

{caption: "Листинг 5-8. Скрипт для вывода сообщений об ошибках", line-numbers: true, format: Bash}
![`print-error-local.sh`](code/Answers/print-error-local.sh)

Оператор if в функции `print_error` можно заменить на case. Например, так:
{line-numbers: true, format: Bash}
```
print_error()
{
  case $LANG in
    ru_RU*)
      echo "$(code_to_error_ru $1) $2" >> debug.log
      ;;
    en_US*)
      echo "$(code_to_error_en $1) $2" >> debug.log
      ;;
    *)
      echo "$(code_to_error_en $1) $2" >> debug.log
      ;;
  esac
}
```

Вариант с case удобнее, если надо поддерживать более двух языков.

Сейчас в функции `print_error` код дублируется. В каждом блоке оператора case вызывается одинаковая команда echo. Единственное различие между блоками — имя функции для конвертирования кода ошибки в текст. Чтобы избежать дублирования, сохраним имя функции в переменной `func`. Затем подставим эту переменную в вызов echo. Получится следующее:
{line-numbers: true, format: Bash}
```
print_error()
{
  case $LANG in
    ru_RU)
      local func="code_to_error_ru"
      ;;
    en_US)
      local func="code_to_error_en"
      ;;
    *)
      local func="code_to_error_en"
      ;;
  esac

  echo "$($func $1) $2" >> debug.log
}
```

Альтернативное решение проблемы дублирования кода — использовать индексируемый массив. Заменим операторы case в функциях `code_to_error_ru` и `code_to_error_en` на массивы. Например, так:
{line-numbers: true, format: Bash}
```
code_to_error_ru()
{
  declare -a messages

  messages[1]="Не найден файл"
  messages[2]="Нет прав для чтения файла"

  echo "${messages[$1]}"
}

code_to_error_en()
{
  declare -a messages

  messages[1]="The following file was not found:"
  messages[2]="You do not have permissions to read the following file:"

  echo "${messages[$1]}"
}
```

Можно упростить код и обойтись без функций `code_to_error`. Объединим сообщения на всех языках в один ассоциативный массив. Поместим его в функцию `print_error`. Ключами массива будут комбинации значения переменной `LANGUAGE` и кода ошибки. Получим такую функцию `print_error` как в листинге 5-9.

{caption: "Листинг 5-9. Скрипт для вывода сообщений об ошибках", line-numbers: true, format: Bash}
![`print-error-array.sh`](code/Answers/print-error-array.sh)

##### Упражнение 3-14. Область видимости переменных

Скрипт из листинга 3-37 выведет на консоль следующий текст:
{line-numbers: true, format: text}
```
main1: var =
foo1: var = foo_value
bar1: var = foo_value
bar2: var = bar_value
foo2: var = bar_value
main2: var =
```

Начнём с вывода "main1" и "main2". Переменная `var` объявлена в функции `foo` как локальная. Поэтому она доступна только в `foo` и в вызываемой из неё функции `bar`. Следовательно, до и после вызова `foo` переменная `var`считается необъявленной.

В выводе "foo1" напечаталось значение `foo_value`. Оно было присвоено переменной только что.

Далее идёт вывод "bar1". Переменная `var` объявлена в функции `foo`, а `bar` вызывается из неё. Поэтому тело функции `bar` тоже является областью видимости `var`.

Затем мы присваиваем `var` новое значение `bar_value`. Обратите внимание, что мы не объявляем новую глобальную переменной с именем `var`. Мы перезаписываем уже существующую локальную переменную. Её значение `bar_value` мы получим в выводах "bar2" и "foo2".
