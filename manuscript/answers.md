# Ответы

## Общая информация

##### Упражнение 1-1. Перевод чисел из BIN в HEX

{line-numbers: false}
```
* 10100110100110 = 0010 1001 1010 0110 = 2 9 A 6 = 29A6

* 1011000111010100010011 = 0010 1100 0111 0101 0001 0011 = 2 C 7 5 1 3 = 2C7513

* 1111101110001001010100110000000110101101 = 1111 1011 1000 1001 0101 0011 0000 0001 1010 1101 = F B 8 9 5 3 0 1 A D = FB895301AD
```

##### Упражнение 1-2. Перевод чисел из HEX в BIN

{line-numbers: false}
```
* FF00AB02 = F F 0 0 A B 0 2 = 1111 1111 0000 0000 1010 1011 0000 0010 = 11111111000000001010101100000010

* 7854AC1 = 7 8 5 4 A C 1 = 0111 1000 0101 0100 1010 1100 0001 = 111100001010100101011000001

* 1E5340ACB38 = 1 E 5 3 4 0 A C B 3 8 = 0001 1110 0101 0011 0100 0000 1010 1100 1011 0011 1000 = 11110010100110100000010101100101100111000
```

## Командный интерпретатор Bash

##### Упражнение 2-1. Шаблоны поиска

{line-numbers: false}
```
* README.md
```

Строка `00_README.txt` не подходит, потому что шаблон `*ME.??` ожидает два символа после точки. В варианте `README` вообще нет точки, и он тоже не подходит.

##### Упражнение 2-2. Шаблоны поиска

Шаблону поиска удовлетворяют три строки:

* `/usr/share/doc/openssl/IPAddressChoice_new.html`
* `/usr/share/doc_openssl/IPAddressChoice_new.html`
* `/doc/openssl`

Строка `doc/openssl` не соответствует шаблону `*/doc?openssl*`, потому что в ней нет символа `/` перед `doc`.

##### Упражнение 2-3. Использование команды find

Правильный ответ следующий:
{line-numbers: false, format: Bash}
```
find /usr -name "*.txt" -exec wc -l {} +
```

Чтобы найти все TXT файлы, подойдёт также команда:
{line-numbers: false, format: Bash}
```
find / -name "*.txt"
```

Но если вы попробуйте расширить её действием `wc -l`, никакого вывода не будет:
{line-numbers: false, format: Bash}
```
find / -name "*.txt" -exec wc -l {} +
```

Помните сообщение об ошибке, которое выводится при запуске `find` в корневом каталоге? Текст этого сообщения будет передаваться в команду `wc`. Дальше команда будет интерпретировать каждое слово в качестве пути до файла. Очевидно, что эти пути окажутся недействительными и `wc` завершится с ошибкой. Чтобы её избежать, запускать `find` надо в каталоге `/usr`. Все TXT файлы находятся в нём и будут найдены командой.

##### Упражнение 2-4. Использование команды grep

Информацию о лицензии приложений логично искать в системном каталоге с документацией `/usr/share/doc`.

Для поиска приложений с лицензией [GNU General Public License](https://ru.wikipedia.org/wiki/GNU_General_Public_License) воспользуемся строкой "General Public License":
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/doc
```

Также имеет смысл поискать в каталоге `/usr/share/licenses`:
{line-numbers: false, format: Bash}
```
grep -Rl "General Public License" /usr/share/licenses
```

В окружении MSYS2 есть два неспецифичных для Unix каталога установки `/mingw32` и `/mingw64`. Можно проверить и установленные в них программы:
{line-numbers: true, format: Bash}
```
grep -Rl "General Public License" /mingw32/share/doc
grep -Rl "General Public License" /mingw64/share
```

В случае лицензии MIT можно искать строку "MIT license" в тех же каталогах. Для Apache лицензии подойдёт строка "Apache license", а для BSD - "BSD license".

##### Упражнение 2-6. Использование утилит для работы с файлами и каталогами

Прежде всего создадим каталоги, куда будем копировать фотографии:
{line-numbers: true, format: Bash}
```
mkdir -p ~/photo/2019/11
mkdir -p ~/photo/2019/12
mkdir -p ~/photo/2020/01
```

Предположим, что все ваши фотографии хранятся в каталоге `D:\Photo`. У него могут быть подкаталоги, но для нашего упражнения это несущественно. С помощью команды `find` найдём все файлы, созданные в ноябре 2019 года. Для этого воспользуемся параметром `-newermt`:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01
```

Эта команда ищет файлы в каталоге `/d/Photo`, который соответствует пути `D:\Photo` в Windows окружении.

Первое выражение `-newermt 2019-11-01` означает выбрать все файлы, модифицированные начиная с 1 ноября 2019 года. Далее идёт выражение `! -newermt 2019-12-01`. Как вы помните, восклицательный знак означает отрицание. По аналогии с предыдущим выражением, `-newermt 2019-12-01` означает все файлы, модифицированные начиная с 1 декабря 2019 года. Между этими выражениями нет условия. В этом случае используется логическое И. В результате получится высказывание: файлы, созданные после 1 ноября 2019 года, но не позднее 30 ноября 2019 года. Другими словами: файлы за ноябрь месяц.

Теперь к нашей команде `find` добавим действие копирования файлов:
{line-numbers: false, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec cp {} ~/photo/2019/11 \;
```

В результате в каталог `~/photo/2019/11` будут скопированы файлы за ноябрь 2019 года. Выполним аналогичные команды для копирования фотографий за декабрь и январь:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec cp {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec cp {} ~/photo/2020/01 \;
```

Вы можете заменить команду копирования на переименование, если файлы в каталоге `D:\Photo` вам больше не нужны:
{line-numbers: true, format: Bash}
```
find /d/Photo -type f -newermt 2019-11-01 ! -newermt 2019-12-01 -exec mv {} ~/photo/2019/11 \;
find /d/Photo -type f -newermt 2019-12-01 ! -newermt 2020-01-01 -exec mv {} ~/photo/2019/12 \;
find /d/Photo -type f -newermt 2020-01-01 ! -newermt 2020-02-01 -exec mv {} ~/photo/2020/01 \;
```

Обратите внимание на масштабируемость такого решения. Независимо от количества файлов в каталоге `D:\Photo` для разделения их по месяцам, нужно всего три команды.

##### Упражнение 2-7. Использование конвейеров и перенаправления потоков ввода-вывода

Прежде всего разберёмся, как работает утилита `bsdtar`. Согласно её выводу `--help`, для создания [**архива**](https://ru.wikipedia.org/wiki/Архив_(информатика)) каталога необходимо передать опции `-c` и `-f`, а также имя архива. Например:
{line-numbers: false, format: Bash}
```
bsdtar -c -f test.tar test
```

Эта команда создаст архив с именем `test.tar`, в который поместит всё содержимое каталога `test`. Обратите внимание, что [сжатия](https://ru.wikipedia.org/wiki/Сжатие_данных) в результате этой команды не произойдёт. То есть архив будет занимать почти столько же места на диске, сколько и собранные в него файлы. Цели операций архивирования и сжатия различны. Первая нужна для удобства хранения и переноса большого числа файлов. Сжатие позволяет уменьшить объём, занимаемый данными на диске. Часто эти операции совмещают в одну.

Если вы хотите сжать полученный архив, добавьте опцию `-j`:
{line-numbers: false, format: Bash}
```
bsdtar -c -j -f test.tar.bz2 test
```

Обратите внимание, что все опции `-c`, `-j` и `-f` можно записать без пробелов:
{line-numbers: false, format: Bash}
```
bsdtar -cjf test.tar.bz2 test
```

Мы разобрались, как использовать `bsdtar`. Теперь пришло время написать команду для прохода по каталогу фотографий и созданию архива для каждого месяца. Чтобы найти все каталоги с месяцами, воспользуемся командой `find`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/*
```

Теперь перенаправим её вывод утилите `xargs`, которая сформирует вызов `bsdtar`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cf %.tar %
```

Если необходимо сжатие, добавьте опцию `-j` в вызов `bsdtar`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* | xargs -I% bsdtar -cjf %.tar.bz2 %
```

I> Учтите, что сжатие — это значительно более долгая операция чем архивация.

В данном случае мы воспользовались параметром `-I` команды `xargs`, чтобы указать место подстановки сформированных ею аргументов. В случае вызова утилиты `bsdtar` этих мест два: имя создаваемого архива и путь до каталога, который следует обработать.

Не забывайте про имена файлов, которые могут содержать символы перевода строки. Чтобы обработать их корректно, добавим опцию `-print0` в вызов утилиты `find`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar -cjf %.tar.bz2 %
```

Если вы хотите, чтобы архивы содержали только файлы без относительных путей (например `2019/11`), воспользуйтесь опцией `--strip-components` утилиты `bsdtar`:
{line-numbers: false, format: Bash}
```
find ~/photo -type d -path */2019/* -o -path */2020/* -print0 | xargs -0 -I% bsdtar --strip-components=3 -cjf %.tar.bz2 %
```

##### Упражнение 2-8. Использование логических операторов

Будем реализовывать наш алгоритм последовательно шаг за шагом. Первое действие — копирование файла README в домашний каталог пользователя:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~
```

Чтобы вывести результат этой команды в лог-файл, воспользуемся оператором `&&` и `echo`:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log
```

Далее необходимо заархивировать скопированный файл. Для этого воспользуемся утилитой `bsdtar` или `tar`:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README
```

Выведем её результат аналогично с использованием оператора `&&` и команды `echo`:
{line-numbers: false, format: Bash}
```
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Обратите внимание, что в данном случае `echo` дописывает в конец уже существующего лог-файла.

Как объединить получившиеся вызовы `cp` и `bsdtar`? Утилита `bsdtar` должна отработать только в случае успешного выполнения копирования. Значит, надо опять воспользоваться оператором `&&`. В результате получим следующую команду:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> result.log
```

Добавим к ней последнее действие — удаление файла `README`:
{line-numbers: false, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log && bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log && rm ~/README && echo "rm - OK" >> ~/result.log
```

Если вы запустите эту команду и все действия выполнятся корректно, вы получите следующий вывод в файле `result.txt`:
{line-numbers: true}
```
cp - OK
bsdtar - OK
rm - OK
```

Согласитесь, что читать получившуюся команду неудобно. Её можно разбить на несколько строк несколькими способами. Bash разрешает перенос строки сразу после логических операторов:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log &&
bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log &&
rm ~/README && echo "rm - OK" >> ~/result.log
```

Попробуйте скопировать эту команду в окно терминала и исполнить. Она должна отработать без ошибок.

Если в вашей команде нет логических операторов, вы можете воспользоваться символом обратный слэш `\`. В нашем случае для примера поставим его перед `&&`:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/README ~ && echo "cp - OK" > ~/result.log \
&& bsdtar -cjf ~/README.tar.bz2 ~/README && echo "bsdtar - OK" >> ~/result.log \
&& rm ~/README && echo "rm - OK" >> ~/result.log
```

Обратный слэш вы можете вставлять в любое место команды. Важно, чтобы сразу после него шёл перевод строки.

## Разработка Bash скриптов

##### Упражнение 3-2. Использование полной формы подстановки параметров

Чтобы ограничить утилиту `find` поиском только в текущем каталоге, воспользуемся параметром `-maxdepth`. Тогда команда поиска файлов с расширением TXT будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt"
```

Добавим в неё действие копирования найденных файлов в домашний каталог пользователя:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec cp -t ~ {} \;
```

Поместим команду в скрипт с именем `txt-copy.sh`. Тогда мы сможем вызвать скрипт и передать ему желаемое действие: копирование или переименование. Проще всего будет передавать имя утилиты (`cp` или `mv`), которую следует вызвать для каждого найденного файла. В таком случае следующая команда будет выполнять копирование:
{line-numbers: false, format: Bash}
```
./txt-copy.sh cp
```

Для перемещения найденных файлов достаточно заменить `cp` на `mv`:
{line-numbers: false, format: Bash}
```
./txt-copy.sh mv
```

Первый параметр, переданный скрипту, сохраняется в перменной `$1`. Подставим её в наш вызов `find`:
{line-numbers: false, format: Bash}
```
find . -maxdepth 1 -type f -name "*.txt" -exec "$1" -t ~ {} \;
```

Теперь зададим значение по умолчанию. Благодаря этому, будет выполняться копирование, если позиционный параметр `$1` пустой. В итоге наш скрипт будет выглядеть так:
{line-numbers: true, format: Bash}
```
#!/bin/bash
find . -maxdepth 1 -type f -name "*.txt" -exec "${1:-cp}" -t ~ {} \;
```

##### Упражнение 3-4. Использование оператора if

Исходная команда выглядит следующих образом:
{line-numbers: false, format: Bash}
```
( grep -RlZ "123" target | xargs -0 cp -t . && echo "cp - OK" || ! echo "cp - FAILS" ) && ( grep -RLZ "123" target | xargs -0 rm && echo "rm - OK" || echo "rm - FAILS" )
```

Обратите внимание на отрицание вывода "cp - FAILS". Если бы не оно, мы могли бы разбить команду на два отдельных вызова. Но в данном случае выполнение прервётся, если первый `grep` не найдёт ни одного файла и команда `cp` не сможет отработать корректно. Поэтому, нам нужен вложенный `if-else` следующего вида:
{line-numbers: true, format: Bash}
```
if grep -RlZ "123" target | xargs -0 cp -t .
then
  echo "cp - OK"
  if grep -RLZ "123" target | xargs -0 rm
  then
    echo "rm - OK"
  else
    echo "rm - FAILS"
  fi
else
  echo "cp - FAILS"
fi
```

Если применить технику раннего возврата, мы получим следующее:
{line-numbers: true, format: Bash}
```
if ! grep -RlZ "123" target | xargs -0 cp -t .
then
  echo "cp - FAILS"
  exit 1
fi

echo "cp - OK"

if grep -RLZ "123" target | xargs -0 rm
then
  echo "rm - OK"
else
  echo "rm - FAILS"
fi
```

Благодаря отрицанию `!` результата работы первого `grep` и следующего далее в конвейере `cp`, мы можем завершить скрипт сразу же после ошибки.

##### Упражнение 3-5. Использование оператора `[[`

Чтобы вывести файлы, которыми отличаются два каталога, их сначала нужно найти. Для поиска воспользуемся утилитой `find`. Тогда поиск файлов в каталоге `dir1` будет выглядеть так:
{line-numbers: false, format: Bash}
```
find dir1 -type f
```

Вывод этой команды может выглядеть например так:
{line-numbers: false}
```
dir1/test3.txt
dir1/test1.txt
dir1/test2.txt
```

Теперь нам нужно добавить действие с помощью параметра `-exec`, в котором мы проверим существование всех найденных файлов в каталоге `dir2`. Но есть одна проблема — каталог `dir1`, который утилита `find` добавляет к именам найденных файлов. Самый простой способ решить эту проблему — перейти в каталог `dir1` и после этого запустить `find`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f
```

Теперь вывод будет выглядеть так:
{line-numbers: false}
```
./test3.txt
./test1.txt
./test2.txt
```

Добавим действие `-exec` с проверкой того, что найденный файл присутствует в каталоге `dir2`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test -e ../dir2/{} \;
```

Обратите внимание, что в этом случае мы вынужденны использовать команду `test`, а не `[[`. Дело в том, что встроенный интерпретатор `find` не умеет корректно обрабатывать Bash конструкцию `[[`.

Если проверка не прошла, то есть файла нет, будем выводить его имя. Для этого инвертируем нашу проверку `test` и добавим второе `-exec` действие, связанное логическим И с первым. В результате получим следующий скрипт:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;
```

Добавим аналогичный вызов `find` для проверки файлов каталога `dir2`:
{line-numbers: true, format: Bash}
```
cd dir1
find . -type f -exec test ! -e ../dir2/{} \; -a -exec echo {} \;

cd ../dir2
find . -type f -exec test ! -e ../dir1/{} \; -a -exec echo {} \;
```

I> Мы написали скрипт сравнения каталогов исключительно в учебных целях. Не используйте его для реальных задач. Лучше применяйте специальную GNU утилиту `diff`.

##### Упражнение 3-6. Использование конструкции `case`

Реализуем скрипт для переключения между конфигурационными файлами с использованием [символьных ссылок](https://ru.wikipedia.org/wiki/Символическая_ссылка). Символьная ссылка — это файл специального типа, который вместо данных содержит указатель на другой файл или каталог системы.

К сожалению, в Unix-окружении, работающем на OS Windows, вместо создания символьной ссылки будет происходить копирование соответствующего файла или каталога. Однако, они будут создаваться корректно на ОС Linux и macOS. Главное преимущество символьной ссылки заключается в том, что при работе с её содержимым вы на самом деле работаете с файлом или каталогом, на который она указывает. Это значит, что все изменения произойдут над этим файлом или каталогом.

Алгоритм нашего скрипта выглядит следующим образом:

1. Удалить существующую символьную ссылку или файл по пути `~/.bashrc`.

2. Проверить опцию командной строки, переданную в скрипт.

3. В зависимости от опции создать символьную ссылку на файл `.bashrc-home` или `.bashrc-work`.

Следующий скрипт реализует алгоритм с помощью конструкции `case`:
{line-numbers: true, format: Bash}
```
#!/bin/bash

file="$1"

rm ~/.bashrc

case "$file" in
  "h")
    ln -s ~/.bashrc-home ~/.bashrc
    ;;

  "w")
    ln -s ~/.bashrc-work ~/.bashrc
    ;;

  *) 
    echo "Указана недопустимая опция"
    ;; 
esac
```

С помощью опции, переданной через позиционный параметр `$1`, выбирается имя файла.

Обратите внимание, что команда создания символьной ссылки остаётся неизменной независимо от опции скрипта. Это верный признак того, что конструкцию `case` можно заменить на ассоциативный массив. Например, следующим образом:
{line-numbers: true, format: Bash}
```
#!/bin/bash

option="$1"

declare -A files=(
  ["h"]="~/.bashrc-home"
  ["w"]="~/.bashrc-work")

if [[ -z "$option" || ! -v files["$option"] ]]
then
  echo "Указана недопустимая опция"
  exit 1
fi

rm ~/.bashrc

ln -s "${files["$option"]}" ~/.bashrc
```

Здесь мы используем двойные кавычки при подстановке элемента массива `files`, потому что он является одним параметром в вызове утилиты `ln`. Таким образом мы решаем возможную проблему с пробелами в путях.

##### Упражнение 3-7. Арифметические действия в дополнительном коде

Результаты сложения однобайтовых целых:
{line-numbers: false}
```
* 79 + (-46) = 0100 1111 + 1101 0010 = 1 0010 0001 -> 0010 0000 = 33

* -97 + 96 = 1001 1111 + 0110 0000 = 1111 1111 -> 1111 1110 -> 1000 0001 = -1
```

Результат сложения двухбайтовых целых:
{line-numbers: false}
```
* 12868 + (-1219) = 0011 0010 0100 0100 + 1111 1011 0011 1101 = 1 0010 1101 1000 0001 -> 0010 1101 1000 0001 = 11649
```

Для проверки корректности перевода чисел в дополнительный код можно использовать [онлайн-калькулятор](https://planetcalc.com/747/)

##### Упражнение 3-8. Вычисление остатка от деления и modulo

{line-numbers: false}
```
* 1697 % 13
q = 1697 / 13 ~ 130.5385 ~ 130
r = 1697 - 13 * 130 = 7

* 1697 modulo 13
q = 1697 / 13 ~ 130.5385 ~ 130
r = 1697 - 13 * 130 = 7

* 772 % -45
q = 772 / -45 ~ -17.15556 ~ -17
r = 772 - (-45) * (-17) = 7

* 772 modulo -45
q = (772 / -45) - 1 ~ -18.15556 ~ -18
r = 772 - (-45) * (-18) = -38

* -568 % 12
q = -568 / 12 ~ -47.33333 ~ -47
r = -568 - 12 * (-47) = -4

* -568 modulo 12
q = (-568 / 12) - 1 ~ -48.33333 ~ -48
r = -568 - 12 * (-48) = 8

* -5437 % -17
q = -5437 / -17 ~ 319.8235 ~ 319
r = -5437 - (-17) * 319 = -14

* -5437 modulo -17
q = -5437 / -17 ~ 319.8235 ~ 319
r = -5437 - (-17) * 319 = -14
```

##### Упражнение 3-9. Вычисление побитового отрицания

Сначала вычислим побитовое отрицание для случая беззнаковых двухбайтовых целых.
{line-numbers: false}
```
 56 = 0000 0000 0011 1000
~56 = 1111 1111 1100 0111 = 65479

 1018 = 0000 0011 1111 1010
~1018 = 1111 1100 0000 0101 = 64517

 58362 = 1110 0011 1111 1010
~58362 = 0001 1100 0000 0101 = 7173
```

Если операция отрицания выполняется над знаковыми двухбайтовыми целыми, результаты будут отличаться.
{line-numbers: false}
```
 56 = 0000 0000 0011 1000
~56 = 1111 1111 1100 0111 -> 1000 0000 0011 1001 = -57

 1018 = 0000 0011 1111 1010
~1018 = 1111 1100 0000 0101 -> 1000 0011 1111 1011 = -1019
```

Число 58362 не может быть представлено в виде знакового двухбайтового целого из-за переполнения. Если записать соответствующие ему биты в переменную такого типа, мы получим -7174. Перевод этого числа в прямой код будет выглядеть следующим образом:
{line-numbers: false}
```
58362 = 1110 0011 1111 1010 -> 1001 1100 0000 0110 = -7174
```

Теперь выполним побитовое отрицание:
{line-numbers: false}
```
  -7174  = 1110 0011 1111 1010
~(-7174) = 0001 1100 0000 0101 = 7173
```

Вы можете проверить результаты побитового отрицания над знаковыми целыми с помощью следующих Bash команд:
{line-numbers: true, format: Bash}
```
$ echo $((~56))
-57
$ echo $((~1018))
-1019
$ echo $((~(-7174)))
7173
```

Проверить отрицание двухбайтового беззнакого целого 58362 с помощью Bash не получится. Интерпретатор сохранит эту переменную в знаковом четырёхбайтовом целом. Тогда в результате отрицания мы получим:
{line-numbers: true, format: Bash}
```
$ echo $((~58362))
-58363
```

##### Упражнение 3-10. Вычисление побитовых И, ИЛИ, исключающего ИЛИ

Вычислим битовые операции для случая беззнаковых двухбайтовый целых:
{line-numbers: false}
```
1122 & 908 = 0000 0100 0110 0010 & 0000 0011 1000 1100 = 0000 0000 000 0000 = 0

1122 | 908 = 0000 0100 0110 0010 | 0000 0011 1000 1100 = 0000 0111 1110 1110 = 2030

1122 ^ 908 = 0000 0100 0110 0010 ^ 0000 0011 1000 1100 = 0000 0111 1110 1110 = 2030


49608 & 33036 = 1100 0001 1100 1000 & 1000 0001 0000 1100 = 1000 0001 0000 1000 = 33032

49608 | 33036 = 1100 0001 1100 1000 | 1000 0001 0000 1100 = 1100 0001 1100 1100 = 49612

49608 ^ 33036 = 1100 0001 1100 1000 ^ 1000 0001 0000 1100 = 0100 0000 1100 0100 = 16580
```

Если целые знаковые, то результаты битовых операций для первой пары чисел 1122 и 908 будут теми же. Для второй пары, вычисление будет отличаться.

Сначала выясним значение обоих чисел в прямом коде:
{line-numbers: false}
```
49608 = 1100 0001 1100 1000 -> 1011 1110 0011 1000 = -15928

33036 = 1000 0001 0000 1100 -> 1111 1110 1111 0100 = -32500

-15928 & -32500 = 1100 0001 1100 1000 & 1000 0001 0000 1100 = 1000 0001 0000 1000 -> 1111 1110 1111 1000 = -32504

-15928 | -32500 = 1100 0001 1100 1000 | 1000 0001 0000 1100 = 1100 0001 1100 1100 -> 1011 1110 0011 0100 = -15924

-15928 ^ -32500 = 1100 0001 1100 1000 ^ 1000 0001 0000 1100 = 0100 0000 1100 0100 = 16580
```

Bash-команды для проверки результатов операций:
{line-numbers: true, format: Bash}
```
$ echo $((1122 & 908))
0
$ echo $((1122 | 908))
2030
$ echo $((1122 ^ 908))
2030

$ echo $((49608 & 33036))
33032
$ echo $((49608 | 33036))
49612
$ echo $((49608 ^ 33036))
16580

$ echo $((-15928 & -32500))
-32504
$ echo $((-15928 | -32500))
-15924
$ echo $((-15928 ^ -32500))
16580
```

##### Упражнение 3-11. Вычисление битовых сдвигов

Вычисление операций:
{line-numbers: false}
```
* 25649 >> 3 = 0110 0100 0011 0001 >> 3 = 0110 0100 0011 0 = 0000 1100 1000 0110 = 3206

* 25649 << 2 = 0110 0100 0011 0001 << 2 = 10 0100 0011 0001 -> 1001 0000 1100 0100 -> 1110 1111 0011 1100 = -28476

* -9154 >> 4 = 1101 1100 0011 1110 >> 4 = 1101 1100 0011 -> 1111 1101 1100 0011 -> 1000 0010 0011 1101 = -573

* -9154 << 3 = 1101 1100 0011 1110 << 3 = 1 1100 0011 1110 -> 1110 0001 1111 0000 -> 1001 1110 0001 0000 = -7696
```

Bash-команды для проверки результатов:
{line-numbers: true, format: Bash}
```
$ echo $((25649 >> 3))
3206
$ echo $((25649 << 2))
102596
$ echo $((-9154 >> 4))
-573
$ echo $((-9154 << 3))
-73232
```

Отличие результатов второй и четвёртой операции связано с восьмибайтовым представлением чисел в Bash.

Вы можете проверить свои расчёты также с помощью [онлайн-калькулятора](https://onlinetoolz.net/bitshift).

##### Упражнение 3-12. Использование операторов цикла

Согласно условию задачи, у игрока есть семь попыток отгадать число. Поэтому применим конструкцию `for` с фиксированным числом итераций. На каждой итерации будем читать введённое пользователем число с помощью команды `read`. Затем сравним это число с загаданным. В зависимости от результата будем выводить текст подсказки.

Чтобы загадать число, воспользуемся зарезервированной переменной `RANDOM`. При чтении она возвращает случайное число от 0 до 32767. В нашем случае требуется число от 0 до 100. Чтобы получить его из значения переменной `RANDOM`, надо вычислить остаток от её деления на 100 по следующей формуле:
{line-numbers: true, format: text}
```
number=$((RANDOM % 100))
``` 

Полное решение задачи выглядит следующим образом:
{line-numbers: true, format: Bash}
```
#!/bin/bash

number=$((RANDOM % 100))

for i in {1..7}
do
  read input
  if (( input < number))
  then
    echo "Число $input меньше искомого"
  elif (( number < input))
  then
    echo "Число $input больше искомого"
  else
    echo "Вы отгадали число"
    exit 0
  fi  
done

echo "Вы не отгадали число"
```