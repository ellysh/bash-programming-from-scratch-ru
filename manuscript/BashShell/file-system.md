## Навигация по файловой системе

Знакомство с Unix-окружением и Bash мы начнём с [**файловой системы**](https://ru.wikipedia.org/wiki/Файловая_система) (ФС). Файловой системой называется способ хранения и чтения информации с дисков. Сначала рассмотрим отличия структуры каталогов в Unix и Windows. Затем познакомимся с Bash-командами для навигации по файловой системе.

### Структура каталогов

В верхней части окна Windows Проводника находится адресная строка. Она выводит абсолютный путь к текущему каталогу. В терминологии Windows каталоги называются [**папками**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Термин_«Папка»). Оба названия обозначают один и тот же объект файловой системы.

Иллюстрация 2-6 приводит окно Проводника. В нём открыт путь `This PC > Local Disk (C:) > msys64`. Это каталог `msys64` на диске `C`. Буква `C` обозначает локальный системный диск. Локальный означает физически подключённый к компьютеру. Системный диск — это тот, на который установлена ОС Windows. Если перевести адресную строку Проводника в абсолютный путь, получим `C:\msys64`.

{caption: "Иллюстрация 2-6. Окно Проводника Windows"}
![Окно Проводника Windows](images/BashShell/explorer.png)

В окне терминала выводится текущий абсолютный путь. Это работает так же как адресная строка Проводника. Но пути в терминале и Проводнике различаются. Причина в отличии структуры каталогов Unix-окружения и Windows.

В Windows каждому диску соответствует буква латинского алфавита. Диск открывается через Проводник как обычная папка. Тогда можно работать с его содержимым. Для примера рассмотрим системный диск `C`. Windows в процессе установки создаёт на нём [стандартный набор каталогов](https://en.wikipedia.org/wiki/Directory_structure#Windows_10):

* `Windows`
* `Program Files`
* `Program Files (x86)`
* `Users`
* `PerfLogs`

В этих каталогах хранятся компоненты ОС и их временные файлы.

Помимо системного диска к компьютеру можно подключить дополнительные диски. Windows обозначает их следующими буквами латинского алфавита: `D`, `E`, `F` и т. д. Структуру каталогов на дополнительных дисках задаёт пользователь. Windows не накладывает на неё никаких ограничений.

Структуру каталогов Windows определяет файловая система [File Allocation Table](https://ru.wikipedia.org/wiki/FAT) (FAT). Компания Microsoft разработала её для ОС [MS-DOS](https://ru.wikipedia.org/wiki/MS-DOS). Впоследствии принципы работы FAT легли в основу стандарта [ECMA-107](http://www.ecma-international.org/publications/standards/Ecma-107.htm). Система [NTFS](https://ru.wikipedia.org/wiki/NTFS) сменила устаревшую FAT в современных версиях Windows. Но из-за требований обратной совместимости структура каталогов в NTFS осталась без изменений.

Структуру каталогов Unix определяет [стандарт POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10). Согласно стандарту, в системе есть каталог самого верхнего уровня. Он называется [**корневым каталогом**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Корневой_каталог) и обозначается символом слэш /. Каталоги и файлы всех подключенных к компьютеру дисков находятся внутри корневого каталога.

Чтобы получить доступ к содержимому диска, его надо смонтировать. **Монтированием** называется встраивание содержимого диска в корневой каталог системы. После монтирования содержимое диска становится доступно по какому-то пути. Этот путь называется [**точкой монтирования**](https://ru.wikipedia.org/wiki/Точка_монтирования). Если перейти в точку монтирования, вы окажетесь в файловой системе диска.

Сравним структуру каталогов Windows и Unix на примере. Предположим, что к компьютеру с Windows подключены два локальных диска `C` и `D`. Тогда структура каталогов первого уровня иерархии выглядит так, как в листинге 2-1.

{caption: "Листинг 2-1. Структура каталогов первого уровня в ОС Windows", line-numbers: false}
```
C:\
    PerfLogs\
    Windows\
    Program Files\
    Program Files (x86)\
    Users\

D:\
    Documents\
    Install\
```

В Unix эта же иерархия каталогов выглядит иначе. Её демонстрирует листинг 2-2.

{caption: "Листинг 2-2. Структура каталогов в ОС Unix", line-numbers: false}
```
/
    c/
        PerfLogs/
        Windows/
        Program Files/
        Program Files (x86)/
        Users/

    d/
        Documents/
        Install/
```

Запустив терминал MSYS2, вы попадаете в Unix-окружение. В нём Windows-пути не работают. Вместо них используйте Unix-пути. Например, каталог `C:\Windows` теперь доступен по пути `/c/Windows`.

В Unix-окружении [важен регистр символов](https://ru.wikipedia.org/wiki/Чувствительность_к_регистру_символов). Это значит, что строки `Documents` и `documents` не равны. В Windows нет чувствительности к регистру. Поэтому если в адресной строке Проводника написать путь `c:\windows`, вы перейдёте в системный каталог `C:\Windows`. В Unix-окружении это не сработает. Все символы надо вводить в правильном регистре.

Кроме регистра символов есть ещё одно отличие. В Unix имена каталогов и файлов в пути разделяет слэш /. В Windows для этого используют обратный слэш \.

### Команды навигации по файловой системе

Как выполнить команду в эмуляторе терминала? Для этого переключитесь на его окно, наберите текст команды и нажмите клавишу Enter. Оболочка обработает ваш ввод. Когда она готова к вводу, на экран выводится **приглашение командной строки**. Приглашение — это специальный символ или строка символов. Если приглашения нет, оболочка занята и не может выполнить команду.

На иллюстрации 2-4 в приглашение обозначается символом доллара $.

Для навигации по файловой системе через Проводник Windows, возможны следующие действия:

* Вывести текущий каталог.
* Перейти в указанный каталог.
* Найти каталог или файл на диске.

Эти же действия доступны через интерфейс командной строки. Каждое из них выполняет специальная команда. Эти команды приведены в таблице 2-1.

{caption: "Таблица 2-1. Команды и утилиты для навигации по файловой системе", width: "100%"}
| Команда | Описание | Примеры |
| --- | --- | --- |
| ls | Вывести на экран содержимое каталога. | `ls` |
| | Если каталог не указан, выводится содержимое текущего. | `ls /c/Windows` |
|  | | |
| pwd | Вывести на экран путь до текущего каталога. | `pwd` |
| | Ключ комнды `-W` выводит путь в структуре каталогов Windows | `pwd -W` |
|  | | |
| cd | Перейти в каталог по относительному или | `cd tmp` |
| | абсолютному пути. | `cd /c/Windows` |
| | | `cd ..` |
|  | | |
| mount | Смонтировать диск в корневую файловую систему. При запуске без параметров выводит список всех смонтированных дисков. | `mount` |
|  | | |
| find | Найти файл или каталог. Первый параметр | `find . -name vim` |
| | команды — это каталог, начиная с которого ведётся поиск. Если он не указан, используется текущий каталог. | `find /c/Windows -name *vim*` |
|  | | |
| grep | Найти файл по его содержимому. | `grep "PATH" *` |
| | | `grep -Rn "PATH" .` |
| | | `grep "PATH" * .*` |

Следующие команды из таблицы 2-1 Bash выполняет самостоятельно:

* pwd
* cd

Эти команды называются [**встроенными в интерпретатор**](https://ru.wikipedia.org/wiki/Bash#Внутренние_команды). Если Bash не может выполнить команду сам, он ищет подходящую утилиту или программу.

В окружение MSYS2 входит набор GNU-утилит. Это вспомогательные узкоспециализированные программы. Они дают доступ к функциям ОС. Также через них пользователь работает с файловой системой. Следующие команды из таблицы 2-1 выполняются GNU-утилитами:

* ls
* mount
* find
* grep

Часто различий между командами и утилитами не делают. Любой текст после приглашения командной строки называют командой.

#### pwd

Рассмотрим команды из таблицы 2-1. Мы только что запустили терминал. Первым делом узнаем текущий каталог. Терминал MSYS2 выводит его перед приглашением $. Этот вывод зависит от конфигурации терминала. Если вы работаете на ОС Linux или macOS, текущий каталог не выводится без дополнительной настройки.

После запуска терминала MSYS2 откроется домашний каталог текущего пользователя. Для сокращения он обозначается символом тильда ~. Этот символ вы видите перед приглашением командной строки. С сокращением ~ можно работать так же, как с любым абсолютным путём.

Чтобы вывести текущий каталог, выполните встроенную команду интерпретатора pwd. Иллюстрация 2-7 демонстрирует результат её выполнения. Команда вывела абсолютный путь до домашнего каталога пользователя: `/home/ilya.shpigor`.

Если к вызову pwd добавить **опцию** `-W`, команда выведет путь в структуре каталогов Windows. Это полезно, если вы создали файл в окружении MSYS2 и собираетесь открыть его в Windows-приложении. Результат вывода pwd с опцией `-W` приведён на иллюстрации 2-7.

{caption: "Иллюстрация 2-7. Вывод команды pwd"}
![Вывод pwd](images/BashShell/pwd-command.png)

Что такое опция команды? Если у приложения только текстовый интерфейс, способы взаимодействия с ним ограничены. При этом ему нужны входные данные для работы. Например, путь до файла или каталога. Командный интерпретатор предлагает простой способ передать эту информацию. Она указывается через пробел после команды запуска приложения. [**Параметром**](https://ru.wikipedia.org/wiki/Интерфейс_командной_строки#Формат_команды) или аргументом программы называются слово или символ, которые передаются ей на вход. **Опцией** или ключом называется аргумент, который переключает режим работы программы. Формат опций стандартизован. Обычно они начинаются с тире - или двойного тире --.

Встроенные команды интерпретатора вызываются так же как и программы. У них тоже есть параметры и опции.

Набирать длинные команды неудобно. Поэтому в Bash есть функция автодополнения. Она вызывается по нажатию клавиши Tab. Наберите первые буквы команды и нажимаете Tab. Если Bash сможет найти команду по первым буквам, он допишет её за вас.  Если несколько команд начинаются одинаково, автодополнение не произойдёт. В этом случае нажмите Tab повторно. Bash выведет список всех доступных команд.

Иллюстрация 2-8 демонстрирует список доступных команд. Bash вывел его после ввода текста `pw` и двойного нажатия Tab.

{caption: "Иллюстрация 2-8. Автодополнение для команды `pw`"}
![Автодополнение pw](images/BashShell/pw-autocompletion.png)

#### ls

Мы узнали текущий каталог. Теперь выведем его содержимое. Для этого есть утилита ls. Предположим, вы только что установили окружение MSYS2. Вызовите ls без параметров в домашнем каталоге пользователя. Утилита ничего не выведет. Этот результат демонстрирует вторая строчка на иллюстрации 2-9. Обычно это означает, что каталог пуст.

{caption: "Иллюстрация 2-9. Вывод утилиты ls"}
![Вывод ls](images/BashShell/ls-command.png)

В Windows есть понятие скрытых файлов и каталогов. Они есть и в Unix-окружении. Такие файлы создают приложения и ОС для своих нужд. Например, в них хранится конфигурация или временная информация. В обычном режиме работы Проводник Windows их не отображает. Чтобы увидеть скрытые файлы, измените [настройки Проводника](https://support.microsoft.com/ru-ru/help/14201/windows-show-hidden-files).

В Unix-окружении имена скрытых файлов и каталогов начинаются с точки. Утилита ls их не отображает по-умолчанию. Чтобы изменить это поведение, запустите утилиту с опцией `-a`. Тогда в домашнем каталоге вы увидите восемь файлов. Все они начинаются с точки, как на иллюстрации 2-9.

Утилита ls может вывести содержимое каталога без перехода в него. Для этого передайте в неё абсолютный или относительный путь до каталога. Иллюстрация 2-10 демонстрирует вывод команды "ls /". Это содержимое корневого каталога.

{caption: "Иллюстрация 2-10. Вывод утилиты ls"}
![Вывод ls](images/BashShell/ls-root-command.png)

Обратите внимание, что в выводе команды "ls /" нет каталогов `/c` и `/d`. Согласно листингу 2-2, это точки монтирования дисков C и D. Они находятся в корневом каталоге. Почему их не выводит ls? Проблема в том, что в файловой системе Windows нет понятия точек монтирования. Поэтому в ней нет каталогов `/c` и `/d`. Они создаются только в Unix-окружении. Через эти каталоги вы получаете доступ к содержимому дисков. Утилита ls читает содержимое каталогов в файловой системе Windows. Поэтому точки монтирования она не отображает. В Linux и macOS такой проблемы нет. Там ls корректно выводит все точки монтирования.

#### mount

Если к компьютеру подключено несколько дисков, полезно вывести на экран их точки монтирования. Это делает утилита [mount](https://ru.wikipedia.org/wiki/Mount). Запустите её без параметров. Она выведет список точек монтирования как на иллюстрации 2-11.

{caption: "Иллюстрация 2-11. Вывод утилиты mount"}
![Результат mount](images/BashShell/mount-command.png)

Рассматривайте этот вывод как таблицу, состоящую из четырёх столбцов. Их значения следующие:

1. Диск, его раздел или каталог. Это то, что монтируется в корневую файловую систему.

2. Точка монтирования. Это путь, по которому доступен смонтированный диск.

3. Тип файловой системы диска.

4. Параметры монтирования. Например, права доступа к диску.

Таблица 2-2 демонстрирует вывод утилиты mount с иллюстрации 2-11. Вывод разделён на столбцы.

{caption: "Таблица 2-2. Вывод утилиты mount", width: "100%"}
| Монтируемый раздел | Точка монтирования | Тип ФС | Параметры монтирования |
| --- | --- | --- | --- |
| `C:/msys64` | `/` | `ntfs` | `binary,noacl,auto` |
| `C:/msys64/usr/bin` | `/bin` | `ntfs` | `binary,noacl,auto` |
| `C:` | `/c` | `ntfs` | `binary,noacl,posix=0,user,noumount,auto` |
| `Z:` | `/z` | `hgfs` | `binary,noacl,posix=0,user,noumount,auto` |

Таблица 2-2 вызовет недоумение у Windows-пользователей. В качестве корневого каталога в Unix-окружении монтируется каталог `C:/msys64`. Далее в него монтируются диски C и Z по путям `/c` и `/z`. С точки зрения Unix-окружения диск C находится по пути `C:/msys64/c`. Но в файловой системе Windows зависимость обратная. Там `C:/msys64` — это подкаталог диска C.

В Unix-окружении это противоречие не вызывает проблем. Путь `/c` является точкой монтирования. Она существует только в окружении Unix. Её нет файловой системе Windows. Представьте, что каталог `/c` в MSYS2 — это [ярлык](https://ru.wikipedia.org/wiki/Ярлык_(компьютер)) для диска C.

Вывод утилиты mount занял на экране много места. Чтобы очистить окно терминала, нажмите комбинацию клавиш Ctrl+L.

Бывает, что запущенная команда долго выполняется или зависла. Чтобы прервать её выполнение, нажмите комбинацию клавиш Ctrl+C.

#### cd

Мы знаем текущий каталог. Теперь перейдём по нужному нам пути. Для примера, найдём документацию по интерпретатору Bash. Проверим системный каталог `/usr`. Там хранятся файлы установленных приложений. Для перехода в `/usr` наберите команду cd так:
{line-numbers: false, format: Bash}
```
cd /usr
```

Не забывайте про автодополнение. Оно работает как для имени команды, так и для её параметров. Достаточно набрать `cd /u` и нажать клавишу Tab. Имя каталога `usr` Bash добавит автоматически. Результат выполнения команды приводит иллюстрация 2-12.

{caption: "Иллюстрация 2-12. Результат выполнения команды cd"}
![Результат cd](images/BashShell/cd-command.png)

При успешном выполнении команда cd ничего не выводит. Она только меняет текущий каталог. Выполните команду и проверьте вывод перед приглашением командной строки. Теперь текущим каталогом стал `/usr`.

Команда cd принимает на вход и абсолютные пути, и относительные. Относительные пути короче и быстрее в наборе. Поэтому их чаще используют для навигации по файловой системе.

Мы перешли в каталог `/usr`. Теперь можно вывести его подкаталоги и перейти в один из них. Предположим, что вместо этого вам надо перейти на уровень выше в корневой каталог. Для этого есть два способа: перейти по абсолютному пути `/` или по специальному относительному пути `..`. Путь `..` всегда указывает на родительский каталог для текущего. Команда перехода по этому пути выглядит так:
{line-numbers: false, format: Bash}
```
cd ..
```

I> Кроме `..` есть еще один специальный путь `.`. Он означает текущий каталог. Если выполнить команду "cd .", ничего не произойдёт. Вы останетесь в там же. Путь `.` нужен для запуска программ из текущего каталога.

Мы находимся в каталоге `/usr`. Выполним здесь утилиту ls. В её выводе есть подкаталог `share`. В нём — подкаталог `doc` с документацией по установленным приложениям. Полный путь документации по Bash такой: `share/doc/bash`. Перейдём в него следующей командой:
{line-numbers: false, format: Bash}
```
cd share/doc/bash
```

Теперь текущим каталогом стал `/usr/share/doc/bash`. Выполним команду ls. Среди прочего она выведет файл с именем `README`. Это и есть документация по Bash, которую мы ищем.

Выведите содержимое файла `README` на экран с помощью утилиты cat. Для этого выполните команду:
{line-numbers: false, format: Bash}
```
cat README
```

Иллюстрация 2-13 демонстрирует её результат.

{caption: "Иллюстрация 2-13. Вывод утилиты cat", height: "30%"}
![Результат cat](images/BashShell/cat-command.png)

I> Авторы некоторых руководств по Bash не рекомендуют выводить содержимое файла утилитой cat. Её назначение — объединять несколько файлов и выводить результат в стандартный поток вывода. Вместо вызова cat для одного файла они рекомендуют комбинировать команду echo и перенаправление потоков. Вот пример такого подхода:
{line-numbers: false, format: Bash}
```
echo "$(< README.txt)"
```

На иллюстрации 2-13 приводится не весь файл `README`, а только его последние строки. Этот файл большой. Поэтому вывод утилиты cat не поместился в окно терминала. Чтобы просмотреть начало файла, используйте полосу прокрутки в правой части окна. Для прокрутки [по страницам](https://en.wikipedia.org/wiki/Page_Up_and_Page_Down_keys) используйте горячие клавиши Shift+PageUp и Shift+PageDown. Для прокрутки по строкам — Shift+↑ и Shift+↓.

#### История команд

Каждая выполненная в терминале команда сохраняется в [истории команд](https://ru.wikipedia.org/wiki/History). Чтобы повторить предыдущую команду, нажмите стрелку вверх ↑ и Enter. Нажмите стрелку вверх несколько раз, чтобы прокрутить историю дальше к началу. Для перехода к следующей команде в истории нажмите стрелку вниз ↓.

Например, вы только что ввели команду "cat README". Чтобы её повторить, нажмите стрелку вверх и Enter.

Комбинация клавиш Ctrl+R вызывает поиск по истории. Нажмите Ctrl+R и начните набирать текст. Bash предложит вам последнюю введённую команду, которая начинается также. Чтобы исполнить её, просто нажмите Enter.

Для вывода на экран всей истории командой наберите:
{line-numbers: false, format: Bash}
```
history
```

В историю команд попадают только выполненные команды. В неё не попадают команды, которые вы набрали, а затем стёрли.

Что делать, есть в историю надо сохранить команду без её исполнения? Например, вы собираетесь исполнить её позже. Для этого есть трюк с комментарием. Если команда начинается с символа решётка #, Bash обработает её как комментарий. По нажатию Enter она попадёт в историю, но не исполнится. С этим трюком вызов утилиты cat станет таким:
{line-numbers: false, format: Bash}
```
#cat README
```

Теперь исполним команду. Для этого найдите её в истории и сотрите символ решётка в начале. Затем нажмите Enter.

В большинстве терминалов трюк с комментарием выполняет комбинация клавиш Alt+Shift+3. Работает она так:

1. Наберите команду, но не нажимайте Enter.
2. Нажмите Alt+Shift+3.
3. Команда сохранится в истории без исполнения.

Как скопировать текст из терминала? Предположим, что часть файла `README` нужна в другом документе. Для копирования используйте [**буфером обмена**](https://ru.wikipedia.org/wiki/Буфер_обмена). Это временное хранилище для строк. В нём сохраняется выделенный в терминале текст. Его можно вставить в любое другое окно.

Для копирования текста из терминала:

1. Выделите мышью нужный текст. Для этого зажмите левую кнопку мыши и проведите курсором по тексту.

2. Для вставки текста из буфера обмена в окно терминала нажмите среднюю кнопку мыши. Текст будет вставлен в текущую позицию курсора.

3. Для вставки текста в другое приложение нажмите правую кнопку мыши и выберите пункт "Вставить".

#### find

Искать нужный файл или каталог командами cd и ls неудобно. Для этого есть специальная утилита find.

Если запустить утилиту find без параметров, она выведет содержимое текущего каталога и его подкаталогов. В вывод попадут и скрытые объекты. На иллюстрации 2-14 результат запуска find для домашнего каталога пользователя `~`.

{caption: "Иллюстрация 2-14. Вывод утилиты find", height: "30%"}
![Вывод find](images/BashShell/find-command.png)

Первый параметр утилиты find — это каталог, в котором надо искать. Утилита принимает относительный или абсолютный путь. Например, вот команда для поиска в корневом каталоге:
{line-numbers: false, format: Bash}
```
find /
```

Со второго параметра утилиты начинаются условия поиска. Если найденный объект не удовлетворяет условиям, он не выводится на экран. Условия сочетаются друг с другом и составляют единое выражение. Для обработки этого выражения в утилиту встроен специальный интерпретатор. Например, условием поиска может быть имя файла. Тогда в вывод find попадут только файлы с этим именем.

Таблица 2-3 приводит часто используемые условия для утилиты find.

{caption: "Таблица 2-3. Часто используемые условия утилиты find", width: "100%"}
| Условие | Значение | Пример |
| --- | --- | --- |
| `-type f` | Искать только файлы. | `find -type f` |
|  | | |
| `-type d` | Искать только каталоги. | `find -type d` |
|  | | |
| `-name шаблон` | Поиск файла или каталога по [**шаблону имени**](https://ru.wikipedia.org/wiki/Шаблон_поиска). | `find -name README` |
| | Шаблон чувствителен к регистру. | `find -name READ*` |
| | | `find -name READ??` |
|  | | |
| `-iname шаблон` | Поиск файла или каталога по шаблону имени. Шаблон нечувствителен к регистру. | `find -iname readme` |
|  | | |
| `-path шаблон` | Поиск по шаблону пути к файлу или каталогу. Шаблон чувствителен к регистру. | `find -path */doc/bash/*` |
|  | | |
| `-ipath шаблон` | Поиск по шаблону пути к файлу или каталогу. Шаблон нечувствителен к регистру. | `find . -ipath */DOC/BASH/*` |
|  | | |
| `-a` или `-and` | Скомбинировать несколько условий с помощью логического И. В вывод попадут только файлы и каталоги, удовлетворяющие всем условиям. | `find -name README -a -path */doc/bash/* ` |
|  | | |
| `-o` или `-or` | Скомбинировать несколько условий с помощью логического ИЛИ. Если файл или каталог соответствует хотя бы одному условию, он попадёт в вывод. | `find -name README -o -path */doc/bash/* ` |
|  | | |
| `!` или `-not` | Логическое отрицание (НЕ) | `find -not -name README` |
| | последующего условия. В вывод попадут только файлы и каталоги, которые не удовлетворяют условию. | `find ! -name README` |

Шаблоном называется поисковый запрос. В него вместе с обычными символами входят [**символы подстановки**](https://ru.wikipedia.org/wiki/Символ_подстановки) (wildcard character). Всего в Bash три таких символа: *, ? и [. Звёздочка означает любое количество любых символов. Знак вопроса — один любой символ. Например, строка `README` соответствует следующим шаблонам:

* `*ME`
* `READM?`
* `*M?`
* `R*M?`

Квадратные скобки указывают набор символов в определённой позиции строки. Например, шаблон `[cb]at.txt` соответствует файлам `cat.txt` и `bat.txt`. Вот вызов утилиты find с поиском по этому шаблону:
{line-numbers: false, format: Bash}
```
find . -name "[cb]at.txt"
```

{caption: "Упражнение 2-1. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону "*ME.??" ?

* 00_README.txt
* README
* README.md
```

{caption: "Упражнение 2-2. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону "*/doc?openssl*" ?

* /usr/share/doc/openssl/IPAddressChoice_new.html
* /usr/share/doc_openssl/IPAddressChoice_new.html
* doc/openssl
* /doc/openssl
```

Применим поиск по шаблонам на практике. Вернёмся к задаче с документацией по Bash. Найдём файл `README` с помощью утилиты find. Предположим, что нам неизвестен диск, где хранится файл. Тогда передадим в find первым параметром корневой каталог. Так она будет искать файл на всех смонтированных дисках. В Unix-окружении документы хранятся в каталогах с именем `doc`. Учитывая это, вызовем следующую команду поиска:
{line-numbers: false, format: Bash}
```
find / -path */doc/*
```

Команда выведет список всех файлов с документацией на всех смонтированных дисках. Этот список слишком длинный. Сократим его с помощью дополнительных условий поиска. Добавим слово `bash` в путь искомого файла. Получится следующая команда:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -path */bash/*
```

Иллюстрация 2-15 демонстрирует результат. То же самое выведет следующая команда:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -a -path */bash/*
```

Отличие команд в опции `-a` между условиями. Она означает логическое И. Если между условиями не указывать логическую операцию, по умолчанию применяется И.

{caption: "Иллюстрация 2-15. Результат поиска утилиты find", height: "30%"}
![Результат find](images/BashShell/find-path-path.png)

В конце вывода утилита find сообщает об ошибке. Проблема в том, что некоторые подкаталоги `/` являются точками монтирования Windows-дисков. Например, диск C смонтирован в `/c`. Утилита не может получить доступ к их содержимому при поиске с корневого каталога. Чтобы избежать ошибки, начните поиск с точки монтирования диска C:
{line-numbers: false, format: Bash}
```
find /c -path */doc/* -a -path */bash/*
```

Альтернативное решение — исключить точки монтирования из поиска. Для этого передайте опцию `-mount`:
{line-numbers: false, format: Bash}
```
find / -mount -path */doc/* -a -path */bash/*
```

В результате find выведет небольшой список документов. Среди них легко найти нужный `README` файл.

Искать файл документации можно и по-другому. Предположим, что его имя известно. Тогда укажем имя вместе с предполагаемым путём. Получим следующую команду
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README
```

Иллюстрация 2-16 демонстрирует результат поиска.

{caption: "Иллюстрация 2-16. Результат поиска утилиты find", height: "30%"}
![Результат find](images/BashShell/find-path-name.png)

Перед нами снова небольшой список файлов, в котором легко найти нужный.

Условия утилиты find можно группировать. Для этого используйте [экранированные](https://ru.wikipedia.org/wiki/Экранирование_символов) круглые скобки. Например, найдём файлы `README` с путём `*/doc/*` или файлы `LICENSE` с произвольным путём. Это сделает следующая команда:
{line-numbers: false, format: Bash}
```
find / \( -path */doc/* -name README \) -o -name LICENSE
```

Зачем экранировать скобки в выражении утилиты find? Дело в том, что скобки — это часть синтаксиса Bash. Они используются в конструкциях языка. Встретив их в вызове утилиты, Bash выполнит **подстановку**. Подстановкой называется замена части команды на что-то другое. С помощью экранирования мы заставляем интерпретатор игнорировать скобки. В этом случае он передаст их как есть в утилиту find.

Утилита find умеет не только искать, но и обрабатывать файлы и каталоги. После условия поиска, можно указать действие. Утилита применит его к каждому найденному объекту.

Опции для указания действий приведены в таблице 2-4.

{caption: "Таблица 2-4. Опции для указания действий над найденными объектами", width: "100%"}
| Опция | Значение | Пример |
| --- | --- | --- |
| `-exec команда {} \;`| Выполнить указанную команду над каждым найденным объектом. | `find -name README -type f -exec cp {} ~ \;` |
|  | | |
| `-exec команда {} +`| Выполнить указанную команду один раз над всеми найденными объектами. Команда получит все объекты на вход. | ` find -type d -exec cp -t ~ {} +` |
|  | | |
| `-delete`| Удалить каждый из найденных файлов. Каталоги удаляются, только если они пустые. | `find -name README -type f -delete` |

Есть два варианта действия `-exec`. Они отличаются символами на конце: экранированная точка с запятой `\;` или плюс +. Действие с плюсом сработает только, если вызываемая команда способна обработать несколько входных параметров. Большинство GNU-утилит с этим справятся. Если команда принимает только один параметр, она обработает только первый найденный объект.

Применим действие `-exec` для решения практической задачи. Скопируем файлы документации по Bash с расширением HTML в домашний каталог. Для начала найдём эти файлы утилитой find. Её вызов выглядит так:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html"
```

Передавая шаблоны в find, заключайте их в двойные кавычки ". Кавычки делают то же, что и обратный слэш перед круглыми скобками. Они запрещают Bash интерпретировать шаблоны. Тогда утилита find получает их как есть и интерпретирует сама.

Результат поиска HTML документов приведён на иллюстрации 2-17.

{caption: "Иллюстрация 2-17. Результат работы утилиты find", height: "30%"}
![Результат find](images/BashShell/find-html.png)

Добавим к команде поиска действие `-exec`. Оно вызывает утилиту cp. Утилита копирует файлы и каталоги в указанный путь. Первым параметром cp принимает копируемый объект. Второй параметр — путь, куда копировать. Вызов find с действием выглядит так:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cp {} ~ \;
```

Это команда выведет только ошибку с точками монтирования.

Разберёмся, что сделала команда. Она вызвала утилиту cp для каждого найденного HTML файла. Первым параметром cp получила путь до файла. Утилита find подставила путь вместо фигурных скобок {}. Она нашла два файла. Поэтому cp вызывалась дважды так:
{line-numbers: true, format: Bash}
```
cp ./usr/share/doc/bash/bash.html ~
cp ./usr/share/doc/bash/bashref.html ~
```

Каждый вызов копирует один HTML файл в домашний каталог пользователя.

Только что мы написали первую программу на языке интерпретатора утилиты find. Она работает по следующему алгоритму:

1. Найти файлы с расширением HTML на всех дисках. Их пути соответствуют шаблону `*/doc/bash/*`.

2. Скопировать каждый найденный файл в каталог пользователя.

Алгоритм программы состоит всего из двух шагов. Но это масштабируемое решение для поиска и копирования файлов. Программа обработает десятки HTML файлов так же быстро, как и два.

Действия `-exec` комбинируются точно так же как и условия поиска. Для примера выведем содержимое каждого из найденных HTML файлов и подсчитаем количество строк в них. С первой задачей справится утилита cat. Утилита wc подсчитает число строк. На вход wc принимает имя файла для обработки. Команда вызова find в этом случае выглядит так:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cat {} \; -exec wc -l {} \;
```

Мы не указали логическую операцию между действиями `-exec`. По умолчанию используется логическое И. Это означает, что второе действие выполняется только при успешном исполнении первого. Если заменить логическую операцию на ИЛИ, второе действие будет выполняться всегда, независимо от результата первого.

Действия `-exec` группируются с помощью экранированных круглых скобок `\(` и `\)`. Это работает так же как группирование условий поиска.

{caption: "Упражнение 2-3. Поиск файлов утилитой find", line-numbers: false}
```
Напишите команду вызова find для поиска текстовых файлов в Unix-окружении.
Дополните команду, чтобы вывести общее число строк в этих файлах.
```

#### Логические выражения

Условия поиска утилиты find представляют собой [**логические выражения**](https://ru.wikipedia.org/wiki/Логическое_выражение). Логическим выражением называется конструкция языка программирования. Выражение можно вычислить. В результате получится одно из двух значений: "истина" или "ложь".

Условие поиска find — это конструкция встроенного в утилиту интерпретатора. Если для найденного объекта условие выполняется, его вычисление даст результат "истина". Если условие не выполняется, его результат — "ложь". Если условий несколько, они объединяются в составное логическое выражение.

Мы сталкивались с алгеброй логики, когда знакомились с двоичной системой счисления. Этот раздел математики изучает [**логические операции**](https://ru.wikipedia.org/wiki/Логическая_операция). Они отличаются от привычной арифметики сложения, вычитания, умножения и деления.

Вычисление логического выражения даёт только два возможных значения. Поэтому арифметические действия над двумя выражениями тривиальны и ничего не дают. Если же применить к ним логические операции, получим условия со строгими правилами вывода результата. Например, для утилиты find так составляется условие для поиска файла с заданным именем и путём. Комбинация таких условий с действиями даёт сложное поведение программы.

**Операндом** называется то, над чем выполняется логическая операция. Операндом может быть выражение или отдельное значение.

Для простоты разберём логические выражения на примере, не связанном с утилитой find. Представьте, что мы программируем робота для склада. Его задача — перевозить коробки из точки А в точку Б. Для этого зададим ему следующий прямолинейный алгоритм:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Двигайся в точку Б.

4. Положи коробку в точке Б.

В этом алгоритме нет никаких условий. Это значит, что робот выполняет каждый его шаг независимо от внешних событий.

Теперь представьте, что на пути робота в точку Б окажется препятствие. Например, другой робот. В этом случае исполнение алгоритма приведёт к столкновению. Чтобы этого не случилось, добавим условие:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Если нет препятствия, двигайся в точку Б. Иначе остановись.

4. Положи коробку в точке Б.

Третий шаг алгоритма называется [**условным оператором**](https://ru.wikipedia.org/wiki/Ветвление_(программирование)). Все современные языки программирования имеют такую конструкцию.

Алгоритм работы условного оператора выглядит так:

1. Вычислить значение операнда.

2. Если результат "истина", выполнить первое действие.

3. Если результат "ложь", выполнить второе действие.

В нашем примере робот вычисляет значение логического выражения "нет препятствия". Если препятствие есть, выражение будет ложно и робот остановится. В противном случае он продолжит движение в точку Б.

Логические операции позволяют скомбинировать несколько выражений. Например, робот пробует взять коробку в точке А, но её там нет. Тогда ему нет смысла двигаться в точку Б. Добавим это условие к уже существующему выражению с помощью операции [**логического И**](https://ru.wikipedia.org/wiki/Конъюнкция) (конъюнкция). Теперь наш алгоритм выглядит так:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Если есть коробка И нет препятствия, двигайся в точку Б. Иначе остановись.

4. Положи коробку в точке Б.

Вычисление логических операций тоже даёт истину или ложь. Результатом логического И будет "истина", когда оба операнда истинны. То есть у робота есть коробка и нет препятствия. В любом другом случае результатом операции будет "ложь". Тогда робот остановится.

Работая с утилитой find, мы познакомились с ещё двумя логическими операциями: [**ИЛИ**](https://ru.wikipedia.org/wiki/Дизъюнкция) (дизъюнкция) и [**НЕ**](https://ru.wikipedia.org/wiki/Отрицание) (отрицание).

На самом деле в нашем алгоритме для робота мы уже применили НЕ, когда написали выражение "нет препятствия". Это отрицание: "НЕ есть препятствие". Укажем явно логическое НЕ в алгоритме:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Если есть коробка И НЕ есть препятствие, двигайся в точку Б. Иначе остановись.

4. Положи коробку в точке Б.

В логическом выражении операцию И можно заменить на ИЛИ. Чтобы поведение робота не изменилось, добавим отрицание к первому условию и уберём его у второго. Также поменяем порядок действий условного оператора. Теперь если выражение будет истинным, робот остановится. Если ложным, продолжит двигаться к точке Б. В итоге получим следующий алгоритм:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Если НЕ есть коробка ИЛИ есть препятствие, остановись. Иначе двигайся в точку Б.

4. Положи коробку в точке Б.

Прочитайте внимательно новый условный оператор. Логика робота не изменилась. Он по-прежнему остановится, если у него нет коробки или на пути возникло препятствие.

В нашем примере логическое выражение записано в виде предложения на русском языке. Это предложение звучит неестественно. Его надо прочитать несколько раз, чтобы понять. Причина в том, что [**естественный язык**](https://ru.wikipedia.org/wiki/Естественный_язык) (язык общения людей) не подходит для описания логических выражений. Он недостаточно точен. Поэтому в алгебре логики применяют математическая запись.

Кроме логических И, ИЛИ, НЕ в программировании часто используются ещё три операции:

* Эквивалентность
* Не эквивалентность
* Исключающее ИЛИ

Таблице 2-5 приводит полный список логических операций.

{caption: "Таблица 2-5. Логические операции в программировании", width: "100%"}
| Операция | Результат вычисления выражения |
| --- | --- |
| И (AND) | "Истина", когда оба операнда "истина". |
|  | |
| ИЛИ (OR) | "Истина", когда любой из операндов "истина". "Ложь", когда все операнды "ложь". |
|  | |
| НЕ (NOT) | "Истина", когда операнд "ложь" и наоборот. |
|  | |
| Исключающее ИЛИ (XOR) | "Истина", когда значения операндов отличаются (истина-ложь или ложь-истина). "Ложь", когда они совпадают (истина-истина, ложь-ложь). |
|  | |
| Эквивалентность | "Истина", когда значения операндов совпадают. |
|  | |
| Не эквивалентность | "Истина", когда значения операндов отличаются. |

Постарайтесь запомнить эту таблицу. Это несложно, если вы часто используете логические операции на практике.

#### grep

Утилита grep — это ещё один инструмент поиска. Она ищет файлы по их содержимому.

Когда применять утилиту find, а когда grep? Используйте find, чтобы найти файл или каталог по имени, пути или [**метаданным**](https://ru.wikipedia.org/wiki/Метаданные). Метаданными называется дополнительная информация об объекте файловой системы. Например, размер, время создания и последней модификации, права доступа. Используйте утилиту grep для поиска файла, о котором неизвестно ничего кроме его содержимого.

Рассмотрим пример. Так станет понятнее, какую утилиту когда выбирать. Мы ищем файл с документацией. Известно, что в нём встречается фраза "free software" (свободное ПО). Если выбрать утилиту find, алгоритм поиска будет следующим:

1. Найти все файлы документации с именем `README` с помощью find.

2. Открыть каждый файл в текстовом редакторе и найти в нём фразу "free software".

Поиск строки в файлах через текстовый редактор займёт много времени. Утилита grep автоматизирует это. Следующая команда найдёт строку "free software" в файле `README`:
{line-numbers: false, format: Bash}
```
grep "free software" /usr/share/doc/bash/README
```

Первый параметр утилиты — это строка для поиска. Не забывайте про двойные кавычки. Так мы сообщаем Bash, что grep получает строку без изменений. Без кавычек пробел разделит её на два отдельных параметра. Этот механизм разделения строк на слова в Bash называется [**word splitting**](http://mywiki.wooledge.org/WordSplitting).

Вторым параметром grep принимает относительный или абсолютный путь к файлу. Если указать список файлов через пробелы, утилита обработает их все. В примере мы передали только один путь до файла `README`.

Иллюстрация 2-18 приводит результат работы утилиты grep.

{caption: "Иллюстрация 2-18. Результат вызова утилиты grep", width: "100%"}
![Результат grep](images/BashShell/grep-command.png)

Утилита выводит на экран все строки файла, в которых встречается искомая фраза. Вывод удобнее читать, если добавить в него номера найденных строк. Для этого укажите опцию `-n` перед первым параметром утилиты. Результат такого вызова приведён в нижней части иллюстрации 2-18.

Мы узнали, как с помощью grep найти строку в указанных файлах. Теперь применим утилиту для решения нашей задачи. Найдём файлы документации с фразой "free software". Это можно сделать двумя способами:

* Использовать шаблоны поиска Bash.
* Использовать механизм перебора файлов самой утилиты grep.

Рассмотрим первый способ. Предположим, что в домашнем каталоге пользователя есть два текстовых файла: `bash.txt` и `xz.txt`. Это копии `README` документов программ Bash и xz. Найдём, в каком из них встречается фраза "free software". Для этого выполним следующие две команды:
{line-numbers: true, format: Bash}
```
cd ~
grep "free software" *
```

Сначала мы переходим в домашний каталог пользователя. Затем вызываем утилиту grep.

В качестве пути до целевого файла мы указали символ подстановки — звёздочку. Этот шаблон поиска означает любую строку. Bash выполнит подстановку перед запуском утилиты grep. Вместо шаблона в команду подставится список всех файлов из домашнего каталога. В результате вызов grep будет выглядеть так:
{line-numbers: false, format: Bash}
```
grep "free software" bash.txt xz.txt
```

Запустите оба варианта вызова grep: с шаблоном * и со списком файлов через пробел. Утилита даст одинаковый результат.

Попробуем обойтись без команды cd для перехода в домашний каталог. Для этого добавим в шаблон поиска путь к каталогу. Получится такой вызов grep:
{line-numbers: false, format: Bash}
```
grep "free software" ~/*
```

Команда echo поможет проверить результат подстановки шаблонов поиска. Посмотрим, как Bash развернёт шаблоны из наших примеров:
{line-numbers: true, format: Bash}
```
echo *
echo ~/*
```

Выполните эти команды. Они выведут список файлов в домашнем каталоге.

Шаблоны поиска нельзя заключать в двойные кавычки. Например, так:
{line-numbers: false, format: Bash}
```
grep "free software" "*"
```

Из-за кавычек Bash не развернёт шаблон, а передаст его как есть утилите grep. Она в отличие от find не умеет самостоятельно разворачивать шаблоны. Поэтому такой вызов приведёт к ошибке как на иллюстрации 2-19.

{caption: "Иллюстрация 2-19. Результат обработки шаблона в grep", width: "100%"}
![Результат grep](images/BashShell/grep-error.png)

Bash не включает скрытые файлы и каталоги в подстановку шаблона `*`. В нашем примере это означает, что утилита grep не получит их на вход. Чтобы искать только по скрытым файлам, используйте шаблон `.*`. Чтобы искать по всем файлам сразу, укажите два шаблона через пробел. Например, так:
{line-numbers: false, format: Bash}
```
grep "free software" * .*
```

Вместо шаблонов поиска, можно использовать встроенный механизм grep. Он перебирает файлы в указанном каталоге. Опция `-r` включает этот режим работы утилиты. Если вы используете опцию, последним параметром укажите не имя файла, а каталог поиска.

Следующая команда найдёт строку "free software" в файлах текущего каталога:
{line-numbers: false, format: Bash}
```
grep -r "free software" .
```

Такой вызов grep обработает все файлы текущего каталога, включая скрытые. Но файлы из подкаталогов обработаны не будут. Чтобы включить их в поиск, замените опцию `-r` на `-R`. Например, так:
{line-numbers: false, format: Bash}
```
grep -R "free software" .
```

Целевой каталог для поиска указывается по относительному или абсолютному пути. Вот примеры для обоих случаев:
{line-numbers: true, format: Bash}
```
cd /home
grep -R "free software" ilya.shpigor/tmp
grep -R "free software" /home/ilya.shpigor/tmp
```

Предположим, нас интересует список файлов, в которых встречается фраза. В обычном режиме утилита grep выводит все вхождения искомой фразы. Это лишний вывод, который не всегда нужен. Уберём его опцией `-l`. Например, так:
{line-numbers: false, format: Bash}
```
grep -Rl "free software" .
```

Иллюстрация 2-20 приводит результат этой команды.

{caption: "Иллюстрация 2-20. grep выводит только имена файлов"}
![Результат grep](images/BashShell/grep-files.png)

Мы получили список файлов, в которых фраза "free software" встречается хотя бы раз. Допустим, нам нужен противоположный результат: список файлов, где фразы нет. Для такого поиска используйте опцию `-L`. Например, так:
{line-numbers: false, format: Bash}
```
grep -RL "free software" .
```

Файлы с исходным кодом программ текстовые. Утилита grep работает только с текстовыми файлами. Поэтому grep хорошо справляется с поиском по исходному коду. Используйте её как дополнение к вашему редактору.

Возможно, вам понравилась утилита grep. Вы хотите обрабатывать ей документы в формате [PDF](https://ru.wikipedia.org/wiki/Portable_Document_Format) и MS Office. К сожалению, это не сработает. Формат этих файлов не текстовый. То есть данные в них закодированы. Для обработки таких файлов, вам понадобится другая утилита. Таблица 2-6 приводит альтернативы grep для не текстовых файлов.

{caption: "Таблица 2-6. Утилиты для работы с PDF и MS Office файлами", width: "100%"}
| Утилита | Функции |
| --- | --- |
| [pdftotext](http://www.xpdfreader.com) | Конвертирует PDF-файл в текстовый формат. |
|  | |
| [pdfgrep](https://pdfgrep.org) | Ищет PDF-файл по его содержанию. |
|  | |
| [antiword](http://www.winfield.demon.nl) | Конвертирует файл MS Office в текстовый формат. |
|  | |
| [catdoc](https://www.wagner.pp.ru/~vitus/software/catdoc) | Конвертирует файл MS Office в текстовый формат. |
|  | |
| [xdoc2txt](https://documentation.help/xdoc2txt/xdoc2txt_en.html) | Конвертирует файлы PDF и MS Office в текстовый формат. |

Некоторые из этих утилит устанавливаются в окружение MSYS2 пакетным менеджером pacman. В последней главе книги мы рассмотрим, как это сделать.

{caption: "Упражнение 2-4. Поиск файлов утилитой grep", line-numbers: false}
```
Напишите вызов утилиты grep для поиска системных утилит со свободной лицензией.
Для открытого ПО предпочитают следующие лицензии:

1. GNU General Public License
2. MIT license
3. Apache license
4. BSD license
```
