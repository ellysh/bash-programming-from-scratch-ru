## Навигация по файловой системе

Знакомство с Unix-окружением и Bash мы начнём с [**файловой системы**](https://ru.wikipedia.org/wiki/Файловая_система) (ФС). Файловой системой называется способ хранения и чтения информации с дисков. Сначала рассмотрим отличия структуры каталогов в Unix и Windows. Затем познакомимся с Bash-командами для навигации по файловой системе.

### Структура каталогов

В верхней части окна Windows Проводника находится адресная строка. Она выводит абсолютный путь к текущему каталогу. В терминологии Windows каталоги называются [**папками**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Термин_«Папка»). Оба названия обозначают один и тот же объект файловой системы.

Иллюстрация 2-6 приводит окно Проводника. В нём открыт путь `This PC > Local Disk (C:) > msys64`. Это каталог `msys64` на диске `C`. Буква `C` обозначает локальный системный диск. Локальный означает физически подключённый к компьютеру. Системный диск — это тот, на который установлена ОС Windows. Если перевести адресную строку Проводника в абсолютный путь, получим `C:\msys64`.

{caption: "Иллюстрация 2-6. Окно Проводника Windows"}
![Окно Проводника Windows](images/BashShell/explorer.png)

В окне терминала выводится текущий абсолютный путь. Это работает так же как адресная строка Проводника. Но пути в терминале и Проводнике различаются. Причина в отличии структуры каталогов Unix-окружения и Windows.

В Windows каждому диску соответствует буква латинского алфавита. Диск открывается через Проводник как обычная папка. Тогда можно работать с его содержимым. Для примера рассмотрим системный диск `C`. Windows в процессе установки создаёт на нём [стандартный набор каталогов](https://en.wikipedia.org/wiki/Directory_structure#Windows_10):

* `Windows`
* `Program Files`
* `Program Files (x86)`
* `Users`
* `PerfLogs`

В этих каталогах хранятся компоненты ОС и их временные файлы.

Помимо системного диска к компьютеру можно подключить дополнительные диски. Windows обозначает их следующими буквами латинского алфавита: `D`, `E`, `F` и т. д. Структуру каталогов на дополнительных дисках задаёт пользователь. Windows не накладывает на неё никаких ограничений.

Структуру каталогов Windows определяет файловая система [File Allocation Table](https://ru.wikipedia.org/wiki/FAT) (FAT). Компания Microsoft разработала её для ОС [MS-DOS](https://ru.wikipedia.org/wiki/MS-DOS). Впоследствии принципы работы FAT легли в основу стандарта [ECMA-107](http://www.ecma-international.org/publications/standards/Ecma-107.htm). Система [NTFS](https://ru.wikipedia.org/wiki/NTFS) сменила устаревшую FAT в современных версиях Windows. Но из-за требований обратной совместимости структура каталогов в NTFS осталась без изменений.

Структуру каталогов Unix определяет [стандарт POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10). Согласно стандарту, в системе есть каталог самого верхнего уровня. Он называется [**корневым каталогом**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Корневой_каталог) и обозначается символом слэш /. Каталоги и файлы всех подключенных к компьютеру дисков находятся внутри корневого каталога.

Чтобы получить доступ к содержимому диска, его надо смонтировать. **Монтированием** называется встраивание содержимого диска в корневой каталог системы. После монтирования содержимое диска становится доступно по какому-то пути. Этот путь называется [**точкой монтирования**](https://ru.wikipedia.org/wiki/Точка_монтирования). Если перейти в точку монтирования, вы окажетесь в файловой системе диска.

Сравним структуру каталогов Windows и Unix на примере. Предположим, что к компьютеру с Windows подключены два локальных диска `C` и `D`. Тогда структура каталогов первого уровня иерархии выглядит так, как в листинге 2-1.

{caption: "Листинг 2-1. Структура каталогов первого уровня в ОС Windows", line-numbers: false}
```
C:\
    PerfLogs\
    Windows\
    Program Files\
    Program Files (x86)\
    Users\

D:\
    Documents\
    Install\
```

В Unix эта же иерархия каталогов выглядит иначе. Её демонстрирует листинг 2-2.

{caption: "Листинг 2-2. Структура каталогов в ОС Unix", line-numbers: false}
```
/
    c/
        PerfLogs/
        Windows/
        Program Files/
        Program Files (x86)/
        Users/

    d/
        Documents/
        Install/
```

Запустив терминал MSYS2, вы попадаете в Unix-окружение. В нём Windows-пути не работают. Вместо них используйте Unix-пути. Например, каталог `C:\Windows` теперь доступен по пути `/c/Windows`.

В Unix-окружении [важен регистр символов](https://ru.wikipedia.org/wiki/Чувствительность_к_регистру_символов). Это значит, что строки `Documents` и `documents` не равны. В Windows нет чувствительности к регистру. Поэтому если в адресной строке Проводника написать путь `c:\windows`, вы перейдёте в системный каталог `C:\Windows`. В Unix-окружении это не сработает. Все символы надо вводить в правильном регистре.

Кроме регистра символов есть ещё одно отличие. В Unix имена каталогов и файлов в пути разделяет слэш /. В Windows для этого используют обратный слэш \.

### Команды навигации по файловой системе

Как выполнить команду в эмуляторе терминала? Для этого переключитесь на его окно, наберите текст команды и нажмите клавишу Enter. Оболочка обработает ваш ввод. Когда она готова к вводу, на экран выводится **приглашение командной строки**. Приглашение — это специальный символ или строка символов. Если приглашения нет, оболочка занята и не может выполнить команду.

На иллюстрации 2-4 в приглашение обозначается символом доллара $.

Для навигации по файловой системе через Проводник Windows, возможны следующие действия:

* Вывести текущий каталог.
* Перейти в указанный каталог.
* Найти каталог или файл на диске.

Эти же действия доступны через интерфейс командной строки. Каждое из них выполняет специальная команда. Эти команды приведены в таблице 2-1.

{caption: "Таблица 2-1. Команды и утилиты для навигации по файловой системе", width: "100%"}
| Команда | Описание | Примеры |
| --- | --- | --- |
| ls | Вывести на экран содержимое каталога. | `ls` |
| | Если каталог не указан, выводится содержимое текущего. | `ls /c/Windows` |
|  | | |
| pwd | Вывести на экран путь до текущего каталога. | `pwd` |
| | Ключ комнды `-W` выводит путь в структуре каталогов Windows | `pwd -W` |
|  | | |
| cd | Перейти в каталог по относительному или | `cd tmp` |
| | абсолютному пути. | `cd /c/Windows` |
| | | `cd ..` |
|  | | |
| mount | Смонтировать диск в корневую файловую систему. При запуске без параметров выводит список всех смонтированных дисков. | `mount` |
|  | | |
| find | Найти файл или каталог. Первый параметр | `find . -name vim` |
| | команды — это каталог, начиная с которого ведётся поиск. Если он не указан, используется текущий каталог. | `find /c/Windows -name *vim*` |
|  | | |
| grep | Найти файл по его содержимому. | `grep "PATH" *` |
| | | `grep -Rn "PATH" .` |
| | | `grep "PATH" * .*` |

Следующие команды из таблицы 2-1 Bash выполняет самостоятельно:

* pwd
* cd

Эти команды называются [**встроенными в интерпретатор**](https://ru.wikipedia.org/wiki/Bash#Внутренние_команды). Если Bash не может выполнить команду сам, он ищет подходящую утилиту или программу. 

В окружение MSYS2 входит набор GNU-утилит. Это вспомогательные узкоспециализированные программы. Они дают доступ к функциям ОС. Также через них пользователь работает с файловой системой. Следующие команды из таблицы 2-1 выполняются GNU-утилитами:

* ls
* mount
* find
* grep

Часто различий между командами и утилитами не делают. Любой текст после приглашения командной строки называют командой.

#### pwd

Рассмотрим команды из таблицы 2-1. Мы только что запустили терминал. Первым делом узнаем текущий каталог. Терминал MSYS2 выводит его перед приглашением $. Этот вывод зависит от конфигурации терминала. Если вы работаете на ОС Linux или macOS, текущий каталог не выводится без дополнительной настройки.

После запуска терминала MSYS2 откроется домашний каталог текущего пользователя. Для сокращения он обозначается символом тильда ~. Этот символ вы видите перед приглашением командной строки. С сокращением ~ можно работать так же, как с любым абсолютным путём.

Чтобы вывести текущий каталог, выполните встроенную команду интерпретатора pwd. Иллюстрация 2-7 демонстрирует результат её выполнения. Команда вывела абсолютный путь до домашнего каталога пользователя: `/home/ilya.shpigor`.

Если к вызову pwd добавить **опцию** `-W`, команда выведет путь в структуре каталогов Windows. Это полезно, если вы создали файл в окружении MSYS2 и собираетесь открыть его в Windows-приложении. Результат вывода pwd с опцией `-W` приведён на иллюстрации 2-7.

{caption: "Иллюстрация 2-7. Вывод команды pwd"}
![Вывод pwd](images/BashShell/pwd-command.png)

Что такое опция команды? Если у приложения только текстовый интерфейс, способы взаимодействия с ним ограничены. При этом ему нужны входные данные для работы. Например, путь до файла или каталога. Командный интерпретатор предлагает простой способ передать эту информацию. Она указывается через пробел после команды запуска приложения. [**Параметром**](https://ru.wikipedia.org/wiki/Интерфейс_командной_строки#Формат_команды) или аргументом программы называются слово или символ, которые передаются ей на вход. **Опцией** или ключом называется аргумент, который переключает режим работы программы. Форма опций стандартизована. Обычно они начинаются с тире - или двойного тире --.

Встроенные команды интерпретатора вызываются так же как и программы. У них тоже есть параметры и опции.

Набирать длинные команды неудобно. Поэтому в Bash есть функция автодополнения. Она вызывается по нажатию клавиши Tab. Наберите первые буквы команды и нажимаете Tab. Если Bash сможет найти команду по первым буквам, он допишет её за вас.  Если несколько команд начинаются одинаково, автодополнение не произойдёт. В этом случае нажмите Tab повторно. Bash выведет список всех доступных команд.

Иллюстрация 2-8 демонстрирует список доступных команд. Bash вывел его после ввода текста `pw` и двойного нажатия Tab.

{caption: "Иллюстрация 2-8. Автодополнение для команды `pw`"}
![Автодополнение pw](images/BashShell/pw-autocompletion.png)

#### ls

После уточнения текущего каталога, будет полезно узнать его содержимое. Для этого воспользуйтесь утилитой ls. Её вывод для домашнего каталога `~` будет пустым, как в верхней части иллюстрации 2-9. Это значит, что каталог пуст.

{caption: "Иллюстрация 2-9. Вывод утилиты ls"}
![Вывод ls](images/BashShell/ls-command.png)

В Unix-окружении, как и в Windows есть скрытые файлы и каталоги. Они создаются ОС или приложениями для своих нужд. Например, это могут быть файлы с конфигурацией или временной информацией, нужной пока приложение работает. Пользователь не видит их в обычном режиме работы. Чтобы Проводник Windows стал отображать скрытые файлы, надо изменить [его настройки](https://support.microsoft.com/ru-ru/help/14201/windows-show-hidden-files).

В Unix-окружении имена скрытых файлов и каталогов начинаются с точки. В обычном режиме работы утилита ls их не отображает. Чтобы вывести их на экран, запустите утилиту с опцией `-a`. Тогда в домашнем кааталоге вы увидите восемь файлов, начинающихся с точки, как в нижней части иллюстрации 2-9.

Чтобы вывести содержимое каталога без перехода в него, передайте утилите ls его абсолютный или относительный путь в первом параметре. Иллюстрация 2-10 демонстрирует вывод команды `ls /`. Это содержимое корневого каталога.

{caption: "Иллюстрация 2-10. Вывод утилиты ls"}
![Вывод ls](images/BashShell/ls-root-command.png)

Обратите внимание, что в выводе утилиты нет каталогов `/c` и `/d`, которые упоминались в листинге 2-2. На самом деле они являются точками монтирования соответствующих дисков. В файловой системе Windows нет понятия точек монтирования. Поэтому каталоги `/c` и `/d` в ней отсутствуют. Они создаются только в окружении Unix, чтобы вы смогли перейти в корневые каталоги дисков `C` и `D`. Утилита ls читает содержимое каталогов в окружении Windows, поэтому эти точки монтирования не отображаются. В Linux и macOS такой проблемы нет: ls корректно выводит все точки монтирования.

#### mount

Когда к компьютеру подключено несколько дисков, может быть полезно вывести на экран их точки монтирования. Эту задачу выполняет утилита [mount](https://ru.wikipedia.org/wiki/Mount). Запустите её без параметров. Она выведет список точек монтирования как на иллюстрации 2-11.

{caption: "Иллюстрация 2-11. Вывод утилиты mount"}
![Результат mount](images/BashShell/mount-command.png)

Этот вывод надо рассматривать как таблицу, состоящую из четырёх столбцов. В первом указан диск, его раздел или просто каталог. Он смонтирован в корневую файловую систему. Второй столбец указывает точку монтирования. Это путь, по которому доступен смонтированный диск. В третьем столбце указан тип его файловой системы. Четвёртый столбец содержит параметры монтирования. Например, к параметрам относятся права доступа к диску: только для чтения или для чтения и записи.

Таблица 2-2 демонстрирует вывод утилиты mount с иллюстрации 2-11, разделённый на столбцы.

{caption: "Таблица 2-2. Вывод утилиты mount", width: "100%"}
| Монтируемый раздел | Точка монтирования | Тип ФС | Атрибуты доступа |
| --- | --- | --- | --- |
| `C:/msys64` | `/` | `ntfs` | `binary,noacl,auto` |
| `C:/msys64/usr/bin` | `/bin` | `ntfs` | `binary,noacl,auto` |
| `C:` | `/c` | `ntfs` | `binary,noacl,posix=0,user,noumount,auto` |
| `Z:` | `/z` | `hgfs` | `binary,noacl,posix=0,user,noumount,auto` |

Таблица 2-2 вызовет недоумение у Windows-пользователей. В качестве корневого каталога `/` в Unix-окружении монтируется каталог `C:/msys64`. Далее в него монтируются диски `C` и `Z` по путям `/c` и `/z`. Получается, что с точки зрения Unix-окружения диск `C` находится по пути `C:/msys64/c`. Но в файловой системе Windows зависимость обратная: `C:/msys64` является подкаталогом диска `C`. На самом деле это противоречие не вызывает проблем. Путь `/c` является точкой монтирования. Она существует только в Unix-окружении и отсутствует в Windows-окружении. Для простоты каталог `/c` можно рассматривать как ярлык для диска `C`.

Вывод утилиты mount занял много места на экране. Чтобы очистить окно терминала от текста, нажмите комбинацию клавиш Ctrl+L.

Бывает, что запущенная команда выполняется слишком долго или зависла. Чтобы прервать её выполнение, нажмите комбинацию клавиш Ctrl+C.

#### cd

Мы выяснили наше текущее местоположение в файловой системе. Теперь перейдём в нужный нам каталог. Для примера, мы ищем документацию по интерпретатору Bash. Попробуем её найти в системном каталоге `/usr`. В нём хранятся файлы установленных приложений. Для перехода в этот каталог наберите команду cd с параметром `/usr`:
{line-numbers: false, format: Bash}
```
cd /usr
```

Не забывайте про автодополнение. Оно работает как для имени команды, так и для её параметров. В нашем случае будет достаточно набрать `cd /u` и нажать клавишу Tab. Имя каталога `usr` будет добавлено автоматически. Результат выполнения команды приведён на иллюстрации 2-12.

{caption: "Иллюстрация 2-12. Результат выполнения команды `cd`"}
![Результат cd](images/BashShell/cd-command.png)

Команда cd ничего не выводит в случае успешного выполнения. При этом только меняется текущий каталог. Согласно выводу перед приглашением командной строки, теперь мы находимся в `/usr`.

Команда cd принимает на вход и абсолютные пути, и относительные. Относительные пути короче и быстрее в наборе. Поэтому они чаще используются при навигации по файловой системе.

Мы перешли в каталог `/usr`. Можно ли из него перейти на уровень выше в корневой каталог? Есть два способа это сделать: по абсолютному пути `/` и по специальному относительному пути `..`. Путь `..` всегда указывает на родительский каталог. Команда перехода по этому пути выглядит так:
{line-numbers: false, format: Bash}
```
cd ..
```

I> Кроме `..` в Bash есть еще один специальный путь `.`. Он означает текущий каталог. Если выполнить команду `cd .`, ничего не произойдёт. Вы останетесь по тому же пути, где и были. Путь `.` используется при запуске программ из текущего каталога.

Мы находимся в каталоге `/usr`. Выполним в нём утилиту ls. В её выводе есть каталог `share`. В нём находится подкаталог `doc` с документацией по установленным приложениям. Среди этих приложений есть интерпретатор Bash. Перейдём в каталог с его документацией по следующей команде:
{line-numbers: false, format: Bash}
```
cd share/doc/bash
```

Теперь нашим текущий каталогом стал `/usr/share/doc/bash`. Выполним в нём команду ls. Среди прочего она выведет файл с именем `README`. Это и есть документация по Bash, которую мы ищем. Выведите содержимое файла `README` на экран с помощью утилиты cat. Для этого выполните команду:
{line-numbers: false, format: Bash}
```
cat README
```

Иллюстрация 2-13 демонстрирует её результат.

{caption: "Иллюстрация 2-13. Вывод утилиты `cat`", height: "30%"}
![Результат cat](images/BashShell/cat-command.png)

I> Авторы некоторых руководств по Bash утверждают, что использовать утилиту cat для вывода содержимого файла неправильно. Её первоначальное назначение — объединять несколько файлов и выводить результат в стандартный поток вывода. Вместо вызова cat для одного файла они рекомендуют использовать перенаправление потоков, которое мы рассмотрим далее в этой главе. Согласно этой рекомендации, вывод содержимого файла на экран выглядит следующим образом:
{line-numbers: false, format: Bash}
```
echo "$(< README.txt)"
```

На иллюстрации 2-13 вы видите не весь файл `README`, а только его последние строки. Это произошло потому, что файл большой и вывод утилиты cat не поместился в окне терминала. Чтобы просмотреть его начало, воспользуйтесь полосой прокрутки в правой части окна. Так же для прокрутки [по страницам](https://en.wikipedia.org/wiki/Page_Up_and_Page_Down_keys) можно использовать горячие клавиши Shift+PageUp и Shift+PageDown, а по строкам — Shift+↑ и Shift+↓.

Каждая выполненная в терминале команда сохраняется в [истории команд](https://ru.wikipedia.org/wiki/History). Чтобы ввести предыдущую команду в терминал, нажмите стрелку вверх ↑. Историю команд можно прокручивать дальше стрелкой вверх. Так, например, вы найдёте первую команду, выполненную после запуска терминала. Для перехода к следующей команде в истории нажмите стрелку вниз ↓.

Например, вы только что ввели команду `cat README`. Чтобы её повторить, нажмите стрелку вверх и клавишу Enter.

Комбинация клавиш Ctrl+R вызывает поиск по истории. Нажмите Ctrl+R и начните набирать текст. Bash предложит вам последнюю введённую команду, которая начинается также. Чтобы исполнить её, просто нажмите Enter.

Для вывода на экран всей истории воспользуйтесь командой history.

В историю команд попадают только выполненные команды. В неё не попадают команды, которые вы набрали, а затем стёрли. Иногда в историю нужно сохранить команду, которая исполнится позже. Для этого применяйте трюком с комментарием. Любая команда, которая начинается с символа решётка `#`, обрабатывается Bash как комментарий. По нажатию Enter она попадёт в историю команд, но не исполнится. С этим трюком вызов утилиты cat станет таким:
{line-numbers: false, format: Bash}
```
#cat README
```

Теперь чтобы исполнить команду, найдите её в истории и сотрите символ решётка в начале.

В большинстве терминалов для трюка с комментарием назначена комбинация клавиш Alt+Shift+3. Работает она так:

1. Наберите команду, но не запускайте её.
2. Нажмите Alt+Shift+3.
3. Команда сохранится в истории без исполнения.

Что делать, если вам нужно скопировать текст из терминала? Например, часть файла `README` нужна в другом документе. Для копирования воспользуйтесь [**буфером обмена**](https://ru.wikipedia.org/wiki/Буфер_обмена). Это временное хранилище для строк. В нём можно сохранить выделенный в терминале текст, а затем вставить его в другое окно.

Для копирования текста из терминала выполните следующее:

1. Выделите мышью нужный текст. Для этого зажмите левую кнопку мыши и проведите курсором по тексту.

2. Для вставки текста из буфера обмена в окно терминала нажмите среднюю кнопку мыши. Текст будет вставлен в текущую позицию курсора.

3. Для вставки текста в другое приложение нажмите правую кнопку мыши и выберите пункт "Вставить".

#### find

Искать нужный файл или каталог вручную с помощью команд cd и ls неудобно. Вместо них для быстрого поиска используйте утилиту find.

Утилита find, запущенная без параметров, выводит содержимое текущего каталога и его подкаталогов. В её вывод попадут и скрытые объекты. Иллюстрация 2-14 демонстрирует результат выполнения find для домашнего каталога пользователя `~`.

{caption: "Иллюстрация 2-14. Результат работы утилиты find", height: "30%"}
![Результат find](images/BashShell/find-command.png)

Утилите find можно указать каталог, содержимое которого надо обработать. Относительный или абсолютный путь до него указывается в первом параметре утилиты. Например, команда для обработки корневого каталога с помощью find выглядит так:
{line-numbers: false, format: Bash}
```
find /
```

Следующие далее параметры утилиты представляют собой условия. Если строка в выводе утилиты find не удовлетворяет этим условиям, она не попадает на экран. Условия сочетаются друг с другом и составляют единое выражение. Для обработки этого выражения в утилиту встроен собственный небольшой интерпретатор.

Например, условием для утилиты find может быть имя файла. Тогда в её вывод попадут только файлы с указанным именем. Все остальные будут отброшены.

Таблица 2-3 демонстрирует часто используемые условия утилиты find.

{caption: "Таблица 2-3. Часто используемые условия утилиты find", width: "100%"}
| Условие | Значение | Пример |
| --- | --- | --- |
| `-type f` | Искать только файлы. | `find -type f` |
|  | | |
| `-type d` | Искать только каталоги. | `find -type d` |
|  | | |
| `-name шаблон` | [**Шаблон имени**](https://ru.wikipedia.org/wiki/Шаблон_поиска) файла или каталога, | `find -name README` |
| | чувствительный к регистру. | `find -name READ*` |
| | | `find -name READ??` |
|  | | |
| `-iname шаблон` | Шаблон имени файла или каталога, нечувствительный к регистру. | `find -iname readme` |
|  | | |
| `-path шаблон` | Шаблон пути к файлу или каталогу, чувствительный к регистру. | `find -path */doc/bash/*` |
|  | | |
| `-ipath шаблон` | Шаблон пути к файлу или каталогу, нечувствительный к регистру. | `find . -ipath */DOC/BASH/*` |
|  | | |
| `-a` или `-and` | Скомбинировать несколько условий с помощью логического И. В вывод попадут только файлы и каталоги, удовлетворяющие всем скомбинированным условиям. | `find -name README -a -path */doc/bash/* ` |
|  | | |
| `-o` или `-or` | Скомбинировать несколько условий с помощью логического ИЛИ. Если файл или каталог соответствует хотя бы одному условию, он попадёт в вывод. | `find -name README -o -path */doc/bash/* ` |
|  | | |
| `!` или `-not` | Логическое отрицание (НЕ) | `find -not -name README` |
| | последующего условия. В вывод попадут только файлы и каталоги, которые не удовлетворяют условию. | `find ! -name README` |

Шаблоном называется поисковый запрос, в который вместе с обычными символами входят [**символы подстановки**](https://ru.wikipedia.org/wiki/Символ_подстановки) (wildcard character). Всего в Bash есть три таких символа: `*`, `?` и `[`. Звёздочка означает любое количество любых символов. Знак вопроса — один любой символ. Например, строка `README` будет соответствовать следующим шаблонам: `*ME`, `READM?`, `*M?`, `R*M?`.

Кроме `*` и `?` можно указывать наборы символов, которые ожидаются в определённой позиции строки. Например, шаблон `[cb]at.txt` будет соответствовать обоим файлам `cat.txt` и `bat.txt`. Применим этот шаблон имени файла в условии утилиты find следующим образом:
{line-numbers: false, format: Bash}
```
find . -name "[cb]at.txt"
```

{caption: "Упражнение 2-1. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону "*ME.??" ?

* 00_README.txt
* README
* README.md
```

{caption: "Упражнение 2-2. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону "*/doc?openssl*" ?

* /usr/share/doc/openssl/IPAddressChoice_new.html
* /usr/share/doc_openssl/IPAddressChoice_new.html
* doc/openssl
* /doc/openssl
```

Рассмотрим примеры условий утилиты find с шаблонами. Вернёмся к задаче поиска документации по Bash. Попробуем найти файл `README` с ней не вручную, а с помощью find. Предположим, что мы не знаем, на каком диске находится этот файл. Тогда первым параметром передадим утилите корневой каталог. В результате она будет искать файл на всех смонтированных дисках. Далее учтём, что в Unix-окружении документы хранятся в каталогах с именем `doc`. Учитывая это, напишем следующую команду для поиска:
{line-numbers: false, format: Bash}
```
find / -path */doc/*
```

Она выведет список всех файлов с документацией на всех смонтированных дисках. Этот список слишком длинный. Его нужно сократить с помощью дополнительных условий поиска. Добавим в предполагаемый путь искомого файла строку `bash`. Получится следующая команда:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -path */bash/*
```

Её результат приведён на иллюстрации 2-15. Эта команда эквивалентна такой:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -a -path */bash/*
```

Если между условиями не указывать логическую операцию (И, ИЛИ), по умолчанию будет использоваться И.

{caption: "Иллюстрация 2-15. Результат работы утилиты find", height: "30%"}
![Результат find](images/BashShell/find-path-path.png)

В конце вывода утилита find сообщает об ошибке. Проблема в том, что некоторые подкаталоги `/` являются точками монтирования Windows-дисков (например, `/c` для `C:`). Утилита find не может получить доступ к их содержимому при вызове её из корневого каталога. Чтобы избежать этой проблемы, начните поиск с точки монтирования диска `C:`:
{line-numbers: false, format: Bash}
```
find /c -path */doc/* -a -path */bash/*
```

Альтернативное решение — исключить точки монтирования из поиска с помощью параметра `-mount`:
{line-numbers: false, format: Bash}
```
find / -mount -path */doc/* -a -path */bash/*
```

В результате мы получим относительно небольшой список документов, среди которых легко найти нужный нам `README` файл.

Мы могли бы следовать другой стратегии поиска. Предположим, что нам известно имя искомого файла. Тогда его можно указать вместе с предполагаемым путём:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README
```

Иллюстрация 2-16 демонстрирует результат такого поиска.

{caption: "Иллюстрация 2-16. Результат работы утилиты find", height: "30%"}
![Результат find](images/BashShell/find-path-name.png)

Мы снова получили относительно небольшой список, в котором легко найти `README` файл с документацией по Bash.

Условия утилиты find можно группировать. Для этого используйте [экранированные](https://ru.wikipedia.org/wiki/Экранирование_символов) скобки. Например, следующая команда ищет файлы `README` с путём `*/doc/*` или файлы `LICENSE` с произвольным путём.
{line-numbers: false, format: Bash}
```
find / \( -path */doc/* -name README \) -o -name LICENSE
```

Почему скобки, передаваемые в утилиту find, должны экранироваться обратным слэшем? Дело в том, что скобки является частью синтаксиса Bash. Они используются в конструкциях языка. Встретив их в вызове утилиты, Bash выполнит **подстановку** (или замену) скобок и их содержимого на что-то другое. С помощью экранирования мы сообщаем интерпретатору, что эти символы должны передаваться в утилиту как есть, без какой-либо замены.

Утилита find используется не только для поиска, но и для обработки файлов или каталогов. Последний параметр утилиты задаёт действие. Это действие будет применено к каждому из найденных файлов и каталогов.

Таблица 2-4 демонстрирует опции для указания действий.

{caption: "Таблица 2-4. Опции для указания действий над найденными файлами и каталогами", width: "100%"}
| Опция | Значение | Пример |
| --- | --- | --- |
| `-exec команда {} \;`| Выполнить указанную команду над каждым из найденных файлов или каталогов. | `find -name README -type f -exec cp {} ~ \;` |
|  | | |
| `-exec команда {} +`| Выполнить указанную команду один раз над всеми найденными файлами или каталогами. То есть они будут переданы на вход этой команды. | ` find -type d -exec cp -t ~ {} +` |
|  | | |
| `-delete`| Удалить каждый из найденных файлов. При этом каталоги будут удаляться, только если они пустые. | `find -name README -type f -delete` |

I> Действие `-exec` с `{} +` на конце допустимо указывать только для команд, поддерживающих несколько параметров. Большинство GNU-утилит их поддерживает. В противном случае команда обработает только первый файл или каталог, найденный утилитой find.

Рассмотрим пример использования действия `-exec`. Часто возникает задача копирования найденного файла в другое место. Предположим, что нам надо скопировать все файлы документации по Bash с **расширением** HTML в домашний каталог. Начнём с поиска этих файлов. Команда вызова утилиты find для поиска выглядит так:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html"
```

I> При передаче шаблонов в утилиту find заключайте их в двойные кавычки `"`. Они выполняют ту же функцию, что и обратный слэш, экранирующий скобки. Таким образом мы указываем Bash, что он не должен интерпретировать шаблоны сам, то есть выполнять подстановку. Вместо этого он должен передавать их вызываемой утилите.

Результат поиска HTML документов представлен на иллюстрации 2-17.

{caption: "Иллюстрация 2-17. Результат работы утилиты find", height: "30%"}
![Результат find](images/BashShell/find-html.png)

Добавим к команде поиска параметр `-exec`. С его помощью будем вызывать утилиту `cp`. Эта утилита копирует файлы и каталоги в указанный путь. В первом параметре cp принимает то, что надо скопировать. Во втором параметре — цель, куда копировать. После добавления действия вызов утилиты find выглядит следующим образом:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cp {} ~ \;
```

Эта команда ничего не выведет в терминал, кроме уже знакомой нам ошибки с точками монтирования.

Что сделала команда? Для каждого найденного HTML файла (см. иллюстрацию 2-17) вызывалась утилита cp. В неё первым параметром вместо скобок `{}` передавался путь до найденного HTML файла. Поскольку найдено было два файла, произошло только два вызова утилиты `cp`. Они выглядели так:
{line-numbers: true, format: Bash}
```
cp ./usr/share/doc/bash/bash.html ~
cp ./usr/share/doc/bash/bashref.html ~
```

Каждый вызов копирует HTML файл в домашний каталог пользователя.

Только что мы написали нашу первую программу на языке интерпретатора утилиты find. Она работает по следующему алгоритму:

1. Найти файлы с расширением HTML, хранящиеся в корневом каталоге. Их пути должны соответствовать шаблону `*/doc/bash/*`.

2. Скопировать каждый из найденных файлов в каталог пользователя.

Программа состоит всего из двух действий. Но она окажется полезной, если вам нужно обработать много файлов. Просто представьте, сколько времени вы бы потратили на эту задачу, если бы работали с Проводником Windows.

Действия `-exec` можно комбинировать точно так же как и условия поиска. Предположим, что надо вывести содержимое каждого из найденных HTML файлов и подсчитать количество строк в них. Для вывода содержимого воспользуемся утилитой cat. Для подсчёта строк применим утилиту wc с опцией `-l`. На вход она принимает имя файла, который надо обработать. Команда вызова find в этом случае выглядит так:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cat {} \; -exec wc -l {} \;
```

Здесь между действиями `-exec` логическая операция не указана. По умолчанию используется `-a` или логическое И. Это означает, что второе действие будет выполнено только при успешном исполнении первого. Мы можем заменить логическую операцию на ИЛИ. Тогда второе действие будет выполняться всегда, независимо от результата первого.

Действия `-exec` можно группировать с помощью экранированных скобок `\(` и `\)` точно так же как и условия поиска.

{caption: "Упражнение 2-3. Поиск файлов утилитой find", line-numbers: false}
```
Напишите команду вызова find для поиска текстовых файлов в Unix-окружении.
Дополните команду, чтобы вывести общее число строк в этих файлах.
```

#### Логические выражения

Комбинация условий утилиты find представляет собой [**логическое выражение**](https://ru.wikipedia.org/wiki/Логическое_выражение). Логическим выражением называется конструкция языка программирования. Результатом её вычисления может быть одно из двух значений: "истина" или "ложь". Условия поиска в find — это конструкция встроенного в утилиту интерпретатора. Каждое условие может выполняться, тогда результатом его вычисления будет "истина". Если условие не выполняется, его результат — "ложь". Если вы указываете только одно условие для поиска, его уже можно считать логическим выражением.

Мы сталкивались с алгеброй логики, когда обсуждали двоичную систему счисления. Этот раздел математики изучает [**логические операции**](https://ru.wikipedia.org/wiki/Логическая_операция). Они отличаются от знакомых нам из арифметики сложения, вычитания, умножения и деления. Дело в том, что логические выражения принимают только два значения. Поэтому арифметические действия над ними становятся тривиальными и ничего не дают. Если же применить к этим выражениям логические операции, можно составлять условия со строгими правилами вывода результата. Например, в случае утилиты find можно составить условие для поиска файла с определённым именем и находящегося по определённому пути. Комбинация таких условий с действиями позволит получить сложное поведение программы.

Выражения, над которыми выполняется логическая операция, называются **операндами**.

Разберём логические выражения на более общем примере, не связанном с утилитой find. Представьте, что мы программируем робота для склада. Он должен перевозить коробки из точки А в точку Б. Для такой простой задачи, можно задать ему следующий прямолинейный алгоритм:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Двигайся в точку Б.

4. Положи коробку в точке Б.

В этом алгоритме нет никаких условий. Это значит, что робот будет выполнять каждый его шаг независимо от каких-либо внешних событий. Теперь представьте, что произойдёт, если на пути робота в точку Б окажется погрузчик. В этом случае исполнение алгоритма приведёт к столкновению. Чтобы его избежать, нам понадобится условие:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Если нет препятствия, двигайся в точку Б. Иначе остановись.

4. Положи коробку в точке Б.

Третий шаг алгоритма называется [**условным оператором**](https://ru.wikipedia.org/wiki/Ветвление_(программирование)). Такая конструкция есть во многих современных языках программирования. В общем виде алгоритм работы условного оператора можно записать так:

1. Вычислить значение логического выражения.

2. Если выражение истинно, выполнить первое указанное действие.

3. Если выражение ложно, выполнить второе указанное действие.

В нашем случае робот вычисляет значение логического выражения "нет препятствия". Если препятствие есть, выражение будет ложно и робот остановится. В противном случае он продолжит движение.

Логические операции позволяют скомбинировать несколько выражений. Например, робот пробует взять коробку в точке А, но её там нет. Тогда ему нет смысла двигаться в точку Б. Мы можем добавить это новое условие к уже существующему выражению с помощью операции [**логического И**](https://ru.wikipedia.org/wiki/Конъюнкция) (конъюнкция). С новым выражением наш алгоритм станет выглядеть так:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Если есть коробка И нет препятствия, двигайся в точку Б. Иначе остановись.

4. Положи коробку в точке Б.

Результат операции логического И будет истинным тогда, когда оба условия истинны. То есть у робота есть коробка и нет препятствия. В любом другом случае выражение будет ложным, и робот остановится.

Работая с утилитой find, мы столкнулись с ещё двумя логическими операциями: [**ИЛИ**](https://ru.wikipedia.org/wiki/Дизъюнкция) (дизъюнкция) и [**НЕ**](https://ru.wikipedia.org/wiki/Отрицание) (отрицание). На самом деле в нашем алгоритме для робота мы уже применили НЕ, когда написали выражение "нет препятствия". Это ничто иное как отрицание: "НЕ есть препятствие". Перепишем наш алгоритм более формально:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Если есть коробка И НЕ есть препятствие, двигайся в точку Б. Иначе остановись.

4. Положи коробку в точке Б.

В логическом выражении операцию И можно заменить на ИЛИ. Чтобы поведение робота не изменилось, добавим отрицание к первому условию и уберём его у второго. Также поменяем порядок действий. Теперь если выражение будет истинным, робот остановится. Если ложным, продолжит движение к точке Б. В итоге получим следующий алгоритм:

1. Двигайся в точку А.

2. Возьми коробку в точке А.

3. Если НЕ есть коробка ИЛИ есть препятствие, остановись. Иначе двигайся в точку Б.

4. Положи коробку в точке Б.

Прочитайте внимательно новое выражение. Логика робота нисколько не изменилась. Он по-прежнему остановится, если у него нет коробки или на пути возникло препятствие.

В нашем примере логическое выражение записано в виде предложения на русском языке. Это предложение звучит неестественно и его надо прочитать несколько раз, чтобы понять. Причина в том, что естественный язык (язык общения людей) плохо подходит для описания логических выражений. Он недостаточно точен. Поэтому в алгебре логики применяется математическая запись.

Кроме рассмотренных нами логических И, ИЛИ, НЕ в программировании широко распространены ещё три операции: **эквивалентность**, **не эквивалентность**, **исключающее ИЛИ**. Они описаны в таблице 2-5.

{caption: "Таблица 2-5. Логические операции в программировании", width: "100%"}
| Операция | Значение выражения |
| --- | --- |
| И (AND) | Истинно, когда оба операнда истинны. |
|  | |
| ИЛИ (OR) | Истинно, когда любой из операндов истинен. Ложно, когда все операнды ложны. |
|  | |
| НЕ (NOT) | Истинно, когда операнд ложен и наоборот. |
|  | |
| Исключающее ИЛИ (XOR) | Истинно, когда значения операндов отличаются (истина-ложь или ложь-истина). Ложно, когда они совпадают (истина-истина, ложь-ложь). |
|  | |
| Эквивалентность | Истинно, когда значения операндов совпадают. |
|  | |
| Не эквивалентность | Истинно, когда значения операндов отличаются. |

Постарайтесь запомнить эту таблицу. При частом использовании логических операций это будет совсем несложно.

#### grep

Утилита grep — это альтернативный инструмент поиска. Она ищет файлы по их содержимому.

Когда вам надо найти файл или каталог по его имени, пути или [**метаданным**](https://ru.wikipedia.org/wiki/Метаданные), используйте утилиту find. Метаданными называется дополнительная информация об объекте файловой системы. Например, размер, время создания и последней модификации, права доступа. Если же вы не знаете об искомом файле ничего кроме встречающихся в нём слов, используйте grep.

Пример поможет нам лучше понять, когда стоит использовать утилиту grep, а когда find. Представьте, что вы ищете файл с документацией, в котором встречается фраза "free software" (свободное ПО). Если мы выберем для поиска утилиту find, нам придётся сделать следующее:

1. Найти все файлы документации с именем `README` с помощью find.

2. Открыть каждый файл в текстовом редакторе и найти в нём фразу "free software".

Ручная проверка содержимого файлов займёт много времени. Утилита grep позволяет автоматизировать подобные задачи.

Чтобы найти текст в конкретном файле, запустите grep со следующими параметрами:
{line-numbers: false, format: Bash}
```
grep "free software" /usr/share/doc/bash/README
```

Первым параметром указывается строка для поиска. В нашем случае это "free software". Не забывайте про двойные кавычки. С их помощью мы сообщаем Bash, что оба слова должны попасть в первый параметр утилиты. Без кавычек фраза будет разделена пробелом на два параметра. Этот механизм разделения строк на слова в Bash называется [**word splitting**](http://mywiki.wooledge.org/WordSplitting).

Вторым параметром в утилиту grep передаётся относительный или абсолютный путь к обрабатываемому файлу. Можно указать сразу несколько путей. Они должны разделяться пробелами. В нашем примере передаётся один путь до файла `README` с документацией по Bash.

Результат работы утилиты grep приведён на иллюстрации 2-18.

{caption: "Иллюстрация 2-18. Результат вызова утилиты grep", width: "100%"}
![Результат grep](images/BashShell/grep-command.png)

Утилита выводит на экран все строки файла, в которых встречается искомая фраза. В этот вывод можно добавить номера строк. Для этого добавьте опцию `-n` перед первым параметром утилиты. Результат такого вызова приведён в нижней части иллюстрации 2-18.

Мы выяснили, как с помощью grep найти фразу или слово в указанных файлах. Теперь применим утилиту для поиска файлов по их содержимому. Она может решить эту задачу двумя способами.

В первом способе применяется функция Bash для разворачивания шаблона имени файла. Предположим, что в домашнем каталоге пользователя находятся два текстовых файла: `bash.txt` и `xz.txt`. Это копии `README` документов программ Bash и xz. Нам нужно найти тот файл, в котором встречается фраза "free software". Это можно сделать следующими двумя командами:
{line-numbers: true, format: Bash}
```
cd ~
grep "free software" *
```

Сначала мы перешли в домашний каталог пользователя. Затем вызвали утилиту grep. В качестве пути до целевого файла мы указали символ подстановки — звёздочку. Это шаблон поиска, означающий любую строку. Bash выполнит подстановку перед запуском утилиты grep. Вместо шаблона в команду будет подставлен список всех файлов, имена которых ему соответствуют. В результате команда запуска grep будет выглядеть так:
{line-numbers: false, format: Bash}
```
grep "free software" bash.txt xz.txt
```

Попробуйте оба варианта вызова grep: с шаблоном `*` и с явным указанием списка файлов. Вы получите одинаковый результат.

Тот же самый поиск можно выполнить одной командой. Для этого добавьте к шаблону путь до домашнего каталога пользователя. Получится такой вызов:
{line-numbers: false, format: Bash}
```
grep "free software" ~/*
```

I> С помощью команды `echo` можно вывести на экран результат разворачивания шаблонов Bash:
{line-numbers: true, format: Bash}
```
echo *
echo ~/*
```

Шаблоны Bash нельзя заключать в двойные кавычки. Например так:
{line-numbers: false, format: Bash}
```
grep "free software" "*"
```

В этом случае Bash не развернёт шаблон, а передаст его как есть утилите grep. Она в отличие от find не умеет самостоятельно разворачивать шаблон. Поэтому его обработка закончится ошибкой, как на иллюстрации 2-19.

{caption: "Иллюстрация 2-19. Результат обработки шаблона в grep", width: "100%"}
![Результат grep](images/BashShell/grep-error.png)

I> Bash не включает скрытые файлы и каталоги в подстановку шаблона `*`. В нашем примере это означает, что утилита grep не получит их на вход. Чтобы искать по скрытым файлам, используйте шаблон `.*`. Можно указывать его и `*` одновременно, чтобы искать по всем файлам разом. Например так:
{line-numbers: false, format: Bash}
```
grep "free software" * .*
```

Во втором способе поиска файлов используется функция утилиты grep. Она перебирает все файлы в указанном каталоге. Эта функция включается опцией `-r`. При её использовании последним параметром нужно указать путь к каталогу. Для решения нашего примера команда будет выглядеть так:
{line-numbers: false, format: Bash}
```
grep -r "free software" .
```

В результате утилита grep будет искать фразу "free software" во всех файлах текущего каталога. Она не будет проходить по его подкаталогам. Для поиска в подкаталогах используйте опцию `-R`. Например так:
{line-numbers: false, format: Bash}
```
grep -R "free software" .
```

Целевой каталог для поиска можно указывать как по относительному, так и по абсолютному пути. Например:
{line-numbers: true, format: Bash}
```
cd /home
grep -R "free software" ilya.shpigor/tmp
grep -R "free software" /home/ilya.shpigor/tmp
```

Утилита grep, запущенная с опциями `-r` и `-R`, корректно обработает скрытые файлы и каталоги.

Предположим, что нас не интересуют конкретные места файлов, в которых встречается фраза "free software". Мы хотим просто получить список файлов, где эта фраза встречается хотя бы один раз. Чтобы получить такой вывод, воспользуйтесь опцией `-l`. Например:
{line-numbers: false, format: Bash}
```
grep -Rl "free software" .
```

Результат выполнения этой команды приведён на иллюстрации 2-20.

{caption: "Иллюстрация 2-20. Результат вывода только имён файлов"}
![Результат grep](images/BashShell/grep-files.png)

Мы получили список файлов, в которых фраза встречается. Допустим, что нам нужен противоположный результат — список файлов, где фразы нет. Для такого поиска используйте опцию `-L`. Например так:
{line-numbers: false, format: Bash}
```
grep -RL "free software" .
```

Файлы с исходным кодом программ являются текстовыми. Поэтому утилита grep отлично подходит для поиска по ним.

Возможно, вы нашли утилиту grep удобной. Вам захочется применить её для поиска документов в формате [PDF](https://ru.wikipedia.org/wiki/Portable_Document_Format) и MS Office. К сожалению, это не сработает. Формат этих файлов не текстовый. То есть содержащиеся в них данные закодированы. Чтобы искать такие файлы по их содержимому, вам надо установить одну из дополнительных утилит. Они кратко описаны в таблице 2-6.

{caption: "Таблица 2-6. Утилиты для работы с PDF и MS Office файлами", width: "100%"}
| Утилита | Функции |
| --- | --- |
| [pdftotext](http://www.xpdfreader.com) | Конвертирует PDF-файл в текстовый формат. |
|  | |
| [pdfgrep](https://pdfgrep.org) | Ищет PDF-файл по его содержанию. |
|  | |
| [antiword](http://www.winfield.demon.nl) | Конвертирует файл MS Office в текстовый формат. |
|  | |
| [catdoc](https://www.wagner.pp.ru/~vitus/software/catdoc) | Конвертирует файл MS Office в текстовый формат. |
|  | |
| [xdoc2txt](https://documentation.help/xdoc2txt/xdoc2txt_en.html) | Конвертирует файлы PDF и MS Office в текстовый формат. |

Некоторые из этих утилит можно установить в Unix-окружение MSYS2 с помощью пакетного менеджера pacman. Мы рассмотрим его в последней главе.

{caption: "Упражнение 2-4. Поиск файлов утилитой grep", line-numbers: false}
```
Напишите вызов утилиты grep для поиска системных утилит со свободной лицензией.
Для открытого ПО предпочитают следующие лицензии:

1. GNU General Public License
2. MIT license
3. Apache license
4. BSD license
```
