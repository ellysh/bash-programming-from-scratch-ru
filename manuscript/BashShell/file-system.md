## Навигация по файловой системе

Знакомство с Unix-окружением и Bash начнём с [**файловой системы**](https://ru.wikipedia.org/wiki/Файловая_система) (ФС). Файловой системой называется способ хранения и чтения информации с дисков. Сначала рассмотрим, чем отличается структура каталогов Unix от стандарта, принятого в семействе ОС Windows. Затем познакомимся с Bash-командами для навигации по файловой системе.

### Структура каталогов

В верхней части окна Windows Проводника находится адресная строка. В ней выводится абсолютный путь к открытому в Проводнике каталогу. В терминологии Windows каталоги называются [**папками**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Термин_«Папка»). Оба термина обозначают один и тот же объект файловой системы. Пример адресной строки приведён на иллюстрации 2-6. В окне Проводника открыт путь `This PC > Local Disk (C:) > msys64`. Он соответствует каталогу `msys64` на диске `C`. Обычно буквой `C` обозначается локальный системный диск. Локальный означает физически подключённый к компьютеру. Системный — на него установлена система Windows. Если перевести путь из адресной строки Проводника в абсолютный путь, получим `C:\msys64`.

{caption: "Иллюстрация 2-6. Окно Проводника Windows"}
![Окно Проводника Windows](images/BashShell/explorer.png)

В окне терминала, как и в адресной строке Проводника, выводится текущий абсолютный путь. Но пути в терминале и Проводнике различаются. Причина в том, что структура каталогов в Unix-окружении не такая, как в Windows.

В Windows каждому диску соответствует буква латинского алфавита. Диск можно открыть в Проводнике, как и обычную папку, и получить доступ к её содержимому. Для примера рассмотрим содержимое системного диска `C`. На нём Windows в процессе установки создаёт [стандартный набор каталогов](https://en.wikipedia.org/wiki/Directory_structure#Windows_10): `Windows`, `Program Files`, `Program Files (x86)`, `Users`, `PerfLogs`. Эти каталоги нужны для размещения компонентов ОС и их временных файлов. Кроме системного диска к компьютеру могут подключаться дополнительные. Они обозначаются буквами латинского алфавита: `D`, `E`, `F` и т. д. На них пользователь создаёт произвольную структуру каталогов.

Структура каталогов Windows определяется файловой системой [File Allocation Table](https://ru.wikipedia.org/wiki/FAT) (FAT). Изначально компания Microsoft разрабатывала её для ОС [MS-DOS](https://ru.wikipedia.org/wiki/MS-DOS). Впоследствии принципы работы FAT легли в основу стандарта [ECMA-107](http://www.ecma-international.org/publications/standards/Ecma-107.htm). В современных версиях Windows файловая система [NTFS](https://ru.wikipedia.org/wiki/NTFS) сменила устаревшую FAT. Но организация дисков и каталогов в ней не изменилась.

Структура каталогов Unix следует [стандарту POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap10.html#tag_10). Согласно этому стандарту, в системе есть каталог самого верхнего уровня. Он называется [**корневым каталогом**](https://ru.wikipedia.org/wiki/Каталог_(файловая_система)#Корневой_каталог) и обозначается символом слэш `/`. Все каталоги и файлы всех подключенных к компьютеру дисков находятся внутри корневого каталога.

Чтобы получить доступ к содержимому диска, его сначала надо смонтировать. **Монтированием** называется встраивание содержимого диска в корневой каталог системы. Путь по которому становится доступно содержимое диска называется его [**точкой монтирования**](https://ru.wikipedia.org/wiki/Точка_монтирования). Перейдя по этому пути, вы окажетесь в файловой системе диска. Все точки монтирования находятся внутри корневого каталога.

Рассмотрим пример. Предположим, что к компьютеру с системой Windows подключены два локальных диска. Они обозначены буквами `C` и `D`. Тогда структура каталогов первого уровня иерархии выглядит так, как демонстрирует листинг 2-1.

{caption: "Листинг 2-1. Структура каталогов первого уровня в ОС Windows", line-numbers: false}
```
C:\
    PerfLogs\
    Windows\
    Program Files\
    Program Files (x86)\
    Users\

D:\
    Documents\
    Install\
```

В Unix эта же иерархия каталогов будет выглядеть иначе. Её демонстрирует листинг 2-2.

{caption: "Листинг 2-2. Структура каталогов в ОС Unix", line-numbers: false}
```
/
    c/
        PerfLogs/
        Windows/
        Program Files/
        Program Files (x86)/
        Users/

    d/
        Documents/
        Install/
```

Как только вы запускаете терминал MSYS2, вы попадаете в Unix-окружение. В нём все Windows-пути становятся недействительными. Вместо них надо использовать Unix-пути. Например, каталог `C:\Windows` теперь доступен по пути `/c/Windows`.

POSIX-совместимые системы [чувствительности к регистру символов](https://ru.wikipedia.org/wiki/Чувствительность_к_регистру_символов). Это означает, что в них строки `Documents` и `documents` не равны. В Windows чувствительности к регистру нет. Поэтому в адресной строке Проводника можно написать путь `c:\windows` и перейти в системный каталог `c:\Windows`. В Unix-окружении это не сработает. Вам придётся вводить все символы в правильном регистре. Также обратите внимание, что в Unix-окружении в качестве разделителя между именами каталогов и файлов используется символ слэш `/`. В Windows для этой цели используется обратный слэш `\`.

### Команды навигации по файловой системе

Как выполнить команду в эмуляторе терминала? Для этого переключитесь на его окно, наберите текст команды и нажмите клавишу Enter. Однако, оболочка не обработает ваш ввод, если занята выполнением введённой ранее команды. Когда она снова будет готова к вводу, на экран будет выведено **приглашение командной строки**. Приглашение — это специальный символ или строка символов. Вывод приглашения означает, что оболочка готова обработать ввод пользователя. На иллюстрации 2-4 в качестве приглашения используется символ доллара `$`. Увидев его в последней строке эмулятора терминала MSYS2, смело вводите следующую команду.

Для навигации по файловой системе Проводник Windows предлагает следующие возможности:

1. Вывод текущего каталога.
2. Переход в указанный каталог.
3. Поиск каталога или файла на диске.

Эти же действия можно выполнить через интерфейс командной строки. Каждому из них соответствует специальная команда. Эти команды приведены в таблице 2-1.

{caption: "Таблица 2-1. Команды и утилиты для навигации по файловой системе", width: "100%"}
| Команда | Описание | Примеры |
| --- | --- | --- |
| `ls` | Вывести на экран содержимое указанного каталога. Если | `ls` |
| | каталог не указан, будет выведено содержимое текущего. | `ls /c/Windows` |
|  | | |
| `pwd` | Вывести на экран путь до текущего каталога. Ключ комнды `-W` | `pwd` |
| | выводит путь в структуре каталогов Windows | `pwd -W` |
|  | | |
| `cd` | Перейти в указанный каталог по относительному или | `cd tmp` |
| | абсолютному пути. | `cd /c/Windows` |
| | | `cd ..` |
|  | | |
| `mount` | Смонтировать указанный диск в корневую файловую систему. При запуске без параметров выводит список всех смонтированных дисков. | `mount` |
|  | | |
| `find` | Найти указанный файл или каталог. Первым | `find . -name vim` |
| | параметром команды указывается каталог, начиная с которого будет вестись поиск. Если он не указан, используется текущий каталог. | `find /c/Windows -name *vim*` |
|  | | |
| `grep` | Найти файл по его содержимому. | `grep "PATH" *` |
| | | `grep -Rn "PATH" .` |
| | | `grep "PATH" * .*` |

Некоторые команды из таблицы 2-1 оболочка Bash выполняет самостоятельно. Они называются [**встроенными в интерпретатор**](https://ru.wikipedia.org/wiki/Bash#Внутренние_команды). Если вы введёте команду и Bash не сможет её выполнить сам, он постарается найти подходящую утилиту или программу. Следующие команды из таблицы 2-1 являются встроенными:

1. pwd
2. cd

В Unix-окружение MSYS2 входит набор GNU утилит. Это вспомогательные узкоспециализированные программы. Они предназначены для доступа к функциям ОС. С их помощью можно получить доступ к файловой системе. Следующие команды из таблицы 2-1 выполняются GNU утилитами:

1. ls
2. mount
3. find
4. grep

Для простоты мы будем называть командой текст, который вводится после приглашения командной строки. При этом неважно выполняет ли команду интерпретатор или утилита.

#### pwd

Рассмотрим каждую из команд таблицы 2-1. Мы только что запустили терминал. Первым делом полезно уточнить наш текущий каталог. Терминал MSYS2 выводит эту информацию перед приглашением `$`. Этот вывод зависит от конфигурации терминала. Если вы работаете на ОС Linux или macOS, текущий каталог без дополнительной настройки не выводится.

Сразу после запуска терминала MSYS2 вы окажетесь в домашнем каталоге пользователя. Терминал выводит его путь как `~` перед приглашением командной строки `$`. Это сокращённое обозначение абсолютного пути домашнего каталога текущего пользователя. С этим сокращением можно работать точно так же, как и с любым другим абсолютным путём.

Чтобы вывести текущий каталог, выполните встроенную команду интерпретатора pwd. Пример её выполнения приведён в верхней части иллюстрации 2-7. Команда напечатала абсолютный путь до домашнего каталога пользователя: `/home/ilya.shpigor`.

Если к вызову команды pwd добавить **опцию** `-W`, то текущий путь будет выведен в структуре каталогов Windows. Это полезно, если вы создали какие-то файлы в окружении MSYS2 и хотите открыть их в Windows-приложении. Результат использования опции `-W` приведён в нижней части иллюстрации 2-7.

{caption: "Иллюстрация 2-7. Вывод команды pwd"}
![Вывод pwd](images/BashShell/pwd-command.png)

Что такое опция `-W`, которую мы передали команде pwd? При работе с интерфейсом командной строки пользователь ограничен в средствах взаимодействия с запускаемым приложением. Удобнее всего устанавливать режим работы приложения в момент его запуска. Также для его работы может понадобиться дополнительная информация (например, путь до файла или каталога). Командный интерпретатор предлагает простой способ передать эту информацию приложению. Для этого надо добавить её через пробел после команды запуска приложения.

[**Параметром**](https://ru.wikipedia.org/wiki/Интерфейс_командной_строки#Формат_команды) или аргументом программы называются слово или символ, которые передаются ей на вход. **Опцией** или ключом называется аргумент в стандартизированной форме (начинается с `-` или `--`), который переключает режим работы программы. 

Встроенные команды интерпретатора вызываются так же как и программы. Поэтому они также могут иметь параметры и опции.

Набирать длинные команды долго. Чтобы ускорить их набор, в оболочке Bash есть функция автодополнения. Она вызывается по нажатию клавиши Tab. Вы набираете первые буквы команды и нажимаете Tab.  Если Bash сможет однозначно определить, какая команда имеется ввиду, он допишет её за вас. Если же есть несколько команд, которые начинаются с введённых букв, автодополнение не произойдёт. В этом случае нажмите Tab повторно, чтобы увидеть список всех доступных команд. Иллюстрация 2-8 демонстрирует вывод по двойному нажатию Tab после ввода текста `pw`.

{caption: "Иллюстрация 2-8. Автодополнение для команды `pw`"}
![Автодополнение pw](images/BashShell/pw-autocompletion.png)

#### ls

После уточнения текущего каталога, будет полезно узнать его содержимое. Для этого воспользуйтесь утилитой ls. Её вывод для домашнего каталога `~` будет пустым, как в верхней части иллюстрации 2-9. Это значит, что каталог пуст.

{caption: "Иллюстрация 2-9. Вывод утилиты ls"}
![Вывод ls](images/BashShell/ls-command.png)

В Unix-окружении, как и в Windows есть скрытые файлы и каталоги. Они создаются ОС или приложениями для своих нужд. Например, это могут быть файлы с конфигурацией или временной информацией, нужной пока приложение работает. Пользователь не видит их в обычном режиме работы. Чтобы Проводник Windows стал отображать скрытые файлы, надо изменить [его настройки](https://support.microsoft.com/ru-ru/help/14201/windows-show-hidden-files).

В Unix-окружении имена скрытых файлов и каталогов начинаются с точки. В обычном режиме работы утилита ls их не отображает. Чтобы вывести их на экран, запустите утилиту с опцией `-a`. Тогда в домашнем кааталоге вы увидите восемь файлов, начинающихся с точки, как в нижней части иллюстрации 2-9.

Чтобы вывести содержимое каталога без перехода в него, передайте утилите ls его абсолютный или относительный путь в первом параметре. Иллюстрация 2-10 демонстрирует вывод команды `ls /`. Это содержимое корневого каталога.

{caption: "Иллюстрация 2-10. Вывод утилиты ls"}
![Вывод ls](images/BashShell/ls-root-command.png)

Обратите внимание, что в выводе утилиты нет каталогов `/c` и `/d`, которые упоминались в листинге 2-2. На самом деле они являются точками монтирования соответствующих дисков. В файловой системе Windows нет понятия точек монтирования. Поэтому каталоги `/c` и `/d` в ней отсутствуют. Они создаются только в окружении Unix, чтобы вы смогли перейти в корневые каталоги дисков `C` и `D`. Утилита ls читает содержимое каталогов в окружении Windows, поэтому эти точки монтирования не отображаются. В Linux и macOS такой проблемы нет: ls корректно выводит все точки монтирования.

#### mount

Когда к компьютеру подключено несколько дисков, может быть полезно вывести на экран их точки монтирования. Эту задачу выполняет утилита [mount](https://ru.wikipedia.org/wiki/Mount). Запустите её без параметров. Она выведет список точек монтирования как на иллюстрации 2-11.

{caption: "Иллюстрация 2-11. Вывод утилиты mount"}
![Результат mount](images/BashShell/mount-command.png)

Этот вывод надо рассматривать как таблицу, состоящую из четырёх столбцов. В первом указан диск, его раздел или просто каталог. Он смонтирован в корневую файловую систему. Второй столбец указывает точку монтирования. Это путь, по которому доступен смонтированный диск. В третьем столбце указан тип его файловой системы. Четвёртый столбец содержит параметры монтирования. Например, к параметрам относятся права доступа к диску: только для чтения или для чтения и записи.

Таблица 2-2 демонстрирует вывод утилиты mount с иллюстрации 2-11, разделённый на столбцы.

{caption: "Таблица 2-2. Вывод утилиты mount", width: "100%"}
| Монтируемый раздел | Точка монтирования | Тип ФС | Атрибуты доступа |
| --- | --- | --- | --- |
| `C:/msys64` | `/` | `ntfs` | `binary,noacl,auto` |
| `C:/msys64/usr/bin` | `/bin` | `ntfs` | `binary,noacl,auto` |
| `C:` | `/c` | `ntfs` | `binary,noacl,posix=0,user,noumount,auto` |
| `Z:` | `/z` | `hgfs` | `binary,noacl,posix=0,user,noumount,auto` |

Таблица 2-2 вызовет недоумение у Windows-пользователей. В качестве корневого каталога `/` в Unix-окружении монтируется каталог `C:/msys64`. Далее в него монтируются диски `C` и `Z` по путям `/c` и `/z`. Получается, что с точки зрения Unix-окружения диск `C` находится по пути `C:/msys64/c`. Но в файловой системе Windows зависимость обратная: `C:/msys64` является подкаталогом диска `C`. На самом деле это противоречие не вызывает проблем. Путь `/c` является точкой монтирования. Она существует только в Unix-окружении и отсутствует в Windows-окружении. Для простоты каталог `/c` можно рассматривать как ярлык для диска `C`.

Вывод утилиты mount занял много места на экране. Чтобы очистить окно терминала от текста, нажмите комбинацию клавиш Ctrl+L.

Бывает, что запущенная команда выполняется слишком долго или зависла. Чтобы прервать её выполнение, нажмите комбинацию клавиш Ctrl+C.

#### cd

Мы выяснили наше текущее местоположение в файловой системе. Теперь перейдём в нужный нам каталог. Для примера, мы ищем документацию по интерпретатору Bash. Попробуем её найти в системном каталоге `/usr`. В нём хранятся файлы установленных приложений. Для перехода в этот каталог наберите команду cd с параметром `/usr`:
{line-numbers: false, format: Bash}
```
cd /usr
```

Не забывайте про автодополнение. Оно работает как для имени команды, так и для её параметров. В нашем случае будет достаточно набрать `cd /u` и нажать клавишу Tab. Имя каталога `usr` будет добавлено автоматически. Результат выполнения команды приведён на иллюстрации 2-12.

{caption: "Иллюстрация 2-12. Результат выполнения команды `cd`"}
![Результат cd](images/BashShell/cd-command.png)

Команда cd ничего не выводит в случае успешного выполнения. При этом только меняется текущий каталог. Согласно выводу перед приглашением командной строки, теперь мы находимся в `/usr`.

Команда cd принимает на вход и абсолютные пути, и относительные. Относительные пути короче и быстрее в наборе. Поэтому они чаще используются при навигации по файловой системе.

Мы перешли в каталог `/usr`. Можно ли из него перейти на уровень выше в корневой каталог? Есть два способа это сделать: по абсолютному пути `/` и по специальному относительному пути `..`. Путь `..` всегда указывает на родительский каталог. Команда перехода по этому пути выглядит так:
{line-numbers: false, format: Bash}
```
cd ..
```

I> Кроме `..` в Bash есть еще один специальный путь `.`. Он означает текущий каталог. Если выполнить команду `cd .`, ничего не произойдёт. Вы останетесь по тому же пути, где и были. Путь `.` используется при запуске программ из текущего каталога.

Мы находимся в каталоге `/usr`. Выполним в нём утилиту ls. В её выводе есть каталог `share`. В нём находится подкаталог `doc` с документацией по установленным приложениям. Среди этих приложений есть интерпретатор Bash. Перейдём в каталог с его документацией по следующей команде:
{line-numbers: false, format: Bash}
```
cd share/doc/bash
```

Теперь нашим текущий каталогом стал `/usr/share/doc/bash`. Выполним в нём команду ls. Среди прочего она выведет файл с именем `README`. Это и есть документация по Bash, которую мы ищем. Выведите содержимое файла `README` на экран с помощью утилиты cat. Для этого выполните команду:
{line-numbers: false, format: Bash}
```
cat README
```

Иллюстрация 2-13 демонстрирует её результат.

{caption: "Иллюстрация 2-13. Вывод утилиты `cat`", height: "30%"}
![Результат cat](images/BashShell/cat-command.png)

I> Авторы некоторых руководств по Bash утверждают, что использовать утилиту cat для вывода содержимого файла неправильно. Её первоначальное назначение — объединять несколько файлов и выводить результат в стандартный поток вывода. Вместо вызова cat для одного файла они рекомендуют использовать перенаправление потоков, которое мы рассмотрим далее в этой главе. Согласно этой рекомендации, вывод содержимого файла на экран выглядит следующим образом:
{line-numbers: false, format: Bash}
```
echo "$(< README.txt)"
```

На иллюстрации 2-13 вы видите не весь файл `README`, а только его последние строки. Это произошло потому, что файл большой и вывод утилиты cat не поместился в окне терминала. Чтобы просмотреть его начало, воспользуйтесь полосой прокрутки в правой части окна. Так же для прокрутки [по страницам](https://en.wikipedia.org/wiki/Page_Up_and_Page_Down_keys) можно использовать горячие клавиши Shift+PageUp и Shift+PageDown, а по строкам — Shift+↑ и Shift+↓.

Каждая выполненная в терминале команда сохраняется в [истории команд](https://ru.wikipedia.org/wiki/History). Чтобы ввести предыдущую команду в терминал, нажмите стрелку вверх ↑. Историю команд можно прокручивать дальше стрелкой вверх. Так, например, вы найдёте первую команду, выполненную после запуска терминала. Для перехода к следующей команде в истории нажмите стрелку вниз ↓.

Например, вы только что ввели команду `cat README`. Чтобы её повторить, нажмите стрелку вверх и клавишу Enter.

Комбинация клавиш Ctrl+R вызывает поиск по истории. Нажмите Ctrl+R и начните набирать текст. Bash предложит вам последнюю введённую команду, которая начинается также. Чтобы исполнить её, просто нажмите Enter.

Для вывода на экран всей истории воспользуйтесь командой history.

I> В историю команд попадают только выполненные команды. В неё не попадают команды, которые вы набрали, а затем стёрли. Иногда в историю нужно сохранить команду, которую исполнять сейчас не нужно. Для этого воспользуйтесь трюком с комментарием. Любая команда, которая начинается с символа решётка `#`, обрабатывается Bash как комментарий. По нажатию Enter она попадёт в историю команд, но не исполнится. С этим трюком наш вызов утилиты cat станет таким:
{line-numbers: false, format: Bash}
```
cat README
```

Что делать, если вам нужно скопировать текст из терминала? Например, часть файла `README` нужна в другом документе. Для копирования воспользуйтесь [**буфером обмена**](https://ru.wikipedia.org/wiki/Буфер_обмена). Это временное хранилище для строк. В нём можно сохранить выделенный в терминале текст, а затем вставить его в другое окно.

Для копирования текста из терминала выполните следующее:

1. Выделите мышью нужный текст. Для этого зажмите левую кнопку мыши и проведите курсором по тексту.

2. Для вставки текста из буфера обмена в окно терминала нажмите среднюю кнопку мыши. Текст будет вставлен в текущую позицию курсора.

3. Для вставки текста в другое приложение нажмите правую кнопку мыши и выберите пункт "Вставить".

#### find

Искать нужный файл или каталог вручную с помощью команд cd и ls неудобно. Вместо них для быстрого поиска используйте утилиту find.

Утилита find, запущенная без параметров, выводит содержимое текущего каталога и его подкаталогов. В её вывод попадут и скрытые объекты. Иллюстрация 2-14 демонстрирует результат выполнения find для домашнего каталога пользователя `~`.

{caption: "Иллюстрация 2-14. Результат работы утилиты find", height: "30%"}
![Результат find](images/BashShell/find-command.png)

Утилите find можно указать каталог, содержимое которого надо обработать. Относительный или абсолютный путь до него указывается в первом параметре утилиты. Например, команда для обработки корневого каталога с помощью find выглядит так:
{line-numbers: false, format: Bash}
```
find /
```

Следующие далее параметры утилиты представляют собой условия. Если строка в выводе утилиты find не удовлетворяет этим условиям, она не попадает на экран. Условия сочетаются друг с другом и составляют единое выражение. Для обработки этого выражения в утилиту встроен собственный небольшой интерпретатор.

Например, условием для утилиты find может быть имя файла. Тогда в её вывод попадут только файлы с указанным именем. Все остальные будут отброшены.

Таблица 2-3 демонстрирует часто используемые условия утилиты find.

{caption: "Таблица 2-3. Часто используемые условия утилиты find", width: "100%"}
| Условие | Значение | Пример |
| --- | --- | --- |
| `-type f` | Искать только файлы. | `find -type f` |
|  | | |
| `-type d` | Искать только каталоги. | `find -type d` |
|  | | |
| `-name шаблон` | [**Шаблон имени**](https://ru.wikipedia.org/wiki/Шаблон_поиска) файла или каталога, | `find -name README` |
| | чувствительный к регистру. | `find -name READ*` |
| | | `find -name READ??` |
|  | | |
| `-iname шаблон` | Шаблон имени файла или каталога, нечувствительный к регистру. | `find -iname readme` |
|  | | |
| `-path шаблон` | Шаблон пути к файлу или каталогу, чувствительный к регистру. | `find -path */doc/bash/*` |
|  | | |
| `-ipath шаблон` | Шаблон пути к файлу или каталогу, нечувствительный к регистру. | `find . -ipath */DOC/BASH/*` |
|  | | |
| `-a` или `-and` | Скомбинировать несколько условий с помощью логического И. В вывод попадут только файлы и каталоги, удовлетворяющие всем скомбинированным условиям. | `find -name README -a -path */doc/bash/* ` |
|  | | |
| `-o` или `-or` | Скомбинировать несколько условий с помощью логического ИЛИ. Если файл или каталог соответствует хотя бы одному условию, он попадёт в вывод. | `find -name README -o -path */doc/bash/* ` |
|  | | |
| `!` или `-not` | Логическое отрицание (НЕ) | `find -not -name README` |
| | последующего условия. В вывод попадут только файлы и каталоги, которые не удовлетворяют условию. | `find ! -name README` |

Шаблоном называется поисковый запрос, в который вместе с обычными символами входят [**символы подстановки**](https://ru.wikipedia.org/wiki/Символ_подстановки) (wildcard character). Всего в Bash есть три таких символа: `*`, `?` и `[`. Звёздочка означает любое количество любых символов. Знак вопроса — один любой символ. Например, строка `README` будет соответствовать следующим шаблонам: `*ME`, `READM?`, `*M?`, `R*M?`.

Кроме `*` и `?` можно указывать наборы символов, которые ожидаются в определённой позиции строки. Например, шаблон `[cb]at.txt` будет соответствовать обоим файлам `cat.txt` и `bat.txt`. Применим этот шаблон имени файла в условии утилиты find следующим образом:
{line-numbers: false, format: Bash}
```
find . -name "[cb]at.txt"
```

{caption: "Упражнение 2-1. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону `*ME.??`?

* 00_README.txt
* README
* README.md
```

{caption: "Упражнение 2-2. Шаблоны поиска", line-numbers: false}
```
Какая из следующих строк соответствует шаблону `*/doc?openssl*`?

* /usr/share/doc/openssl/IPAddressChoice_new.html
* /usr/share/doc_openssl/IPAddressChoice_new.html
* doc/openssl
* /doc/openssl
```

Рассмотрим примеры условий утилиты find с шаблонами. Вернёмся к задаче поиска документации по Bash. Попробуем найти файл `README` с ней не вручную, а с помощью find. Предположим, что мы не знаем, на каком диске находится этот файл. Тогда первым параметром передадим утилите корневой каталог. В результате она будет искать файл на всех смонтированных дисках. Далее учтём, что в Unix-окружении документы хранятся в каталогах с именем `doc`. Учитывая это, напишем следующую команду для поиска:
{line-numbers: false, format: Bash}
```
find / -path */doc/*
```

Она выведет список всех файлов с документацией на всех смонтированных дисках. Этот список слишком длинный. Его нужно сократить с помощью дополнительных условий поиска. Добавим в предполагаемый путь искомого файла строку `bash`. Получится следующая команда:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -path */bash/*
```

Её результат приведён на иллюстрации 2-15. Эта команда эквивалентна такой:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -a -path */bash/*
```

Если между условиями не указывать логическую операцию (И, ИЛИ), по умолчанию будет использоваться И.

{caption: "Иллюстрация 2-15. Результат работы утилиты find", height: "30%"}
![Результат find](images/BashShell/find-path-path.png)

В конце вывода утилита find сообщает об ошибке. Проблема в том, что некоторые подкаталоги `/` являются точками монтирования Windows-дисков (например, `/c` для `C:`). Утилита find не может получить доступ к их содержимому при вызове её из корневого каталога. Чтобы избежать этой проблемы, начните поиск с точки монтирования диска `C:`:
{line-numbers: false, format: Bash}
```
find /c -path */doc/* -a -path */bash/*
```

Альтернативное решение — исключить точки монтирования из поиска с помощью параметра `-mount`:
{line-numbers: false, format: Bash}
```
find / -mount -path */doc/* -a -path */bash/*
```

В результате мы получим относительно небольшой список документов, среди которых легко найти нужный нам `README` файл.

Мы могли бы следовать другой стратегии поиска. Предположим, что нам известно имя искомого файла. Тогда его можно указать вместе с предполагаемым путём:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README
```

Иллюстрация 2-16 демонстрирует результат такого поиска.

{caption: "Иллюстрация 2-16. Результат работы утилиты find", height: "30%"}
![Результат find](images/BashShell/find-path-name.png)

Мы снова получили относительно небольшой список, в котором легко найти `README` файл с документацией по Bash.

Условия утилиты find можно группировать. Для этого используйте [экранированные](https://ru.wikipedia.org/wiki/Экранирование_символов) скобки. Например, следующая команда ищет файлы `README` с путём `*/doc/*` или файлы `LICENSE` с произвольным путём.
{line-numbers: false, format: Bash}
```
find / \( -path */doc/* -name README \) -o -name LICENSE
```

Почему скобки, передаваемые в утилиту find, должны экранироваться обратным слэшем? Дело в том, что скобки является частью синтаксиса Bash. Они используются в конструкциях языка. Встретив их в вызове утилиты, Bash выполнит **подстановку** (или замену) скобок и их содержимого на что-то другое. С помощью экранирования мы сообщаем интерпретатору, что эти символы должны передаваться в утилиту как есть, без какой-либо замены.

Утилита find используется не только для поиска, но и для обработки файлов или каталогов. Последний параметр утилиты задаёт действие. Это действие будет применено к каждому из найденных файлов и каталогов.

Таблица 2-4 демонстрирует опции для указания действий.

{caption: "Таблица 2-4. Опции для указания действий над найденными файлами и каталогами", width: "100%"}
| Опция | Значение | Пример |
| --- | --- | --- |
| `-exec команда {} \;`| Выполнить указанную команду над каждым из найденных файлов или каталогов. | `find -name README -type f -exec cp {} ~ \;` |
|  | | |
| `-exec команда {} +`| Выполнить указанную команду один раз над всеми найденными файлами или каталогами. То есть они будут переданы на вход этой команды. | ` find -type d -exec cp -t ~ {} +` |
|  | | |
| `-delete`| Удалить каждый из найденных файлов. При этом каталоги будут удаляться, только если они пустые. | `find -name README -type f -delete` |

I> Действие `-exec` с `{} +` на конце допустимо указывать только для команд, поддерживающих несколько параметров. Большинство GNU утилит их поддерживает. В противном случае команда обработает только первый файл или каталог, найденный утилитой find.

Рассмотрим пример использования действия `-exec`. Часто возникает задача копирования найденного файла в другое место. Предположим, что нам надо скопировать все файлы документации по Bash с расширением HTML в домашний каталог. Начнём с поиска этих файлов. Команда вызова утилиты find для поиска выглядит так:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html"
```

I> При передаче шаблонов в утилиту find заключайте их в двойные кавычки `"`. Они выполняют ту же функцию, что и обратный слэш, экранирующий скобки. Таким образом мы указываем Bash, что он не должен интерпретировать шаблоны сам, то есть выполнять подстановку. Вместо этого он должен передавать их вызываемой утилите.

Результат поиска HTML документов представлен на иллюстрации 2-17.

{caption: "Иллюстрация 2-17. Результат работы утилиты find", height: "30%"}
![Результат find](images/BashShell/find-html.png)

Добавим к команде поиска параметр `-exec`. С его помощью будем вызывать утилиту `cp`. Эта утилита копирует файлы и каталоги в указанный путь. В первом параметре cp принимает то, что надо скопировать. Во втором параметре — цель, куда копировать. После добавления действия вызов утилиты find выглядит следующим образом:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cp {} ~ \;
```

Эта команда ничего не выведет в терминал, кроме уже знакомой нам ошибки с точками монтирования.

Что сделала команда? Для каждого найденного HTML файла (см. иллюстрацию 2-17) вызывалась утилита cp. В неё первым параметром вместо скобок `{}` передавался путь до найденного HTML файла. Поскольку найдено было два файла, произошло только два вызова утилиты `cp`. Они выглядели так:
{line-numbers: true, format: Bash}
```
cp ./usr/share/doc/bash/bash.html ~
cp ./usr/share/doc/bash/bashref.html ~
```

Каждый вызов копирует HTML файл в домашний каталог пользователя.

Только что мы написали нашу первую программу на языке интерпретатора утилиты find. Она работает по следующему алгоритму:

1. Найти файлы с расширением HTML, хранящиеся в корневом каталоге. Их пути должны соответствовать шаблону `*/doc/bash/*`.

2. Скопировать каждый из найденных файлов в каталог пользователя.

Программа состоит всего из двух действий. Но она окажется полезной, если вам нужно обработать много файлов. Просто представьте, сколько времени вы бы потратили на эту задачу, если бы работали с Проводником Windows.

Действия `-exec` можно комбинировать точно так же как и условия поиска. Предположим, что надо вывести содержимое каждого из найденных HTML файлов и подсчитать количество строк в них. Для вывода содержимого воспользуемся утилитой cat. Для подсчёта строк применим утилиту wc с опцией `-l`. На вход она принимает имя файла, который надо обработать. Команда вызова find в этом случае выглядит так:
{line-numbers: false, format: Bash}
```
find / -path "*/doc/bash/*" -name "*.html" -exec cat {} \; -exec wc -l {} \;
```

Здесь между действиями `-exec` логическая операция не указана. По умолчанию используется `-a` или логическое И. Это означает, что второе действие будет выполнено только при успешном исполнении первого. Мы можем заменить логическую операцию на ИЛИ. Тогда второе действие будет выполняться всегда, независимо от результата первого.

Действия `-exec` можно группировать с помощью экранированных скобок `\(` и `\` точно так же как и условия поиска.

{caption: "Упражнение 2-3. Использование утилиты find", line-numbers: false}
```
Напишите команду вызова find для поиска всех TXT файлов в вашем Unix-окружении.
Дополните команду, чтобы вывести общее число строк в этих файлах.
```

#### Логические выражения

Изучая встроенный интерпретатор утилиты `find`, мы столкнулись с [**логическими выражениями**](
https://ru.wikipedia.org/wiki/Логическое_выражение). Это важная концепция современных языков программирования, поэтому рассмотрим её подробнее.

Логическое выражение — это некоторое условие, которое может быть либо истинным, либо ложным. Условия могут сочетаться друг с другом. В общем случае мы говорим о некоторой конструкции языка, результат вычисления которой принимает одно из двух значений: "истина" или "ложь".

Мы уже упоминали алгебру логики, когда обсуждали двоичную систему счисления. Это раздел математики, который изучает [**логические операции**](https://ru.wikipedia.org/wiki/Логическая_операция) над выражениями. Эти операции отличаются от принятых в арифметике сложения, вычитания, умножения и деления. Причина в том, что выражения принимают только два значения. Из-за этого арифметические действия над ними становятся тривиальными и ничего не дают. С другой стороны, если применить к выражениям логические операции, можно составлять условия со строгими правилами вывода результата. Комбинация таких условий позволит получить сложное поведение.

I> Выражения, над которыми выполняется логическая операция, называются **операндами**.

Рассмотрим простой пример. Представьте себе, что мы программируем робота для склада. Его задача заключается в том, чтобы переносить коробки из точки А в точку Б. Мы можем задать ему простой алгоритм работы:

1. Возьми коробку в точке А.

2. Двигайся в точку Б.

3. Положи коробку.

В этом алгоритме нет никаких условий. Он реализует простейшее поведение робота. Но представьте, что произойдёт, если на пути робота стоит погрузчик. В этом случае исполнение приведённого выше алгоритма приведёт к столкновению. Чтобы этого избежать, мы должны добавить условие:

1. Возьми коробку в точке А.

2. Если нет препятствия, двигайся в точку Б. Иначе остановись.

3. Положи коробку.

Второй шаг алгоритма называется [**условным оператором**](https://ru.wikipedia.org/wiki/Ветвление_(программирование)). Он есть во многих современных языках программирования.

Что именно происходит в условном операторе? На самом деле в нём вычисляется значение логического выражения "нет препятствия". Если препятствие есть, выражение будет ложно, и робот остановится. В противном случае он продолжит движение.

Логические операции появляются, когда требуется сочетать несколько выражений. Представьте, что в точке А может не оказаться коробки. Тогда роботу нет смысла двигаться в точку Б. В этом случае мы можем воспользоваться операцией [**логического И**](https://ru.wikipedia.org/wiki/Конъюнкция), известной так же как конъюнкция. Наш алгоритм станет выглядеть следующим образом:

1. Возьми коробку в точке А.

2. Если есть коробка И нет препятствия, двигайся в точку Б. Иначе остановись.

3. Положи коробку.

Интуитивно понятно, что результат логического И в нашем примере будет истинным только тогда, когда оба условия истинны. То есть у робота есть коробка и нет препятствия. В любом другом случае выражение будет ложным, и робот остановится.

Изучая утилиту `find`, мы столкнулись с ещё двумя логическими операциями: [**ИЛИ**](https://ru.wikipedia.org/wiki/Дизъюнкция) (дизъюнкция) и [**НЕ**](https://ru.wikipedia.org/wiki/Отрицание) (отрицание). На самом деле в нашем алгоритме для робота мы уже применили НЕ, когда написали выражение "нет препятствия". Это ничто иное как отрицание: "НЕ есть препятствие". Перепишем наш алгоритм более формально:

1. Возьми коробку в точке А.

2. Если есть коробка И НЕ есть препятствие, двигайся в точку Б. Иначе остановись.

3. Положи коробку.

Мы можем переписать наше выражение, используя операцию ИЛИ. Но в таком случае нам придётся поменять действия робота: истинное выражение приведёт к его остановке, а ложное — к движению в точку Б. В итоге получится следующий алгоритм:

1. Возьми коробку в точке А.

2. Если НЕ есть коробка ИЛИ есть препятствие, остановись. Иначе двигайся в точку Б.

3. Положи коробку.

Очевидно, что логика робота нисколько не изменилась. Он по-прежнему остановится, если у него нет коробки или на пути возникло препятствие.

Как вы уже заметили, [**естественный язык**](https://ru.wikipedia.org/wiki/Естественный_язык) (язык общения людей) плохо подходит для описания логических выражений. Поэтому в алгебре логики применяется формальная математическая запись.

Кроме рассмотренных нами логических И, ИЛИ, НЕ в программировании широко распространены ещё три операции: **эквивалентность**, **не эквивалентность**, **исключающее ИЛИ**. Информация по ним приведена в таблице 2-5.

{caption: "Таблица 2-5. Логические операции в программировании", width: "100%"}
| Операция | Значение выражения |
| --- | --- |
| И (AND) | Истинно только когда оба операнда истинны. |
|  | |
| ИЛИ (OR) | Истинно, когда любой из операндов истинен. Ложно только тогда, когда все операнды ложны. |
|  | |
| НЕ (NOT) | Истинно когда операнд ложен и наоборот. |
|  | |
| Исключающее ИЛИ (XOR) | Истинно когда значения операндов отличаются (истина-ложь или ложь-истина). Ложно когда они совпадают (истина-истина, ложь-ложь). |
|  | |
| Эквивалентность | Истинно только когда значения операндов совпадают. |
|  | |
| Не эквивалентность | Истинно только когда значения операндов отличаются. |

Постарайтесь запомнить эту таблицу. При частом использовании логических операций это будет совсем несложно.

#### grep

Ещё одним мощным инструментом поиска является утилита `grep`. Мы познакомились с программой `find`, которая позволяет искать файлы и каталоги по имени, пути и [**метаданным**](https://ru.wikipedia.org/wiki/Метаданные). К метаданным относятся размер (в случае файла), время создания и последней модификации, права доступа.

Чтобы лучше понять задачи, решаемые утилитой `grep`, рассмотрим пример. Представьте, что на всём жёстком диске вы ищете текстовый файл, в котором встречается фраза "free software" (свободное ПО). Алгоритм такого поиска с помощью утилиты `find` будет следующим:

1. Найти все текстовые файлы на диске с помощью `find`.

2. Открыть каждый файл в текстовом редакторе и проверить наличие фразы "free software".

Это огромная ручная работа, которая займёт много времени. Утилита `grep` создана как раз для решения подобных задач.

Чтобы найти текст в указанном файле, запустите `grep` со следующими параметрами:
{line-numbers: false, format: Bash}
```
grep "free software" /usr/share/doc/bash/README
```

Первым параметром указывается строка для поиска. В нашем случае это "free software". Не забывайте про двойные кавычки. С их помощью мы сообщаем Bash, что вся строка должна передаваться утилите `grep` как первый параметр. В противном случае она будет разбита на слова, каждое из которых будет передано как отдельный параметр. Этот механизм разделения строк на слова в Bash называется [**word splitting**](http://mywiki.wooledge.org/WordSplitting).

После строки для поиска идут относительные или абсолютные пути к интересующим нас файлам, разделённые пробелом. В нашем примере передаётся только путь до `README` файла с документацией на Bash. Результат выполнения команды приведён на иллюстрации 2-18.

{caption: "Иллюстрация 2-18. Результат вызова утилиты `grep`", width: "100%"}
![Результат grep](images/BashShell/grep-command.png)

В вывод утилиты можно добавить номера строк файла, в которых встретилась искомая строка. Для этого добавьте опцию `-n`. Результат такого вызова приведён в нижней части иллюстрации 2-18.

Мы выяснили, как с помощью `grep` искать строки в одном файле. Но как эта утилита поможет нам найти нужный файл из многих? Для этой цели `grep` можно использовать двумя способами.

В первом способе мы применим функцию Bash для разворачивания шаблона имени файла. Предположим, что в домашнем каталоге пользователя находятся два текстовых файла: `bash.txt` и `xz.txt`. Это копии `README` документов соответствующих программ: Bash и xz. Наша задача заключается в проверке, встречается ли фраза "free software" в этих файлах. Для этого выполним следующее:
{line-numbers: true, format: Bash}
```
cd ~
grep "free software" *
```

Сначала мы перешли в домашний каталог пользователя. Затем вызвали утилиту `grep`. В качестве целевого файла мы использовали символ подстановки — звёздочка. Это шаблон поиска, означающий любую строку. Перед вызовом `grep` Bash выполнит подстановку. Вместо шаблона в команду будет вставлен список всех файлов, имена которых ему соответствуют. В результате команда будет выглядеть следующим образом:
{line-numbers: false, format: Bash}
```
grep "free software" bash.txt xz.txt
```

Попробуйте оба варианта вызова `grep`: с шаблоном `*` и явным указанием списка файлов. Вы получите одинаковый результат.

I> С помощью команды `echo` можно вывести на экран результат разворачивания шаблона Bash:
{line-numbers: false, format: Bash}
```
echo *
```

В данном случае важно не заключать символ звёздочки в двойные кавычки следующим образом:
{line-numbers: false, format: Bash}
```
grep "free software" "*"
```

Если сделать так, то подстановки Bash не будет и шаблон поиска будет передан как есть утилите `grep`. В отличие от `find` она не умеет самостоятельно разворачивать шаблоны. Поэтому будет выведено сообщение об ошибке как на иллюстрации 2-19.

{caption: "Иллюстрация 2-19. Результат передачи шаблона в `grep`", width: "100%"}
![Результат grep](images/BashShell/grep-error.png)

I> Bash не включает скрытые файлы в подстановку шаблона `*`. В нашем случае это означает, что утилита `grep` не получит их на вход. Чтобы искать по скрытым файлам, используйте шаблон `.*`. Можно указывать его и `*`, чтобы искать по всем файлам разом. Например:
{line-numbers: false, format: Bash}
```
grep "free software" * .*
```

Мы рассмотрели первый способ поиска нужного файла с помощью шаблонов Bash. Во втором способе воспользуемся функцией утилиты `grep` для перебора всех файлов в указанном каталоге. Эта функция включается опцией `-r`. При этом последним параметром нужно указать путь к каталогу:
{line-numbers: false, format: Bash}
```
grep -r "free software" .
```

Приведённая команда ищет фразу "free software" во всех файлах текущего каталога. Если вы хотите также проверить файлы подкаталогов, то воспользуйтесь опцией `-R`:
{line-numbers: false, format: Bash}
```
grep -R "free software" .
```

Целевой каталог для поиска можно указывать по относительному и абсолютному путям. Например:
{line-numbers: true, format: Bash}
```
cd /home
grep -R "free software" ilya.shpigor/tmp
grep -R "free software" /home/ilya.shpigor/tmp
```

I> Утилита `grep`, запущенная с опциями `-r` и `-R`, корректно обработает скрытые файлы и каталоги.

Если вас интересуют только имена файлов, в которых встречается указанная строка, воспользуйтесь опцией `-l`:
{line-numbers: false, format: Bash}
```
grep -Rl "free software" .
```

Результат выполнения этой команды приведён на иллюстрации 2-20.

{caption: "Иллюстрация 2-20. Результат вывода только имён файлов"}
![Результат grep](images/BashShell/grep-files.png)

Если вам наоборот нужен список файлов, в которых указанная строка не встречается, воспользуйтесь опцией `-L`. Например так:
{line-numbers: false, format: Bash}
```
grep -RL "free software" .
```

Скорее всего, познакомившись с утилитой `grep`, вам захочется применить её для поиска документов в формате [PDF](https://ru.wikipedia.org/wiki/Portable_Document_Format) и MS Office. К сожалению, это не сработает. Файлы в этих форматах не являются текстовыми. Но эта задача может быть решена установкой дополнительных утилит: `pdftotext`, `pdfgrep`, `antiword`, `catdoc` и `xdoc2txt`. Мы рассмотрим их далее, когда будем обсуждать пакетный менеджер.

Файлы с исходным кодом программ являются текстовыми. Поэтому утилита `grep` отлично подходит для поиска по ним.

{caption: "Упражнение 2-4. Использование команды `grep`", line-numbers: false}
```
Напишите команду вызова утилиты grep для поиска приложений MSYS2, распространяющихся под свободной лицензией. В сообществе открытого ПО самые распространённые лицензии следующие:

1. GNU General Public License
2. MIT license
3. Apache license
4. BSD license
```
