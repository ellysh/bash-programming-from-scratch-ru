## Дополнительные возможности Bash

Мы познакомились со встроенными командами Bash и GNU-утилитами для работы с файловой системой. Теперь вы умеете запускать программы, копировать и удалять файлы из командной строки. То же самое легко сделать через графический интерфейс. Для простых задач выбор командного или графического интерфейса — это дело вкуса.

Интерпретатор Bash предлагает возможности, которых нет в графическом интерфейсе. Благодаря им, некоторые задачи выполняются быстрее и проще. Применяйте эти возможности, чтобы сэкономить время и избежать ошибок.

В этом разделе рассмотрим следующие механизмы Bash:

1. Перенаправление ввода-вывода.
2. Конвейеры.
3. Логические операторы.

### Философия Unix

[Дуглас Макилрой](https://ru.wikipedia.org/wiki/Макилрой,_Дуглас) — один из разработчиков Unix. Он обобщил философию этой ОС в трёх пунктах:

1. Пишите программы, которые делают что-то одно и делают это хорошо.

2. Пишите программы, которые бы работали вместе.

3. Пишите программы, которые бы поддерживали текстовые потоки, поскольку это универсальный интерфейс.

Текстовый формат данных — это основа философии Unix. На нём строятся первые два правила.

Благодаря текстовому формату, данные легко передавать между программами. Предположим, что два разработчика независимо друг от друга написали две утилиты. Обе утилиты принимают на вход и выводят результаты в виде текста. Теперь вы хотите скомбинировать эти утилиты для решения своей задачи. Сделать это просто. Не нужно конвертировать данные из одного формата в другой или расширять функциональность утилит. Вместо этого передайте вывод одной утилиты на вход другой.

Когда взаимодействие программ легко наладить, незачем перегружать каждую из них дополнительными возможностями. Например, вы пишете программу для копирования файлов. Она хорошо справляется со своей задачей. Но со временем вы понимаете, что ей нужна функция поиска. Тогда находить и копировать файлы было бы быстрее. Также было бы удобно создавать каталоги прямо в программе, чтобы переносить в них файлы. Этот пример показывает, что требования к приложению быстро растут. Если программа работает самостоятельно, придётся расширять её функции.

Когда приложения работают вместе, каждое из них решает только свою задачу. Если требуется дополнительная операция, проще обратиться к другой утилите. Не надо добавлять новую функцию в приложение. Она уже есть готовая и хорошо протестированная. Просто вызовите внешнюю утилиту, которая сделает то что нужно за вас. Именно такой подход поощряет философия Unix.

### Перенаправление ввода-вывода

Утилиты командной строки появились в первых версиях Unix. Большая часть этих утилит попала в POSIX-стандарт. В современных Linux дистрибутивах их заменили на GNU-утилиты. Эти утилиты предлагают больше возможностей. В то же время они следуют стандарту POSIX и обеспечивают обратную совместимость со старыми программами.

GNU-утилиты следуют философии Unix. Они используют текстовый формат для ввода и вывода данных. Поэтому их так же легко комбинировать, как и Unix-утилиты.

При комбинировании GNU-утилит возникает вопрос. Как правильно передавать текстовые данные между ними? У этой задачи есть несколько решений.

Предположим, что вывод утилиты помещается в одну строку. Вам нужно передать её на вход другой утилите. Для этого воспользуйтесь буфером обмена. Выделите мышью вывод утилиты. Затем наберите следующую команду и вставьте содержимое из буфера обмена в её конец. Это простой метод. Но он не сработает для копирования нескольких строк. При их вставке Bash интерпретирует разделители строк как нажатия клавиши Enter. По нажатию Enter команда начнёт исполняться. Из-за этого часть копируемых строк потеряется.

Другое решение — использовать файловую систему. Создайте временный файл, чтобы сохранить вывод одной утилиты. Затем передайте имя файла другой утилите. Она прочитает его содержимое и получит данные. Такой подход удобнее буфера обмена по двум причинам:

1. Нет ограничения на количество передаваемых строк.
2. Нет ручных операций с буфером обмена.

У Bash есть механизмы для перенаправления ввода и вывода команд в файлы. Это значит, что вашему приложению достаточно читать текстовые данные на входе и выводить результат на экран. Всю работу по перенаправлению этих данных возьмёт на себя Bash.

Рассмотрим пример. Предположим, что мы ищем файлы на диске. Результат поиска надо сохранить в файл. Для решения задачи воспользуемся утилитой find и оператором перенаправления `1>`. Тогда команда вызова утилиты выглядит так:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 1> readme_list.txt
```

После выполнения команды в текущем каталоге появится файл `readme_list.txt`. Утилита find запишет в него свой вывод. Формат вывода такой же, как если бы он печатался на экран. Если файл с именем `readme_list.txt` уже существует, find перезапишет его содержимое.

Что означает оператор `1>`? Это [перенаправление стандартного потока вывода](https://ru.wikipedia.org/wiki/Перенаправление_ввода-вывода). В Unix-окружении есть три [стандартных потока](https://ru.wikipedia.org/wiki/Стандартные_потоки). Таблица 2-12 объясняет их назначение.

{caption: "Таблица 2-12. Стандартные потоки POSIX", width: "100%"}
| Номер | Название | Применение |
| --- | --- | --- |
| 0 | Стандартный поток ввода (standard input или stdin). | Данные, которые передаются на вход программы. По умолчанию они поступают с устройства ввода типа клавиатуры. |
|  | | |
| 1 | Стандартный поток вывода (standard output или stdout). | Данные, которые выводит программа. По умолчанию они печатаются в окне терминала. |
|  | | |
| 2 | Стандартный поток ошибок (standard error или stderr). | Данные об ошибках, которые выводит программа. По умолчанию они печатаются в окне терминала. |

Приложение работает в программном окружении операционной системы. Поток представляет собой канал связи между приложением и окружением. В ранних Unix-системах информация вводилась и выводилась через физические каналы. Ввод был привязан к клавиатуре, а вывод — к монитору. Потоки ввели как [абстракцию](https://ru.wikipedia.org/wiki/Уровень_абстракции_(программирование)) над этими каналами. Абстракция позволила работать с разными объектами по одному и тому же алгоритму. Так ввод с реального устройства можно заменить на ввод из файла. Аналогично печать на экран можно заменить на вывод в файл. При этом за ввод-вывод отвечает один и тот же код ОС.

Назначение потоков ввода и вывода понятно. Но зачем нужен поток ошибок? Представьте, что вы запустили утилиту find для поиска файлов. К некоторым каталогам у вас нет доступа. При попытке прочитать их содержимое выводится сообщение об ошибке. Если утилита нашла много файлов, сообщения об ошибках потеряются в её выводе. Разделение потоков вывода и ошибок поможет в этом случае. Перенаправьте в файл поток вывода. Тогда на экран напечатаются только сообщения об ошибках.

Чтобы перенаправить поток ошибок, используйте оператор `2>`. Например, добавим его в вызов утилиты find:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 2> errors.txt
```

Цифра перед знаком больше в операторах `2>` и `1>` означает номер потока.

Для перенаправления потока ввода используйте оператор `0<`. Вот простой, но не правильный пример поиска шаблона `Bash` в файле `README.txt`:
{line-numbers: false, format: Bash}
```
grep "Bash" 0< README.txt
```

Эта команда использует интерфейс утилиты grep для обработки потока ввода. Но grep умеет сама читать содержимое указанного файла. Поэтому лучше в неё всегда передавать имя файла. Например, так:
{line-numbers: false, format: Bash}
```
grep "Bash" README.txt
```

Рассмотрим пример посложнее. Некоторые руководства по Bash рекомендуют команду echo для вывода содержимого файла на экран. Например, с ней вывод файла `README.txt` выглядит так:
{line-numbers: false, format: Bash}
```
echo $( 0< README.txt )
```

Здесь echo получает на вход результат выполнения следующей команды:
{line-numbers: false, format: Bash}
```
0< README.txt
```

Замена вызова команды на её результат называется **подстановкой команды**. Когда Bash встречает символы `$(` и `)`, он выполняет заключённую между ними команду и подставляет её вывод.

Из-за подстановки команд наш вызов echo выполняется в два этапа:

1. Передать содержимое файла `README.txt` на стандартный поток ввода.

2. Вывести данные из стандартного потока ввода командой echo.

При подстановке команд учитывайте порядок исполнения. Сначала Bash выполняет все подстановки по порядку. Потом он выполняет получившуюся команду целиком.

Из-за нарушения порядка исполнения следующий вызов find завершится с ошибкой:
{line-numbers: false, format: Bash}
```
$ find / -path */doc/* -name README -exec echo $(0< {}) \;
```

Текст ошибки следующий:
{line-numbers: false, format: Bash}
```
bash: {}: No such file or directory
```

Команда должна вывести содержимое файлов, найденных утилитой find. Но вместо этого Bash выдал ошибку. Проблема в том, что команда `0< {}` выполнится перед вызовом утилиты find. В результате содержимое файла с именем `{}` перенаправляется на стандартный поток ввода. Но файла с таким именем не существует. Мы ожидали, что утилита find вместо символов `{}` подставит свой результат. Но она выполняется после подстановки команды `0< {}`, а не до.

Чтобы вызов find сработал, замените команду echo на утилиту cat. Получится следующее:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README -exec cat {} \;
```

Команда выведет на экран содержимое найденных файлов.

Операторы перенаправления потоков ввода и вывода часто используют. Поэтому для них ввели краткую форму: ввод `<` и вывод `>`.

Вызов find с краткой формой перенаправления выглядит так:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README > readme_list.txt
```

Вот вызов echo с краткой формой перенаправления:
{line-numbers: false, format: Bash}
```
echo $( < README.txt )
```

Предположим, что вы перенаправляете поток вывода в уже существующий файл. Его содержимое нельзя удалять. В этом случае допишите результат команды в конец файла. Для этого замените оператор `>` на `>>`.

Например, приложения на вашем компьютере установлены в каталоги `/usr` и `/opt`. Тогда следующие два вызова find найдут их README файлы:
{line-numbers: true, format: Bash}
```
find /usr -path */doc/* -name README > readme_list.txt
find /opt -name README >> readme_list.txt
```

Первый вызов find создаст файл `readme_list.txt` и запишет в него результат. Если файл уже существует, его содержимое перезапишется. Вторая команда find допишет свой результат в конец `readme_list.txt`. Если бы файла ещё не было, оператор `>>` его бы создал.

Полная форма оператора `>>` выглядит как `1>>`. Чтобы перенаправить поток ошибок без перезаписи файла, используйте оператор `2>>`.

Иногда нужно перенаправить и поток вывода, и поток ошибок в один файл. Для этого используйте операторы `&>` или `&>>`. Первый оператор перезапишет существующий файл. Второй — допишет данные в его конец. Например:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README &> result_and_errors.txt
```

Эта команда работает в Bash, но не в Bourne shell. Дело в том, что операторы `&>` и `&>>` — это Bash расширения. Их нет в POSIX-стандарте. Если совместимость со стандартом важна, перенаправляйте поток ошибок в поток вывода с помощью оператора `2>&1`. Например, так:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README > result_and_errors.txt 2>&1
```

Такое перенаправление называется **дублированием потоков** (duplicating). Применяйте его для записи двух потоков в файл или передаче их данных через конвейер другой команде.

Будьте осторожны с дублированием потоков. Легко допустить ошибку и перепутать порядок операторов в команде. Если вы работайте на Bash, всегда используйте операторы `&>` или `&>>`.

Вот пример ошибки с дублированием потоков:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README 2>&1 > result_and_errors.txt
```

В результате поток ошибок выводится на экран, а не в файл `result_and_errors.txt`. Почему команда работает неправильно? Ведь мы перенаправили поток ошибок в поток вывода оператором `2>&1`. Рассмотрим эту ошибку подробнее.

Стандарт POSIX вводит понятие [**файлового дескриптора**](https://ru.wikipedia.org/wiki/Файловый_дескриптор). Дескриптор — это указатель на файл или канал коммуникации. Дескрипторы, как абстракция, нужны для эффективной работы с потоками. При запуске программы дескрипторы потоков вывода и ошибок указывают на окно терминала. Их можно связать с файлом. В этом случае дескрипторы потоков будут указывать на этот файл. Подробнее этот механизм описан в [статье BashGuide](http://mywiki.wooledge.org/BashFAQ/055).

Вернёмся к нашему вызову утилиты find. Bash выполняет перенаправления потоков слева направо. Их порядок представлен в таблице 2-13.

{caption: "Таблица 2-13. Порядок перенаправления потоков", width: "100%"}
| Порядок | Перенаправление | Результат |
| --- | --- | --- |
| 1 | `2>&1` | Теперь поток ошибок указывает на то же, на что и поток вывода. В нашем случае это окно терминала. |
|  | | |
| 2 | `> result_and_errors.txt` | Теперь поток вывода указывает на файл `result_and_errors.txt`. При этом поток ошибок по-прежнему связан с окном терминала. |

Исправим наш вызов find. Для этого изменим порядок операторов перенаправления. Сначала должен идти вывод в файл, а потом дублирование. Получим следующее:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README > result_and_errors.txt 2>&1
```

В результате поток вывода связан с файлом. Затем поток ошибок перенаправляется в тот же файл.

Для записи потока вывода и потока ошибок в разные файлы укажите операторы перенаправления друг за другом. Например, так:
{line-numbers: false, format: Bash}
```
find / -path */doc/* -name README > result.txt 2> errors.txt
```

### Конвейеры

Для передачи данных между утилитами создавать временные файлы неудобно. Приходится запоминать их пути. После передачи данных эти файлы надо удалять, чтобы зря не расходовать место на жёстком диске. Если переданные данные сохранять не нужно, используйте [**конвейеры**](https://ru.wikipedia.org/wiki/Конвейер_(Unix)) (pipeline). Они удобнее временных файлов. Конвейер — это механизм взаимодействия процессов. Он строится на прямой передаче сообщений без использования файловой системы.

Рассмотрим пример. Предположим, что в документации по Bash надо найти информацию о [лицензии](https://ru.wikipedia.org/wiki/Лицензия_на_программное_обеспечение) на интерпретатор. Это можно сделать утилитой grep. Просто запустите утилиту в каталоге с документацией:
{line-numbers: false, format: Bash}
```
grep -R "GNU" /usr/share/doc/bash
```

Альтернативное решение — искать информацию о лицензии в info справке по Bash. Конвейеры позволяют обработать поток вывода программы и быстро найти в нём нужное. Команда для поиска в выводе утилиты info выглядит так:
{line-numbers: false, format: Bash}
```
info bash | grep -n "GNU"
```

Утилита info выводит свой результат на поток вывода. Далее в команде идёт символ `|`. Он означает, что вывод команды слева передаётся на ввод команде справа. Таким образом утилита grep получит текст справки по Bash. В этом тексте она ищет строки со словом "GNU". Если Bash распространяется под [GNU GPL](https://ru.wikipedia.org/wiki/GNU_General_Public_License) лицензией, вывод grep будет непустым.

В вызов утилиты grep мы добавили опцию `-n`. Благодаря ей, grep выводит номера найденных строк. Это удобно для поиска конкретного места в файле.

#### du

Рассмотрим пример использования конвейеров посложнее. GNU-утилита du оценивает использование дискового пространства. Запустите её без параметров в текущем каталоге. Она **рекурсивно** пройдёт по всем его подкаталогам и выведет занимаемое ими пространство.

Рекурсивный обход означает повторение операции перехода в подкаталог. Алгоритм обхода выглядит так:

1. Проверить содержимое текущего каталога.

2. Если есть не посещённый подкаталог, перейти в него и начать с пункта 1 алгоритма.

3. Если все подкаталоги посещены, перейти на уровень выше и начать с пункта 1 алгоритма.

4. Если перейти на уровень выше нельзя, завершить алгоритм.

Следуя этому алгоритму, мы обойдём все подкаталоги от выбранной точки файловой системы. Это универсальный алгоритм обхода. К нему можно добавить любое действие над каждым найденным подкаталогом. В случае утилиты du это расчёт занимаемого дискового пространства. Тогда алгоритм утилиты можно записать так:

1. Проверить содержимое текущего каталога.

2. Если есть не посещённый подкаталог, перейти в него и начать с пункта 1 алгоритма.

3. Если все подкаталоги посещены или их нет:

    3.1 Рассчитать и вывести на экран дисковое пространство, занимаемое текущим каталогом.

    3.2 Перейти на уровень выше.

    3.3 Начать с пункта 1 алгоритма.

4. Если перейти на уровень выше нельзя, завершить алгоритм.

Утилит du принимает на вход пути до каталогов и файлов. Каталоги она обойдёт рекурсивно, а для файлов выведет их объём.

Вызовите утилиту du для системного каталога `/usr/share` следующим образом:
{line-numbers: false, format: Bash}
```
du /usr/share
```

Вот сокращенный пример её вывода:
{line-numbers: true, format: Bash}
```
261     /usr/share/aclocal
58      /usr/share/awk
3623    /usr/share/bash-completion/completions
5       /usr/share/bash-completion/helpers
3700    /usr/share/bash-completion
2       /usr/share/cmake/bash-completion
2       /usr/share/cmake
8       /usr/share/cygwin
1692    /usr/share/doc/bash
85      /usr/share/doc/flex
...
```

Эта таблица состоит из двух столбцов. В правом указан подкаталог, а в левом — сколько байтов он занимает на диске. В этот вывод можно добавить статистику по файлам в подкаталогах. Для этого укажите опцию `-a`. Получится следующая команда:
{line-numbers: false, format: Bash}
```
du /usr/share -a
```

Опция `-h` сделает вывод утилиты du нагляднее. С ней утилита будет переводить байты в килобайты, мегабайты и гигабайты.

Предположим, что мы оцениваем размер HTML файлов в каталоге `/usr/share`. Чтобы вывести такую статистику, выполните следующую команду:
{line-numbers: false, format: Bash}
```
du /usr/share -a -h | grep "\.html"
```

Здесь вывод утилиты du передаётся на вход grep через конвейер. Далее grep выводит строки, в которых встречается шаблон "\.html".

Почему в шаблоне "\.html" точка экранирована обратным слэшем \ ? Дело в том, что точка означает однократное вхождение любого символа. Если указать шаблон ".html", в вывод утилиты grep попадут лишние файлы (например, `pod2html.1perl.gz`) и подкаталоги (`/usr/share/doc/pcre/html`). Если точку экранировать, утилита grep обработает её как символ точка.

В примере с утилитами du и grep конвейер объединяет две команды. Но количество объединяемых команд не ограничено. Для примера отсортируем найденные HTML файлы в порядке убывания. Для этого применим утилиту sort. Получим такую команду:
{line-numbers: false, format: Bash}
```
du /usr/share -a -h | grep "\.html" | sort -h -r
```

По умолчанию утилита sort сортирует строки в порядке возрастания по алфавиту ([**лексикографическая сортировка**](https://ru.wikipedia.org/wiki/Лексикографический_порядок)). Например, есть файл со следующими строками:
{line-numbers: true, format: text}
```
abc
aaaa
aaa
dca
bcd
dec
```

Утилита sort, вызванная без опций, отсортирует строки файла так:
{line-numbers: true, format: text}
```
aaa
aaaa
abc
bcd
dca
dec
```

Чтобы обратить порядок сортировки, укажите опцию sort `-r`. С ней сортировка файла будет такой:
{line-numbers: true, format: text}
```
dec
dca
bcd
abc
aaaa
aaa
```

В выводе утилиты du в первом столбце указаны размеры файлов. Именно их будет сортировать sort. Размеры файлов — это числа. Из-за этого лексикографическая сортировка не подойдёт. Чтобы понять почему, рассмотрим пример.

Предположим, есть файл с числами:
{line-numbers: true, format: text}
```
3
100
2
```

После лексикографической сортировки этого файла по возрастанию получим:
{line-numbers: true, format: text}
```
100
2
3
```

Число 100 оказалось меньше 2 и 3. Причина в том, что ASCII-код символа 1 меньше чем символов 2 и 3. Чтобы отсортировать целые числа по их значению, используйте опцию sort `-n`.

В нашем конвейере из трёх команд утилита du вызывается с опцией `-h`. Это значит, что в её выводе байты будут переведены в более крупные единицы измерения. Чтобы утилита sort обработала их корректно, вызовите её с той же опцией `-h`.

Конвейеры можно сочетать с перенаправлением потоков. Чтобы сохранить отфильтрованный и отсортированный вывод утилиты du в файл, выполните следующую команду:
{line-numbers: false, format: Bash}
```
du /usr/share -a -h | grep "\.html" | sort -h -r > result.txt
```

В результате вывод утилиты sort будет записан в файл `result.txt`.

Предположим, вы сочетаете конвейеры и перенаправление потоков. При этом вам нужно поток выходных данных надо направить и в файл, и на вход утилите. Как это сделать? У Bash нет встроенного механизма для этой задачи. Но её можно решить GNU-утилитой tee. Рассмотрим пример.

Выполните следующую команду:
{line-numbers: false, format: Bash}
```
du /usr/share -a -h | tee result.txt
```

Результат утилиты du будет выведен на экран. Этот же результат будет записан в файл `result.txt`. Таким образом утилита tee продублировала свой поток ввода в указанный файл и в поток вывода. При этом содержимое `result.txt` перезапишется. Чтобы вместо этого дописать вывод tee в конец файла, используйте опцию `-a` утилиты.

Иногда нужно проверить поток данных между командами в конвейере. Утилита tee позволяет это сделать. Для этого добавьте её вызов между этими командами. Например так:
{line-numbers: false, format: Bash}
```
du /usr/share -a -h | tee du.txt | grep "\.html" | tee grep.txt | sort -h -r > result.txt
```

Вывод каждой команды конвейера попадёт в соответствующий файл. Эти промежуточные результаты пригодятся при поиске ошибок. Конечный результат работы конвейера по-прежнему будет записан в файл `result.txt`.

#### xargs

Параметр `-exec` утилиты find вызывает программу для каждого найденного файла или каталога. Такое поведение напоминает конвейер: find передаёт свой результат другой утилите. Эти механизмы похожи внешне, но устроены различно. Выбирайте подходящий механизм в зависимости от задачи.

Рассмотрим, как утилита find выполняет действие `-exec`. Действие всегда выполняется какой-то программой. Её запускает встроенный интерпретатор find. Он передаёт в неё всё, что нашла утилита find. Обратите внимание, что интерпретатор Bash не участвует в вызове `-exec`. Это означает, что в нём нельзя использовать встроенные команды Bash, функции, конвейеры, перенаправление потоков, условные операторы, циклы и другие конструкции Bash.

Попробуем выполнить следующую команду:
{line-numbers: false, format: Bash}
```
find ~ -type f -exec echo {} \;
```

Для обработки результатов find вызывается команда echo интерпретатора Bash. Этот вызов find выполнится корректно. Почему? На самом деле в нашем примере вызывается не команда Bash, а GNU-утилита. Некоторые встроенные команды Bash реализованы в виде отдельных GNU-утилит. Они хранятся в системном каталоге `/bin`. Среди них вы можете найти и файл `/bin/echo`. Именно он вызывается в нашем примере.

Если в действии `-exec` не обойтись без конструкции или Bash-команды, запустите интерпретатор явно и передайте в него команду. Например, так:
{line-numbers: false, format: Bash}
```
find ~ -type f -exec bash -c 'echo {}' \;
```

Эта команда даст тот же результат, что и предыдущая с вызовом утилиты echo. На экран будет выведен результат поиска find.

Вывод find можно перенаправить другой утилите через конвейер. В этом случае через конвейер передаётся текст, а не отдельные имена файлов и каталогов. Например, выполните следующую команду:
{line-numbers: false, format: Bash}
```
find ~ -type f | grep "bash"
```

Вы получите вывод наподобие следующего:
{line-numbers: true, format: Bash}
```
/home/ilya.shpigor/.bashrc
/home/ilya.shpigor/.bash_history
/home/ilya.shpigor/.bash_logout
/home/ilya.shpigor/.bash_profile
```

Конвейер передал вывод find на стандартный поток ввода утилите grep. В результате grep отфильтровала текст и вывела только имена файлов, в которых встречается шаблон "bash".

Когда find передаёт свои результаты в действие `-exec`, это не текст на стандартном потоке ввода. Вместо этого конструируется команда вызова сторонней утилиты. Имена найденных find файлов и каталогов передаются, как параметры вызываемой утилиты. Можно ли добиться такого же поведения с помощью конвейера? Да. Для этого воспользуйтесь GNU-утилитой xargs.

Изменим наш пример с find и grep. Вместо того чтобы фильтровать имена файлов, будем фильтровать их содержимое. Для этого в утилиту grep надо передать не текст на стандартный поток ввода, а имена файлов через параметры командной строки. Добавим вызов xargs в нашу команду:
{line-numbers: false, format: Bash}
```
find ~ -type f | xargs grep "bash"
```

I> Эта команда не сможет корректно обработать файлы, имена которых содержат пробелы и символы перевода строки. Решение этой проблемы рассмотрим в следующем разделе.

Вывод этой команды выглядит так:
{line-numbers: true, format: Bash}
```
/home/ilya.shpigor/.bashrc:# ~/.bashrc: executed by bash(1) for interactive shells.
/home/ilya.shpigor/.bashrc:# The copy in your home directory (~/.bashrc) is yours, please
/home/ilya.shpigor/.bashrc:# User dependent .bashrc file
/home/ilya.shpigor/.bashrc:# See man bash for more options...
/home/ilya.shpigor/.bashrc:# Make bash append rather than overwrite the history on disk
/home/ilya.shpigor/.bashrc:# When changing directory small typos can be ignored by bash
...
```

Утилита xargs конструирует команду из переданных в неё параметров и стандартного потока ввода. В получившейся команде сначала идут параметры xargs, а потом слова из потока ввода. Обратимся к нашему примеру. Предположим, что первый найденный find файл — это `~/.bashrc`. Наш вызов xargs после конвейера выглядит так:
{line-numbers: false, format: Bash}
```
xargs grep "bash"
```

В этот вызов передаётся два параметра командной строки: `grep` и "bash". Значит начало сконструированной xargs команды выглядит так:
{line-numbers: false, format: Bash}
```
grep "bash"
```

Дальше к этой команде добавляется текст из потока ввода. В потоке ввода найденный find файл `~/.bashrc`. Поэтому конечная команда, сконструированная xargs выглядит так:
{line-numbers: false, format: Bash}
```
grep "bash" ~/.bashrc
```

Утилита xargs выполняет сконструированную команду самостоятельно без вызова Bash. Поэтому на неё накладываются те же ограничения, что и на действие `-exec` утилиты find.

Утилита xargs добавляет в конец конструируемой команды всё, что получает через поток ввода. В некоторых случаях место этой подстановки надо изменить. Для этого используйте параметр `-I`.

Рассмотрим пример. Допустим, что надо скопировать найденные файлы в домашний каталог пользователя. Это можно сделать следующей командой:
{line-numbers: false, format: Bash}
```
find /usr/share/doc/bash -type f -name "*.html" | xargs -I % cp % ~
```

Параметр `-I %` сообщает утилите `xargs`, что текст из потока ввода надо подставить вместо символа % в конструируемой команде. В нашем примере утилита cp вызывается для каждой строки, которую конвейер передаёт в xargs. Поэтому xargs сконструирует две следующие команды:
{line-numbers: true, format: Bash}
```
cp /usr/share/doc/bash/bash.html /home/ilya.shpigor
cp /usr/share/doc/bash/bashref.html /home/ilya.shpigor
```

Опция `-t` утилиты xargs выводит на экран сконструированных команд перед их исполнением. Использовать эту опцию можно так:
{line-numbers: false, format: Bash}
```
find /usr/share/doc/bash -type f -name "*.html" | xargs -t -I % cp % ~
```

Мы рассмотрели примеры комбинации утилиты find и конвейеров. Это исключительно учебные примеры для образовательных целей. Не делайте так в ваших Bash-скриптах. Вместо конвейеров предпочитайте обрабатывать найденные файлы действием `-exec`. Тогда вы избежите ошибок обработки файлов, содержащих пробелы и перевод строки.

Один из немногих случаев, когда комбинация утилиты find и конвейера оправдана — это параллельная обработка найденных файлов.

Рассмотрим пример. При вызове утилиты cp через действие `-exec` файлы копируются по очереди друг за другом. Это неэффективно, если у вашего жёсткого диска высокая скорость доступа. Копирование файлов можно ускорить, если запустить одновременно несколько процессов. Параметр `-P` утилиты xargs указывает максимальное количество параллельно работающих процессов. Они будут выполнять сконструированные команды.

Предположим, что у процессора вашего компьютера четыре ядра. Тогда копирование можно выполнять в четыре параллельных потока. Команда для этого выглядит так:
{line-numbers: false, format: Bash}
```
find /usr/share/doc/bash -type f -name "*.html" | xargs -P 4 -I % cp % ~
```

В результате файлы будут копироваться по четыре штуки за раз. Как только один из параллельных процессов завершится, начнётся копирование следующего файла. В зависимости от конфигурации вашего процессора и жёсткого диска это может значительно ускорить выполнение команды.

Для обработки данных на потоке ввода есть целый ряд GNU-утилит. Обычно их используют вместе с конвейерами для поиска и анализа текста. Самые часто используемые из этих утилит приведены в таблице 2-14.

{caption: "Таблица 2-14. GNU-утилиты для обработки стандартного потока ввода", width: "100%"}
| Утилита | Описание | Примеры |
| --- | --- | --- |
| `xargs` | Конструирует команду по параметрам командной строки и тексту из стандартного потока ввода. | `find . -type f -print0 | xargs -0 cp -t ~` |
|  | | |
| `grep` | Ищет текст по указанному шаблону. | `grep -A 3 -B 3 "GNU" file.txt` |
| | | `du /usr/share -a | grep "\.html"` |
|  | | |
| `tee` | Перенаправляет потока ввода одновременно в поток вывода и в файл. | `grep "GNU" file.txt | tee result.txt` |
|  | | |
| `sort` | Сортирует строки из потока ввода в | `sort file.txt` |
| | прямом и обратном (параметр `-r`) порядке. | `du /usr/share | sort -n -r` |
|  | | |
| `wc` | Считает строки (параметр `-l`), слова (`-w`), | `wc -l file.txt` |
| | буквы (`-m`) и байты (`-с`) в указанном файле или потоке ввода. | `info find | wc -m` |
|  | | |
| `head` | Выводит указанное число байтов | `head -n 10 file.txt` |
| | (параметр `-c`) или строк (`-n`) файла или текста из начала потока ввода. | `du /usr/share | sort -n -r | head -10` |
|  | | |
| `tail` | Выводит указанное число байтов | `tail -n 10 file.txt` |
| | (параметр `-c`) или строк (`-n`) файла или текста из конца потока ввода. | `du /usr/share | sort -n -r | tail -10` |
|  | | |
| `less` | Утилита для навигации по тексту из | `less /usr/share/doc/bash/README` |
|  | стандартного потока ввода. Для выхода из неё нажмите клавишу Q. | `du | less` |

### Проблемы передачи имён файлов через конвейер

Конвейеры часто используют неправильно для обработки результатов утилит ls и find. Разберёмся в причине таких ошибок. Для этого рассмотрим несколько примеров.

Ожидается, что следующие две команды для поиска HTML файлов вернут одинаковый результат:
{line-numbers: true, format: Bash}
```
find /usr/share/doc/bash -name "*.html"
ls /usr/share/doc/bash | grep "\.html"
```

В общем случае их результаты будут отличаться. Дело не в том, что утилиты find и grep по-разному обрабатывают шаблон поиска. Проблема в передаче имён файлов через конвейер.

Стандарт POSIX разрешает любые символы в именах файлов. В том числе пробелы и перевод строки. Единственный запрещённый символ — это [**нуль-терминатор**](https://ru.wikipedia.org/wiki/Нуль-терминированная_строка) (NULL). К чему может привести это правило? Обратимся к конкретному примеру.

Создайте в домашнем каталоге пользователя файл с символом перевода строки в имени. Этот символ обозначается как `\n`. Чтобы создать такой файл, вызовите утилиту touch:
{line-numbers: false, format: Bash}
```
touch ~/$'test\nfile.txt'
```

Утилита touch меняет время последнего изменения указанного файла. После вызова touch это время будет равно текущему. Если файла не существует, утилита создаст его пустым.

Для нашего примера создайте ещё два файла: `test1.txt` и `file1.txt`. Выполните следующую команду:
{line-numbers: false, format: Bash}
```
touch ~/test1.txt ~/file1.txt
```

Теперь вызовем утилиту ls в домашнем каталоги пользователя. Её вывод обработаем с помощью grep. Для этого выполните две следующие команды:
{line-numbers: true, format: Bash}
```
ls ~ | grep test
ls ~ | grep file
```

Их вывод приведён на иллюстрации 2-27.

{caption: "Иллюстрация 2-27. Результат обработки вывода ls с помощью grep", width: "100%"}
![ls и grep](images/BashShell/ls-grep.png)

Обратите внимание, что имя файла `test\nfile.txt` оказалось обрезано. Утилита ls сама по себе выводит его в полной форме 'test'$'\n''file.txt'. Однако, при передаче через конвейер символ `\n` заменяется на перевод строки и имя делится на две части. Поэтому grep обрабатывает обе части по отдельности так, как будто это два разных файла.

Это не единственная проблема. Предположим, что вы копируете файл с пробелом в имени (например, `test file.txt`). Из-за пробела следующая команда завершится с ошибкой:
{line-numbers: false, format: Bash}
```
ls ~ | xargs cp -t ~/tmp
```

В этом случае xargs сконструирует такой вызов утилиты cp:
{line-numbers: false, format: Bash}
```
cp -t ~/tmp test file.txt
```

Эта команда копирует файлы `test` и `file.txt` в каталог `~/tmp`. Но в нашем случае ни одного из этих файлов не существует. Причиной ошибки стал механизм word splitting. Он разделил имя файла с пробелом на два отдельных имени. Ошибка решается двойными кавычками. Например, так:
{line-numbers: false, format: Bash}
```
ls ~ | xargs -I % cp -t ~/tmp "%"
```

Но если в имени файла стоит не пробел, а перевод строки, добавление кавычек не поможет. Как быть в такой ситуации? Ответ — не используйте ls. Утилита find с действием `-exec` лучше справится с этой задачей. Например:
{line-numbers: false, format: Bash}
```
find . -name "*.txt" -exec cp -t tmp {} \;
```

Иногда нужно обработать найденные файлы командой, сконструированной утилитой xargs. В этом случае используйте опцию `-print0` утилиты find. Например, так:
{line-numbers: false, format: Bash}
```
find . -type f -print0 | xargs -0 -I % bsdtar -cf %.tar %
```

Опция `-print0` меняет формат вывода find. С ней пути до найденных файлов и каталогов выводятся с нуль-терминатором в качестве разделителя. Без опции `-print0` разделителем выступает перевод строки.

Если формат вывода find изменился, надо также поменять формат ввода xargs. По умолчанию утилита xargs ожидает на вход строки с разделителем `\n`. Если передать ей опцию `-0`, она будет ожидать разделитель нуль-терминатор. Таким образом мы согласовали формат вывода одной утилиты и ввода другой.

Формат вывода утилиты grep тоже можно изменить для передачи через конвейер. Для этого используйте опцию `-Z`. Она разделяет файлы в выводе grep нуль-терминатором. Эта опция аналогична `-print0` у find. Пример её использования:
{line-numbers: false, format: Bash}
```
grep -RlZ "GNU" . | xargs -0 -I % bsdtar -cf %.tar %
```

Эта команда ищет файлы в которых встречается шаблон "GNU". Их имена, разделённые нуль терминатором, передаются утилите xargs. Она конструирует вызов утилиты bsdtar для архивации найденных файлов.

Из рассмотренных примеров можно сделать такие выводы:

1. При передаче имён файлов через конвейер помните о пробелах и переводах строк.

2. Всегда избегайте обработки вывода утилиты ls. Вместо неё используйте find с действием `-exec`.

3. Если без xargs не обойтись, всегда используйте опцию `-0`. На вход утилите передавайте только файлы, разделённые нуль-терминатором.

{caption: "Упражнение 2-7. Конвейеры и перенаправление потоков ввода-вывода", format: text, line-numbers: false}
```
Напишите команду для архивирования фотографий с помощью утилиты bsdtar.
Если вы пользователь Linux или macOS, используйте утилиту tar.
Фотографии хранятся в структуре каталогов из упражнения 2-6:

~/
  photo/
        2019/
             11/
             12/
        2020/
             01/

Фотографии одного месяца попадают в один архив.
После выполнения команды получится следующее:

~/
  photo/
        2019/
             11.tar
             12.tar
        2020/
             01.tar
```

### Логические операторы

Конвейеры позволяют сочетать несколько команд. В результате получается [**линейный алгоритм**](https://ru.wikipedia.org/wiki/Алгоритм#Виды_алгоритмов). В таком алгоритме действия выполняются последовательно друг за другом без каких либо условных операторов.

Предположим, что мы реализуем более сложный алгоритм. В нём результат выполнения первой команды определяет следующий шаг. Если команда выполнилась успешно, требуется одно действие. В противном случае — другое. Тогда конвейер нам не подойдёт. Про такой алгоритм говорят, что он содержит [**ветвление**](https://ru.wikipedia.org/wiki/Ветвление_(программирование)). Сам алгоритм называется **разветвляющимся**.

Рассмотрим разветвляющийся алгоритм на примере. Нужно написать команду для копирования каталога. В случае её успешного выполнения в лог-файл записывается строка "OK". В противном случае пишется строка "Error".

Применив конвейер, можно составить такую команду:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup | echo "OK" > result.log
```

К сожалению, эта команда не сработает. Строка "OK" запишется в файл `result.log` независимо от результата копирования. Даже если каталога `docs` не существует, в лог-файле будет сообщение об успешном выполнении.

Чтобы результат утилиты cp определял вывод echo, воспользуемся оператором &&. Получим такую команду:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup && echo "OK" > result.log
```

Теперь строка "OK" выводится в файл только тогда, когда утилита cp успешно скопирует каталог.

Что такое оператор &&? На самом деле это операция логического И. Но в данном случае она выполняется не над выражениями (условиями), а над командами Bash (действиями). Может возникнуть вопрос: какой смысл выполнять логическую операцию над двумя действиями? Давайте разберёмся.

Стандарт POSIX требует, чтобы каждая запущенная программа при завершении выдавала [**код возврата**](https://ru.wikipedia.org/wiki/Код_возврата) (exit status). При успешном завершении код равен нулю. В противном случае он может принимать любое значение от 1 до 255.

Когда логический оператор применяется к команде, он работает с её кодом возврата. Поэтому сначала команда исполняется, а потом её код возврата используется в логическом выражении.

Вернёмся к нашему примеру:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup && echo "OK" > result.log
```

Предположим, что утилита cp завершилась успешно. В этом случае она вернёт ноль. В Bash ноль соответствует значению "истина". Поэтому левая часть нашего оператора && будет истинной. Этой информации ещё не достаточно, чтобы вычислить значение всего выражения. Оно может быть истинным или ложным в зависимости от правого операнда. Чтобы узнать его значение, оператор && должен выполнить команду echo. Она всегда завершается успешно и возвращает код ноль. Таким образом результат работы оператора && будет "истина".

Возникает следующий вопрос: как мы используем результат оператора && в нашем примере? Ответ — никак. Логические операторы нужны для вычисления выражений. Но в Bash их часто применяют ради побочных эффектов, а именно — порядка вычисления операндов.

Рассмотрим случай, когда утилита cp в нашей команде завершилась с ошибкой. Тогда её код возврата будет отличен от нуля. Для Bash это эквивалентно значению "ложь". В этом случае оператор && уже может вычислить значение всего выражения. Ему не нужно вычислять правый операнд. Вспомните: если хотя бы один операнд логического И ложный, всё выражение будет ложным. Таким образом код возврата команды echo не важен. Поэтому она не будет выполнена и записи в файл `result.log` не произойдёт.

Вычисление только тех операндов, которые достаточны для вывода значения всего выражения, называется [**коротким замыканием**](https://en.wikipedia.org/wiki/Short-circuit_evaluation) (short-circuit).

I> Код возврата последней выполненной команды всегда сохраняется в переменной окружения Bash с именем `?`. Для вывода её значения на экран используйте команду echo. Например:
{line-numbers: false, format: Bash}
```
echo $?
```

В условии нашей задачи говорится, что при ошибке в лог-файл выводится строка "Error". Дополним нашу команду оператором логического ИЛИ, который в Bash обозначается как ||. Получим следующее:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup && echo "OK" > result.log || echo "Error" > result.log
```

Эта команда реализует нужный нам разветвляющийся алгоритм. Если утилита cp выполнится успешно, в лог-файл запишется "OK". В противном случае запишется "Error". Почему? Чтобы ответить на этот вопрос, сначала разберёмся в приоритете операций.

Для простоты обозначим все коды возврата команды буквами латинского алфавита. Утилита cp возвращает код A. Первая команда echo вернёт B, а вторая — C. Тогда команду можно записать в виде следующего выражения:
{line-numbers: false}
```
A && B || C
```

В Bash приоритет операторов && и || одинаковый. Выражение вычисляется слева направо. В таком случае говорят, что операторы [**левоассоциативны**](https://ru.wikipedia.org/wiki/Очерёдность_операций). Учитывая это, можно переписать наше выражение в следующем виде:
{line-numbers: false}
```
(A && B) || C
```

Добавление скобок ничего не меняет. По-прежнему сначала вычисляется выражение (A && B). Затем при необходимости вычисляется операнд C.

Итак, что произойдёт, если A равно истине? В этом случае оператор && вычислит свой правый операнд B. Тогда в лог-файл будет записана строка "OK". Далее Bash обработает оператор ||. В этот момент уже известно значение его левой части (A && B). Оно равно истине. Поэтому на значение всего выражения правый операнд не повлияет. Его вычислять не нужно. Для логического ИЛИ всё выражение истинно, если хотя бы один из операндов истинен. Поэтому строка "Error" не будет записана в лог-файл.

Если значение A ложь, выражение (A && B) также будет ложным. При этом вычисление операнда B не требуется. Поэтому вывода "OK" в лог-файл не будет. Bash перейдёт к следующему оператору ||. Интерпретатору уже известно, что левый операнд ложный. Поэтому для вычисления всего выражения надо узнать значение его правой части. В результате выполнится вторая команда echo и строка "Error" запишется в лог-файл.

Принцип работы логических операторов и короткого замыкания неочевиден. Возможно, вам понадобится какое-то время, чтобы в нём разобраться. Постарайтесь это сделать. Практически в каждом современном языке программирования встречаются логические выражения. Поэтому понимание правил их вычисления пригодится вам в дальнейшем.

Команды в языке Bash могут сочетаться не только конвейерами и логическими операторами. Их также можно объединять через точку с запятой. Команды следующие друг за другом через ; выполняются по порядку без каких либо условий.

Рассмотрим пример. Предположим, что нужно скопировать два каталога по разны целевым путям. Одним вызовом утилиты cp этого не сделать. Но можно объединить вызовы в одну команду. Например:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup ; cp -R ~/photo ~/photo-backup
```

В результате утилита cp вызывается дважды независимо от результата копирования каталога `docs`. Даже если произойдёт ошибка, каталог `photo` всё равно будет скопирован.

Отличается ли поведение команд следующих через ; от конвейера? Ошибка выполнения первой части команды не повлияет на работу второй. То есть алгоритм будет линейным в обоих случаях. В примере с копированием каталогов разницы никакой нет. Утилита cp игнорирует входные данные на потоке ввода. Следующая команда выполняет тот же самый алгоритм копирования:
{line-numbers: false, format: Bash}
```
cp -R ~/docs ~/docs-backup | cp -R ~/photo ~/photo-backup
```

Однако, в общем случае различие есть. Команды, следующие через ; выполняются независимо друг от друга. Если используется конвейер, зависимость возникает. Стандартный поток вывода первой команды передаётся на вход второй. Это может изменить её поведение.

Сравните следующие две команды:
{line-numbers: true, format: Bash}
```
ls /usr/share/doc/bash | grep "README" * -
ls /usr/share/doc/bash ; grep "README" * -
```

Параметр `-` утилиты grep добавляет данные со стандартного потока ввода в конец команды.

Иллюстрация 2-28 демонстрирует результаты обеих команд.

{caption: "Иллюстрация 2-28. Результаты выполнения команд", width: "100%"}
![Конвейер и разделитель](images/BashShell/pipe-vs-connector.png)

Отличается даже поведение утилиты ls. При использовании конвейера её результат не выводится на экран, а перенаправляется на вход grep.

Разберёмся с выводом команд. Второй параметр grep — это шаблон "*". Поэтому сначала утилита обработает все файлы в текущем каталоге. Слово "README" найдено в одном из них с именем `xz.txt`. Поэтому на экран выводится следующая строка:
{line-numbers: false, format: Bash}
```
xz.txt:    README              This file
```

Далее grep обрабатывает вывод ls, полученный из потока ввода. В этих данных тоже встречается слово "README". Об этом сообщает следующий вывод:
{line-numbers: false, format: Bash}
```
(standard input):README
```

Таким образом утилита grep обработала и файлы текущего каталога, и вывод ls.

В варианте команды с ; утилита ls выводит свой результат на экран. После этого вызывается утилита grep. Она обработает все файлы текущего каталога и поток ввода. Но теперь данных на потоке ввода нет. Поэтому grep найдёт слово "README" только в файле `xz.txt`.

{caption: "Упражнение 2-8. Логические операторы", format: text, line-numbers: false}
```
Напишите команду, реализующую следующий алгоритм:

1. Скопировать файл README с документацией по Bash в домашний каталог пользователя.

2. Архивировать скопированный файл ~/README.

3. Удалить скопированный файл ~/README.

Каждый шаг выполняется только, если предыдущий завершился успешно.
Результат каждого шага записывается в лог-файл result.txt.
```
