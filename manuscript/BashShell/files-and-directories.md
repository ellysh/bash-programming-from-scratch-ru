## Действия над файлами и каталогами

Мы узнали, как найти нужный файл или каталог на диске. Теперь поговорим о действиях над ними. По опыту работы с графическим интерфейсом ОС вы знаете, что любой файл или каталог можно:

1. Создать
2. Удалить
3. Скопировать
4. Перенести или переименовать

Каждое из этих действий выполняется специальной GNU-утилитой. Они описаны в таблице 2-7.

{caption: "Таблица 2-7. Утилиты для работы с файлами и каталогами", width: "100%"}
| Утилита | Действие | Примеры |
| --- | --- | --- |
| `mkdir` | Создать каталога с указанным именем и путём. | `mkdir /tmp/docs` |
| | | `mkdir -p tmp/docs/report` |
|  | | |
| `rm` | Удалить указанный файл или каталог по | `rm readme.txt` |
| | абсолютному или относительному пути. | `rm -rf ~/tmp` |
|  | | |
| `cp` | Скопировать файл или каталог. Первым | `cp readme.txt tmp/readme.txt` |
| | параметром передаётся текущий путь, а вторым — целевой. | `cp -r /tmp ~/tmp` |
|  | | |
| `mv` | Перенести или переименовать указанный первым | `mv readme.txt documentation.txt.` |
| | параметром файл или каталог. | `mv ~/tmp ~/backup` |

У каждой из этих утилит есть опция `--help`. Она выводит краткую справку. Если нужный вам режим работы утилиты будет пропущен в книге, вы можете узнать о нём из документации. Если краткой справки окажется недостаточно, обратитесь к системе info или man.

Рассмотрим примеры использования утилит из таблицы 2-7. 

### mkdir

Утилита mkdir создаёт новый каталог по указанному абсолютному или относительному пути. Путь передаётся в первом параметре. Например, следующая команда создаёт каталог `docs` в домашнем каталоге пользователя:
{line-numbers: false, format: Bash}
```
mkdir ~/docs
```

Мы указали абсолютный путь до каталога `docs`. Его можно создать и по относительному пути. Для этого сначала перейдём в домашний каталог пользователя, а затем выполним mkdir:
{line-numbers: true, format: Bash}
```
cd ~
mkdir docs
```

Для создания вложенных каталогов у утилиты mkdir есть опция `-p`. Например, документы с отчётами за 2019 год должны находиться по пути `∼/docs/reports/2019`. Предположим, что каталогов `docs` и `reports` ещё нет. Вам нужно создать сначала их и только потом каталог `2019`. Это можно сделать одной командой mkdir с опцией `-p`:
{line-numbers: false, format: Bash}
```
mkdir -p ~/docs/reports/2019
```

Если каталоги `docs` и `reports` уже существуют, команда всё равно выполнится успешно. В этом случае утилита mkdir создаст только недостающую часть пути — каталог `2019`.

### rm

Утилита rm удаляет файлы и каталоги. Их можно указать по абсолютному или относительному пути.

Например, две следующие команды делают одно и тоже. Они удаляют файл `report.txt`:
{line-numbers: true, format: Bash}
```
rm report.txt
rm ~/docs/reports/2019/report.txt
```

Утилита rm может удалить несколько файлов за раз. Для этого укажите их имена через пробел. Например так:
{line-numbers: false, format: Bash}
```
rm report.txt ~/docs/reports/2019/report.txt
```

Если нужно удалить много файлов, перечислять их все в вызове утилиты неудобно. В этом случае используйте шаблон поиска Bash. Например, удалим все текстовые файлы, имена которых начинаются со слова "report". Это документы с отчётами. Вызов rm для них выглядит так:
{line-numbers: false, format: Bash}
```
rm ~/docs/reports/2019/report*.txt
```

При удалении защищённого от записи файла, утилита rm выведет предупреждение как на иллюстрации 2-26.

{caption: "Иллюстрация 2-26. Предупреждение при удалении защищённого от записи файла", width: "100%"}
![Предупреждение `rm`](images/BashShell/rm-warning.png)

Чтобы удалить файл, нажмите клавишу Y (сокращение от yes), а затем Enter. Если вызвать утилиту с опцией `-f` или `--force`, предупреждения выводиться не будут. Пример такого вызова:
{line-numbers: false, format: Bash}
```
rm -f ~/docs/reports/2019/report*.txt
```

I> У опций GNU-утилит есть краткая и полная форма. Краткая форма состоит из одной буквы и начинается с тире `-`. Полная форма — это слово, перед которым стоит двойное тире `--`. Такой формат опций рекомендуется [POSIX-стандартом](https://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html) и [GNU-расширением](https://www.gnu.org/prep/standards/html_node/Command_002dLine-Interfaces.html) к нему.

Утилита rm не сможет удалить каталог, если не передать в неё дополнительную опцию. Если каталог пустой, для его удаления укажите опцию `-d` или `--dir`. Например:
{line-numbers: false, format: Bash}
```
rm -d ~/docs
```

Если в каталоге есть файлы или подкаталоги, вызовите утилиту с опцией `-r` или `--recursive`. Например так:
{line-numbers: false, format: Bash}
```
rm -r ~/docs
```

Эта команда удалит и пустой каталог `docs`. Чтобы проще запомнить, всегда указывайте опцию `-r` для удаления каталогов.

### cp и mv

Утилиты для копирования и переименования работают по одному принципу. Первым параметром они принимают файл или каталог, над котором выполняется действие. Второй параметр — это новый путь, где окажется копируемый или переносимый объект.

Например, скопируем файл `report.txt` в текущем каталоге. Для этого вызовем утилиту cp:
{line-numbers: false, format: Bash}
```
cp report.txt report-2019.txt
```

Эта команда создаст новый файл с именем `report-2019.txt`. Его содержимое такое же как у `report.txt`.

Предположим, что старый файл с именем `report.txt` не нужен. После копирования его можно удалить утилитой rm. Но лучше не копировать файл, а перенести его утилитой mv. Её вызов выглядит так:
{line-numbers: false, format: Bash}
```
mv report.txt report-2019.txt
```

Эта команда создаст новый файл с именем `report-2019.txt`. При этом она удалит старый файл `report.txt`. Таким образом утилита mv совмещает операции копирования и удаления.

Утилиты cp и mv работают с относительными и с абсолютными путями. Например, нужно скопировать файл из домашнего каталога в `~/docs/reports/2019`. Для этого выполните следующую команду:
{line-numbers: false, format: Bash}
```
cp ~/report.txt ~/docs/reports/2019
```

Команда скопирует файл `report.txt` по пути `~/docs/reports/2019/report.txt`.

Тот же результат можно получить по-другому. Перейдите в домашний каталог пользователя и вызовите утилиту cp с относительными путями. Например так:
{line-numbers: true, format: Bash}
```
cd ~
cp report.txt docs/reports/2019
```

Имя копии можно указать явно. Это полезно, когда оно должно отличаться от имени исходного файла. Для нашего примера вызов утилиты cp выглядит так:
{line-numbers: false, format: Bash}
```
cp ~/report.txt ~/docs/reports/2019/report-2019.txt
```

Перенос файлов из каталога в каталог работает точно так же как и копирование. Например, следующая команда перенесёт файл `report.txt`:
{line-numbers: false, format: Bash}
```
mv ~/report.txt ~/docs/reports/2019
```

А эта команда перенесёт файл и переименует:
{line-numbers: false, format: Bash}
```
mv ~/report.txt ~/docs/reports/2019/report-2019.txt
```

Переименовать каталог можно так же как и файл с помощью утилиты mv. Например:
{line-numbers: false, format: Bash}
```
mv ~/tmp ~/backup
```

Эта команда переименует каталог `tmp` в `backup`.

Утилита cp в обычном режиме работы не может копировать каталоги. Например, нужно скопировать каталог с временными файлами `/tmp` в домашний каталог пользователя. Следующая команда завершится с ошибкой:
{line-numbers: false, format: Bash}
```
cp /tmp ~
```

Чтобы копирование сработало, надо указать опцию `-r` или `--recursive`. Получим такой вызов:
{line-numbers: false, format: Bash}
```
cp -r /tmp ~
```

Предположим, вы копируете или переносите файл. Если по его новому пути уже есть файл с таким же именем, утилиты cp и mv запросят подтверждение операции. В этом случае копируемый файл перезапишет существующий.

Если вы проверили заранее, что существующий файл не нужен, его можно перезаписать без подтверждения. Для этого используйте опцию `-f` или `--force`. Например:
{line-numbers: true, format: Bash}
```
cp -f ~/report.txt ~/tmp
mv -f ~/report.txt ~/tmp
```

Обе команды перезапишут существующий файл `report.txt` в каталоге `tmp`. Подтверждать операцию при этом не нужно.

{caption: "Упражнение 2-6. Работа с файлами и каталогами", format: text, line-numbers: false}
```
Упорядочьте свои фотографии за последние три месяца с помощью GNU-утилит. Перед началом работы сделайте их резервную копию. Разделите все фотографии по годам и месяцам. Структура каталогов должна получиться примерно следующая:

~/
  photo/
        2019/
             11/
             12/
        2020/
             01/
```

### Права доступа

Утилита rm при удалении файла или каталога проверяет его [**права доступа**](https://ru.wikipedia.org/wiki/Права_доступа). Например, если файл защищён от записи, утилита выведет предупреждение. Что такое права доступа и для чего они нужны?

Права доступа ограничивают действия пользователя над файловой системой. За соблюдением этих прав следит операционная система. Благодаря этой функции, пользователи имеют доступ только к своим файлам и каталогам. При этом доступ к компонентам ОС ограничен.

Права доступа позволяют разным людям совместно использовать один компьютер. До появления персональных компьютеров такой режим работы практиковался повсеместно. Вычислительные ресурсы были дороги. Поэтому решать сразу несколько задач на одной машине было эффективнее.

Обратимся ещё раз к иллюстрации 2-26. При вызове утилиты ls с опцией `-l` выводится таблица. В ней каждому файлу и каталогу соответствует строка. Значение столбцов в строке следующее:

1. Права доступа.
2. Число ссылок (hard link) на файл или каталог.
3. Владелец.
4. Группа владельца.
5. Размер объекта в байтах.
6. Дата и время последнего изменения.
7. Имя файла или каталога.

Нас интересуют права доступа. Например, у файла `report.txt` они следующие: `-r--r--r--`. Разберёмся, что означает эта запись.

В Unix права доступа к файлу или каталогу хранятся в виде [**битовой маски**](https://ru.wikipedia.org/wiki/Битовая_маска). Битовая маска — это положительное целое число. В памяти оно хранится в двоичном виде, как последовательность нулей и единиц. Каждый бит маски хранит значение, которое не зависит от других битов. Поэтому в одной битовой маске можно упаковать набор значений.

Какие значения можно упаковать в битовую маску? Например, это могут быть признаки объекта. Каждый признак либо есть у объекта, либо нет. Если признак есть, представим его как бит со значением 1. Если признака нет, то его бит равен нулю.

Вернёмся к правам доступа к файлу. Представим эти права как следующие признаки:

1. Разрешение на чтение.
2. Разрешение на запись.
3. Разрешение на исполнении.

Эти признаки можно упаковать в маску из трёх битов.

Допустим, что к файлу есть полный доступ. Его содержимое можно прочитать или изменить. Сам файл можно скопировать, удалить или исполнить. Это значит, что файл имеет права на чтение, запись и исполнение. Запись разрешает не только изменение файла, но и его удаление. В этом случае маска с правами доступа к файлу выглядит так:
{line-numbers: false}
```
111
```

Все три бита в маске равны единицам.

Предположим, что читать и исполнять файл нельзя. Тогда первый бит маски, отвечающий за доступ на чтение, станет нулём. Третий бит (разрешение на исполнение) также станет нулём. В результате получим маску:
{line-numbers: false}
```
010
```

Для правильной работы с маской надо понимать, что означает каждый её бит. Сама маска не хранит этой информации. 

Мы рассмотрели упрощённый пример прав доступа. Теперь посмотрим, как эти права устроены в Unix.

Утилита ls выводит следующую строку с правами для файла `report.txt`:
{line-numbers: false}
```
-r--r--r--
```

Эта строка и есть битовая маска. В ней нулям соответствуют тире, а единицам буквы латинского алфавита. Тогда строку `-r--r--r--` можно представить в виде маски 0100100100. Если все биты маски равны единицам, утилита ls выведет строку `drwxrwxrwx`.

Строка прав доступа в Unix состоит из четырёх частей. Таблица 2-8 объясняет значение каждой из них.

{caption: "Таблица 2-8. Части строки прав доступа в Unix", width: "100%"}
| d | rwx | rwx | rwx |
| --- | --- | --- | --- |
| Признак каталога. | Права владельца файла или каталога. По умолчанию это тот, кто его создал. | Права группы пользователей, привязанной к файлу. По умолчанию это группа, к которой относится владелец. | Права всех остальных пользователей кроме владельца и группы, привязанной к файлу. |

Для удобства каждую из этих частей представляют отдельной битовой маской. На каждую из них отводится по 4 бита. Поэтому строку `-r--r--r--` можно представить в виде следующих четырёх масок:
{line-numbers: false}
```
0000 0100 0100 0100
```

Что означают латинские буквы в строке прав доступа? Они соответствуют битам, установленным в единицу. Позиция каждого бита определяет действие пользователя над объектом: чтение, запись и исполнение. Буквы упрощают работу с битовой маской для человека. Согласитесь, что строка `-rw-r--r--` проще для чтения, чем двоичное число 0000011001000100.

Таблица 2-9 объясняет смысл каждой буквы в строке прав доступа.

{caption: "Таблица 2-9. Буквы в строке прав доступа", width: "100%"}
| Буква | Значение для файла | Значение для каталога |
| --- | --- | --- |
| d | Если вместо буквы d первым символом стоит тире, это права для файла. | Права доступа соответствуют каталогу. |
|  | | |
| r | Чтение. | Вывод содержимого каталога. |
|  | | |
| w | Запись. | Создание, переименование или удаление файлов в каталоге. |
|  | | |
| x | Выполнение файла. | Переход в каталог, доступ к его файлам и подкаталогам. |
|  | | |
| — | Действие запрещено. | Действие запрещено. |

Предположим, что все пользователи системы имеют полный доступ к файлу. Тогда строка его прав доступа выглядит так:
{line-numbers: false}
```
-rwxrwxrwx
```

Для каталога с теми же правами, первый символ тире поменяется на букву d. Его строка прав доступа выглядит так:
{line-numbers: false}
```
drwxrwxrwx
```

I> Чтобы вывести группы, к которым относится текущий пользователь воспользуйтесь командой `groups`.

Теперь нам легко прочитать права доступа к файлам `report.txt` и `report1.txt` на иллюстрации 2-26. Первый могут читать все пользователи. Изменять и исполнять его не может никто. Второй файл могут читать все. Изменять может только владелец. Исполнять не может никто.

Мы рассмотрели команды и утилиты для работы с файловой системой. Каждая из них работает с указанным файлом или каталогом. Чтобы команда выполнилась успешно, указанный ей объект должен иметь определённые права. Таблица 2-10 демонстрирует необходимые права для каждой рассмотренной нами утилиты и команды.

{caption: "Таблица 2-10. Права доступа для работы команд и утилит", width: "100%"}
| Команда | Маска | Права доступа | Комментарий |
| --- | --- | --- | --- |
| `ls` | `r--` | Чтение | Только каталоги. |
|  | | | |
| `cd` | `--x` | Выполнение | Только каталоги. |
|  | | | |
| `mkdir` | `-wx` | Запись и выполнение. | Только каталоги. |
|  | | | |
| `rm` | `-w-` | Запись | Для каталогов надо указывать опцию `-r`. |
|  | | | |
| `cp` | `r--` | Чтение | Целевой каталог должен быть доступен на запись и исполнение. |
|  | | | |
| `mv` | `r--` | Чтение | Целевой каталог должен быть доступен на запись и исполнение. |
|  | | | |
| Исполнение | `r-x` | Чтение и выполнение. | Только для файлов. |

### Запуск файлов

В Windows есть строгие правила о том, какие файлы можно запускать. Расширение файла определяет его тип. Загрузчик Windows может запускать только файлы определённого типа. Они имеют расширение EXE и COM. Это сомпилированные исполняемые файлы приложений. Кроме них можно запускать скрипты. Их расширения могут быть BAT, JS, PY и т.д. Каждый тип скрипта привязан к одному из установленных в системе интерпретаторов. Запустить скрипт нельзя, если расширение его файла не соответствует интерпретатору.

Правила запуска файлов в Unix-окружении отличаются от Windows. В Unix можно запустить любой файл, если у него есть права на чтение и исполнение. В отличии от Windows его расширение не важно. Например, файл с именем `report.txt` может быть исполняемым.

В Unix нет соглашения о расширении исполняемых файлов. Поэтому из имени файла не всегда понятен его тип. Чтобы узнать тип файла, используйте утилиту file. На вход она принимает путь к файлу и выводит на экран его тип. Пример вызова утилиты:
{line-numbers: false, format: Bash}
```
file /usr/bin/ls
```

В окружении MSYS2 она выведет на эркан следующее:
{line-numbers: false, format: Bash}
```
/usr/bin/ls: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows
```

Вывод означает, что файл имеет тип [PE32](https://ru.wikipedia.org/wiki/Portable_Executable). Это исполняемый файл с машинным кодом. Он запускается загрузчиком Windows. Также в выводе указана разрядность файла: x86-64. Это значит, что утилита ls запустится только на 64-разрядных версиях Windows.

Если вы запустите ту же команду file на ОС Linux, её вывод будет отличаться. Например, он может выглядеть так:
{line-numbers: false, format: Bash}
```
/bin/ls: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=d0bc0fb9b3f60f72bbad3c5a1d24c9e2a1fde775, stripped
```

В Linux файл имеет тип [ELF](https://ru.wikipedia.org/wiki/Executable_and_Linkable_Format). Это исполняемый файл с машинным кодом. Его может запускать загрузчик Linux. Разрядность файла такая же как и в MSYS2: x86-64.

Мы научились отличать исполнемые файлы в Unix-окружении от неисполняемых. Теперь выясним, где их искать.

GNU-утилиты устанавливаются в систему по умолчанию. Они находятся в каталогах `/bin` и `/usr/bin`. Пути к GNU-утилитам хранятся в переменной Bash с именем `PATH`. Вопрос в том, куда устанавливаются новые приложения в Unix-окружении?

В Windows на системном диске есть каталоги `Program Files` и `Program Files (x86)`. По умолчанию все приложения устанавливаются в них. Для каждого приложения создаётся новый подкаталог (например, `C:\Program Files (x86)\Notepad++`). В процессе установки в него копируются исполняемые файлы, DLL библиотеки, файлы конфигурации и ресурсов. Эти файлы дополняют системные библиотеки Windows. Без них приложение не сможет работать. Вместо каталогов `Program Files` и `Program Files (x86)` можно выбрать другой путь установки (например, `D:\Programs`). В этом случае в нём будет создан подкаталог приложения со всеми его файлами.

В Unix-окружении принято два варианта установки программ. Первый вариант напоминает подход Windows. Приложение устанавливается в системный каталог `/opt`. В нём создаётся новый подкаталог (например, `/opt/teamviewer`). В подкаталог копируются все файлы приложения. Этот вариант установки обычно выбирают разработчики проприетарных программы с закрытым исходным кодом.

Утилиты и программы с открытым исходным кодом устанавливаются по-другому. Приложению для работы нужны файлы различного типа. В файловой системе Unix для каждого типа файлов есть свой системный каталог. Это значит, что исполняемые файлы всех приложений будут скопированы в один системный каталог. Документация для них окажется в другом каталоге. Файлы ресурсов всех приложений попадут в третий.

Таблица 2-11 объясняет назначение системных каталогов Unix.

{caption: "Таблица 2-11. Назначение системных каталогов Unix", width: "70%"}
| Каталог | Назначение |
| --- | --- |
| `/bin` | Исполняемые файлы системных утилит. |
|  | |
| `/etc` | Конфигурационные файлы. |
|  | |
| `/lib` | Библиотеки, необходимые для работы системных утилит. |
|  | |
| `/usr/bin` | Исполняемые файлы приложений пользователя. |
|  | |
| `/usr/lib` | Библиотеки, необходимые для приложений пользователя. |
|  | |
| `/usr/local` | Приложения, скомпилированные пользователем самостоятельно. |
|  | |
| `/usr/share` | Архитектурно-независимые файлы ресурсов приложений пользователя. |
|  | |
| `/var` | Файлы, создаваемые приложениями в процессе работы (например лог-файлы). |

Копирование всех файлов одного типа в специальные системные каталоги кажется спорным решением. Его минус в сложности сопровождения. Например, приложение обновляется до следующей версии. Для этого надо обновить все его файлы во всех системных каталогах. Если один из файлов будет пропущен, приложение перестанет работать.

У решения со специальными системными каталогами есть и сильная сторона. В Windows каждое приложение при установке копирует в свой каталог все необходимые ему файлы. Среди этих файлов есть и библиотеки с подпрограммами. Некоторым приложениям для работы нужны одни и те же библиотеки. В результате в файловой системе накапливаются десятки копий этих библиотек.

В Unix копирования библиотек удаётся избежать. Предположим, что все приложения соблюдают соглашение и устанавливают свои файлы в правильные каталоги. В этом случае каждая программа легко сможет найти файлы другой программы. Благодаря этому, один и тот же файл используется всеми приложениями, которым он нужен. Поэтому в файловой системе достаточно хранить единственный экземпляр каждой библиотеки.

Предположим, что мы установили приложение (например, браузер). Согласно таблице 2-11 его исполняемый файл (например, `firefox`) будет скопирован в каталог `/usr/bin`. Как нам его запустить из Bash? Есть несколько способов:

1. По имени исполняемого файла.
2. По абсолютному пути.
3. По относительному пути.

Рассмотрим каждый способ подробнее.

Первый вариант нам хорошо знаком. Именно таким образом мы вызывали GNU утилиты до сих пор. Например, запуск `find` из каталога `/usr/bin` выглядит следующим образом:
{line-numbers: false, format: Bash}
```
find --help
```

Точно так же мы запустим и браузер:
{line-numbers: false, format: Bash}
```
firefox
```

Это работает, потому что путь `/usr/bin` хранится в переменной `PATH`. Получив команду `firefox`, Bash ищет исполняемый файл с соответствующим именем в каждом из путей в `PATH`.

I> Обратите внимание, что порядок поиска исполняемого файла соответствует порядку путей в переменной `PATH`. Предположим, что файл есть в обоих каталогах `/usr/local/bin` и `/usr/bin`. В то же время `/usr/local/bin` идёт первым в `PATH`. Тогда Bash всегда будет запускать файл из него.

Во втором способе запуска мы просто набираем абсолютный путь к исполняемому файлу:
{line-numbers: false, format: Bash}
```
/usr/bin/firefox
```

Как правило, этот способ применяется для запуска проприетарных приложений, установленных в каталог `/opt`. Этот каталог обычно не указывается в переменной `PATH`. Поэтому Bash не может самостоятельно найти исполняемый файл.

Третий способ запуска файла покажется непривычным для Windows пользователей. Если вы перейдёте в каталог `/usr`, то запустить браузер можно командой:
{line-numbers: false, format: Bash}
```
bin/firefox
```

Это очевидно и не вызывает вопросов. Но предположим, что исполняемый файл `firefox` находится в каталоге `/opt/firefox/bin`. Перейдём в этот каталог командой `cd` и попробуем запустить браузер:
{line-numbers: true, format: Bash}
```
cd /opt/firefox/bin
firefox
```

Такой способ не сработает. Почему? Дело в том, что сейчас мы попытались запустить приложение по имени исполняемого файла. В этом случае Bash будет искать его в путях переменной `PATH`. Но приложение установлено в `/opt`, которого в `PATH` нет. Тогда Bash выдаст ошибку, что файл не найден.

Правильно указывать относительный путь с текущим каталогом:
{line-numbers: false, format: Bash}
```
./firefox
```

Тогда Bash поймёт, что искать исполняемый файл следует в текущем каталоге.

Рассмотрим, как добавить свой путь (например, `/opt/firefox/bin`) в переменную `PATH`. Для этого выполните следующие действия:

1. Перейдите в домашний каталог пользователя:
{line-numbers: false, format: Bash}
```
cd ~
```

2. Выведите соответствующий ему Windows путь (см. пример на иллюстрации 2-7):
{line-numbers: false, format: Bash}
```
pwd -W
```

3. В редакторе Notepad (Блокнот) или любом другом откройте файл `.bash_profile` из этого каталога.

4. В конец файла добавьте следующую строку:
{line-numbers: false, format: Bash}
```
PATH="/opt/firefox/bin:${PATH}"
```

Чтобы изменения вступили в силу, вам нужно перезапустить терминал MSYS2. Теперь если вы наберёте команду `firefox`, Bash найдёт соответствующий исполняемый файл по пути `/opt/firefox/bin` и запустит его.
